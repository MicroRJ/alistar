// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/spatial.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fspatial_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fspatial_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fspatial_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_s2clientprotocol_2fspatial_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fspatial_2eproto;
namespace SC2APIProtocol {
class ActionSpatial;
struct ActionSpatialDefaultTypeInternal;
extern ActionSpatialDefaultTypeInternal _ActionSpatial_default_instance_;
class ActionSpatialCameraMove;
struct ActionSpatialCameraMoveDefaultTypeInternal;
extern ActionSpatialCameraMoveDefaultTypeInternal _ActionSpatialCameraMove_default_instance_;
class ActionSpatialUnitCommand;
struct ActionSpatialUnitCommandDefaultTypeInternal;
extern ActionSpatialUnitCommandDefaultTypeInternal _ActionSpatialUnitCommand_default_instance_;
class ActionSpatialUnitSelectionPoint;
struct ActionSpatialUnitSelectionPointDefaultTypeInternal;
extern ActionSpatialUnitSelectionPointDefaultTypeInternal _ActionSpatialUnitSelectionPoint_default_instance_;
class ActionSpatialUnitSelectionRect;
struct ActionSpatialUnitSelectionRectDefaultTypeInternal;
extern ActionSpatialUnitSelectionRectDefaultTypeInternal _ActionSpatialUnitSelectionRect_default_instance_;
class FeatureLayers;
struct FeatureLayersDefaultTypeInternal;
extern FeatureLayersDefaultTypeInternal _FeatureLayers_default_instance_;
class FeatureLayersMinimap;
struct FeatureLayersMinimapDefaultTypeInternal;
extern FeatureLayersMinimapDefaultTypeInternal _FeatureLayersMinimap_default_instance_;
class ObservationFeatureLayer;
struct ObservationFeatureLayerDefaultTypeInternal;
extern ObservationFeatureLayerDefaultTypeInternal _ObservationFeatureLayer_default_instance_;
class ObservationRender;
struct ObservationRenderDefaultTypeInternal;
extern ObservationRenderDefaultTypeInternal _ObservationRender_default_instance_;
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> ::SC2APIProtocol::ActionSpatial* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatial>(Arena*);
template<> ::SC2APIProtocol::ActionSpatialCameraMove* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatialCameraMove>(Arena*);
template<> ::SC2APIProtocol::ActionSpatialUnitCommand* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatialUnitCommand>(Arena*);
template<> ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatialUnitSelectionPoint>(Arena*);
template<> ::SC2APIProtocol::ActionSpatialUnitSelectionRect* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatialUnitSelectionRect>(Arena*);
template<> ::SC2APIProtocol::FeatureLayers* Arena::CreateMaybeMessage<::SC2APIProtocol::FeatureLayers>(Arena*);
template<> ::SC2APIProtocol::FeatureLayersMinimap* Arena::CreateMaybeMessage<::SC2APIProtocol::FeatureLayersMinimap>(Arena*);
template<> ::SC2APIProtocol::ObservationFeatureLayer* Arena::CreateMaybeMessage<::SC2APIProtocol::ObservationFeatureLayer>(Arena*);
template<> ::SC2APIProtocol::ObservationRender* Arena::CreateMaybeMessage<::SC2APIProtocol::ObservationRender>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SC2APIProtocol {

enum ActionSpatialUnitSelectionPoint_Type : int {
  ActionSpatialUnitSelectionPoint_Type_Select = 1,
  ActionSpatialUnitSelectionPoint_Type_Toggle = 2,
  ActionSpatialUnitSelectionPoint_Type_AllType = 3,
  ActionSpatialUnitSelectionPoint_Type_AddAllType = 4
};
bool ActionSpatialUnitSelectionPoint_Type_IsValid(int value);
constexpr ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint_Type_Type_MIN = ActionSpatialUnitSelectionPoint_Type_Select;
constexpr ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint_Type_Type_MAX = ActionSpatialUnitSelectionPoint_Type_AddAllType;
constexpr int ActionSpatialUnitSelectionPoint_Type_Type_ARRAYSIZE = ActionSpatialUnitSelectionPoint_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionSpatialUnitSelectionPoint_Type_descriptor();
template<typename T>
inline const std::string& ActionSpatialUnitSelectionPoint_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionSpatialUnitSelectionPoint_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionSpatialUnitSelectionPoint_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionSpatialUnitSelectionPoint_Type_descriptor(), enum_t_value);
}
inline bool ActionSpatialUnitSelectionPoint_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionSpatialUnitSelectionPoint_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionSpatialUnitSelectionPoint_Type>(
    ActionSpatialUnitSelectionPoint_Type_descriptor(), name, value);
}
// ===================================================================

class ObservationFeatureLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObservationFeatureLayer) */ {
 public:
  inline ObservationFeatureLayer() : ObservationFeatureLayer(nullptr) {}
  ~ObservationFeatureLayer() override;
  explicit PROTOBUF_CONSTEXPR ObservationFeatureLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObservationFeatureLayer(const ObservationFeatureLayer& from);
  ObservationFeatureLayer(ObservationFeatureLayer&& from) noexcept
    : ObservationFeatureLayer() {
    *this = ::std::move(from);
  }

  inline ObservationFeatureLayer& operator=(const ObservationFeatureLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObservationFeatureLayer& operator=(ObservationFeatureLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObservationFeatureLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObservationFeatureLayer* internal_default_instance() {
    return reinterpret_cast<const ObservationFeatureLayer*>(
               &_ObservationFeatureLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ObservationFeatureLayer& a, ObservationFeatureLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ObservationFeatureLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObservationFeatureLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObservationFeatureLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObservationFeatureLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObservationFeatureLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObservationFeatureLayer& from) {
    ObservationFeatureLayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationFeatureLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ObservationFeatureLayer";
  }
  protected:
  explicit ObservationFeatureLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRendersFieldNumber = 1,
    kMinimapRendersFieldNumber = 2,
  };
  // optional .SC2APIProtocol.FeatureLayers renders = 1;
  bool has_renders() const;
  private:
  bool _internal_has_renders() const;
  public:
  void clear_renders();
  const ::SC2APIProtocol::FeatureLayers& renders() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::FeatureLayers* release_renders();
  ::SC2APIProtocol::FeatureLayers* mutable_renders();
  void set_allocated_renders(::SC2APIProtocol::FeatureLayers* renders);
  private:
  const ::SC2APIProtocol::FeatureLayers& _internal_renders() const;
  ::SC2APIProtocol::FeatureLayers* _internal_mutable_renders();
  public:
  void unsafe_arena_set_allocated_renders(
      ::SC2APIProtocol::FeatureLayers* renders);
  ::SC2APIProtocol::FeatureLayers* unsafe_arena_release_renders();

  // optional .SC2APIProtocol.FeatureLayersMinimap minimap_renders = 2;
  bool has_minimap_renders() const;
  private:
  bool _internal_has_minimap_renders() const;
  public:
  void clear_minimap_renders();
  const ::SC2APIProtocol::FeatureLayersMinimap& minimap_renders() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::FeatureLayersMinimap* release_minimap_renders();
  ::SC2APIProtocol::FeatureLayersMinimap* mutable_minimap_renders();
  void set_allocated_minimap_renders(::SC2APIProtocol::FeatureLayersMinimap* minimap_renders);
  private:
  const ::SC2APIProtocol::FeatureLayersMinimap& _internal_minimap_renders() const;
  ::SC2APIProtocol::FeatureLayersMinimap* _internal_mutable_minimap_renders();
  public:
  void unsafe_arena_set_allocated_minimap_renders(
      ::SC2APIProtocol::FeatureLayersMinimap* minimap_renders);
  ::SC2APIProtocol::FeatureLayersMinimap* unsafe_arena_release_minimap_renders();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObservationFeatureLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::FeatureLayers* renders_;
    ::SC2APIProtocol::FeatureLayersMinimap* minimap_renders_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class FeatureLayers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.FeatureLayers) */ {
 public:
  inline FeatureLayers() : FeatureLayers(nullptr) {}
  ~FeatureLayers() override;
  explicit PROTOBUF_CONSTEXPR FeatureLayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeatureLayers(const FeatureLayers& from);
  FeatureLayers(FeatureLayers&& from) noexcept
    : FeatureLayers() {
    *this = ::std::move(from);
  }

  inline FeatureLayers& operator=(const FeatureLayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureLayers& operator=(FeatureLayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeatureLayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureLayers* internal_default_instance() {
    return reinterpret_cast<const FeatureLayers*>(
               &_FeatureLayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FeatureLayers& a, FeatureLayers& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureLayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureLayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureLayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeatureLayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeatureLayers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeatureLayers& from) {
    FeatureLayers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureLayers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.FeatureLayers";
  }
  protected:
  explicit FeatureLayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightMapFieldNumber = 1,
    kVisibilityMapFieldNumber = 2,
    kCreepFieldNumber = 3,
    kPowerFieldNumber = 4,
    kPlayerIdFieldNumber = 5,
    kUnitTypeFieldNumber = 6,
    kSelectedFieldNumber = 7,
    kUnitHitPointsFieldNumber = 8,
    kUnitEnergyFieldNumber = 9,
    kUnitShieldsFieldNumber = 10,
    kPlayerRelativeFieldNumber = 11,
    kUnitDensityAaFieldNumber = 14,
    kUnitDensityFieldNumber = 15,
    kUnitHitPointsRatioFieldNumber = 17,
    kUnitEnergyRatioFieldNumber = 18,
    kUnitShieldsRatioFieldNumber = 19,
    kEffectsFieldNumber = 20,
    kHallucinationsFieldNumber = 21,
    kCloakedFieldNumber = 22,
    kBlipFieldNumber = 23,
    kBuffsFieldNumber = 24,
    kActiveFieldNumber = 25,
    kBuffDurationFieldNumber = 26,
    kBuildProgressFieldNumber = 27,
    kBuildableFieldNumber = 28,
    kPathableFieldNumber = 29,
    kPlaceholderFieldNumber = 30,
  };
  // optional .SC2APIProtocol.ImageData height_map = 1;
  bool has_height_map() const;
  private:
  bool _internal_has_height_map() const;
  public:
  void clear_height_map();
  const ::SC2APIProtocol::ImageData& height_map() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_height_map();
  ::SC2APIProtocol::ImageData* mutable_height_map();
  void set_allocated_height_map(::SC2APIProtocol::ImageData* height_map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_height_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_height_map();
  public:
  void unsafe_arena_set_allocated_height_map(
      ::SC2APIProtocol::ImageData* height_map);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_height_map();

  // optional .SC2APIProtocol.ImageData visibility_map = 2;
  bool has_visibility_map() const;
  private:
  bool _internal_has_visibility_map() const;
  public:
  void clear_visibility_map();
  const ::SC2APIProtocol::ImageData& visibility_map() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_visibility_map();
  ::SC2APIProtocol::ImageData* mutable_visibility_map();
  void set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_visibility_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_visibility_map();
  public:
  void unsafe_arena_set_allocated_visibility_map(
      ::SC2APIProtocol::ImageData* visibility_map);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_visibility_map();

  // optional .SC2APIProtocol.ImageData creep = 3;
  bool has_creep() const;
  private:
  bool _internal_has_creep() const;
  public:
  void clear_creep();
  const ::SC2APIProtocol::ImageData& creep() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_creep();
  ::SC2APIProtocol::ImageData* mutable_creep();
  void set_allocated_creep(::SC2APIProtocol::ImageData* creep);
  private:
  const ::SC2APIProtocol::ImageData& _internal_creep() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_creep();
  public:
  void unsafe_arena_set_allocated_creep(
      ::SC2APIProtocol::ImageData* creep);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_creep();

  // optional .SC2APIProtocol.ImageData power = 4;
  bool has_power() const;
  private:
  bool _internal_has_power() const;
  public:
  void clear_power();
  const ::SC2APIProtocol::ImageData& power() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_power();
  ::SC2APIProtocol::ImageData* mutable_power();
  void set_allocated_power(::SC2APIProtocol::ImageData* power);
  private:
  const ::SC2APIProtocol::ImageData& _internal_power() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_power();
  public:
  void unsafe_arena_set_allocated_power(
      ::SC2APIProtocol::ImageData* power);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_power();

  // optional .SC2APIProtocol.ImageData player_id = 5;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::SC2APIProtocol::ImageData& player_id() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_player_id();
  ::SC2APIProtocol::ImageData* mutable_player_id();
  void set_allocated_player_id(::SC2APIProtocol::ImageData* player_id);
  private:
  const ::SC2APIProtocol::ImageData& _internal_player_id() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::SC2APIProtocol::ImageData* player_id);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_player_id();

  // optional .SC2APIProtocol.ImageData unit_type = 6;
  bool has_unit_type() const;
  private:
  bool _internal_has_unit_type() const;
  public:
  void clear_unit_type();
  const ::SC2APIProtocol::ImageData& unit_type() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_type();
  ::SC2APIProtocol::ImageData* mutable_unit_type();
  void set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_type() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_type();
  public:
  void unsafe_arena_set_allocated_unit_type(
      ::SC2APIProtocol::ImageData* unit_type);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_type();

  // optional .SC2APIProtocol.ImageData selected = 7;
  bool has_selected() const;
  private:
  bool _internal_has_selected() const;
  public:
  void clear_selected();
  const ::SC2APIProtocol::ImageData& selected() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_selected();
  ::SC2APIProtocol::ImageData* mutable_selected();
  void set_allocated_selected(::SC2APIProtocol::ImageData* selected);
  private:
  const ::SC2APIProtocol::ImageData& _internal_selected() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_selected();
  public:
  void unsafe_arena_set_allocated_selected(
      ::SC2APIProtocol::ImageData* selected);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_selected();

  // optional .SC2APIProtocol.ImageData unit_hit_points = 8;
  bool has_unit_hit_points() const;
  private:
  bool _internal_has_unit_hit_points() const;
  public:
  void clear_unit_hit_points();
  const ::SC2APIProtocol::ImageData& unit_hit_points() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_hit_points();
  ::SC2APIProtocol::ImageData* mutable_unit_hit_points();
  void set_allocated_unit_hit_points(::SC2APIProtocol::ImageData* unit_hit_points);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_hit_points() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_hit_points();
  public:
  void unsafe_arena_set_allocated_unit_hit_points(
      ::SC2APIProtocol::ImageData* unit_hit_points);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_hit_points();

  // optional .SC2APIProtocol.ImageData unit_energy = 9;
  bool has_unit_energy() const;
  private:
  bool _internal_has_unit_energy() const;
  public:
  void clear_unit_energy();
  const ::SC2APIProtocol::ImageData& unit_energy() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_energy();
  ::SC2APIProtocol::ImageData* mutable_unit_energy();
  void set_allocated_unit_energy(::SC2APIProtocol::ImageData* unit_energy);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_energy() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_energy();
  public:
  void unsafe_arena_set_allocated_unit_energy(
      ::SC2APIProtocol::ImageData* unit_energy);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_energy();

  // optional .SC2APIProtocol.ImageData unit_shields = 10;
  bool has_unit_shields() const;
  private:
  bool _internal_has_unit_shields() const;
  public:
  void clear_unit_shields();
  const ::SC2APIProtocol::ImageData& unit_shields() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_shields();
  ::SC2APIProtocol::ImageData* mutable_unit_shields();
  void set_allocated_unit_shields(::SC2APIProtocol::ImageData* unit_shields);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_shields() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_shields();
  public:
  void unsafe_arena_set_allocated_unit_shields(
      ::SC2APIProtocol::ImageData* unit_shields);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_shields();

  // optional .SC2APIProtocol.ImageData player_relative = 11;
  bool has_player_relative() const;
  private:
  bool _internal_has_player_relative() const;
  public:
  void clear_player_relative();
  const ::SC2APIProtocol::ImageData& player_relative() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_player_relative();
  ::SC2APIProtocol::ImageData* mutable_player_relative();
  void set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative);
  private:
  const ::SC2APIProtocol::ImageData& _internal_player_relative() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_player_relative();
  public:
  void unsafe_arena_set_allocated_player_relative(
      ::SC2APIProtocol::ImageData* player_relative);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_player_relative();

  // optional .SC2APIProtocol.ImageData unit_density_aa = 14;
  bool has_unit_density_aa() const;
  private:
  bool _internal_has_unit_density_aa() const;
  public:
  void clear_unit_density_aa();
  const ::SC2APIProtocol::ImageData& unit_density_aa() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_density_aa();
  ::SC2APIProtocol::ImageData* mutable_unit_density_aa();
  void set_allocated_unit_density_aa(::SC2APIProtocol::ImageData* unit_density_aa);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_density_aa() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_density_aa();
  public:
  void unsafe_arena_set_allocated_unit_density_aa(
      ::SC2APIProtocol::ImageData* unit_density_aa);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_density_aa();

  // optional .SC2APIProtocol.ImageData unit_density = 15;
  bool has_unit_density() const;
  private:
  bool _internal_has_unit_density() const;
  public:
  void clear_unit_density();
  const ::SC2APIProtocol::ImageData& unit_density() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_density();
  ::SC2APIProtocol::ImageData* mutable_unit_density();
  void set_allocated_unit_density(::SC2APIProtocol::ImageData* unit_density);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_density() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_density();
  public:
  void unsafe_arena_set_allocated_unit_density(
      ::SC2APIProtocol::ImageData* unit_density);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_density();

  // optional .SC2APIProtocol.ImageData unit_hit_points_ratio = 17;
  bool has_unit_hit_points_ratio() const;
  private:
  bool _internal_has_unit_hit_points_ratio() const;
  public:
  void clear_unit_hit_points_ratio();
  const ::SC2APIProtocol::ImageData& unit_hit_points_ratio() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_hit_points_ratio();
  ::SC2APIProtocol::ImageData* mutable_unit_hit_points_ratio();
  void set_allocated_unit_hit_points_ratio(::SC2APIProtocol::ImageData* unit_hit_points_ratio);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_hit_points_ratio() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_hit_points_ratio();
  public:
  void unsafe_arena_set_allocated_unit_hit_points_ratio(
      ::SC2APIProtocol::ImageData* unit_hit_points_ratio);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_hit_points_ratio();

  // optional .SC2APIProtocol.ImageData unit_energy_ratio = 18;
  bool has_unit_energy_ratio() const;
  private:
  bool _internal_has_unit_energy_ratio() const;
  public:
  void clear_unit_energy_ratio();
  const ::SC2APIProtocol::ImageData& unit_energy_ratio() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_energy_ratio();
  ::SC2APIProtocol::ImageData* mutable_unit_energy_ratio();
  void set_allocated_unit_energy_ratio(::SC2APIProtocol::ImageData* unit_energy_ratio);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_energy_ratio() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_energy_ratio();
  public:
  void unsafe_arena_set_allocated_unit_energy_ratio(
      ::SC2APIProtocol::ImageData* unit_energy_ratio);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_energy_ratio();

  // optional .SC2APIProtocol.ImageData unit_shields_ratio = 19;
  bool has_unit_shields_ratio() const;
  private:
  bool _internal_has_unit_shields_ratio() const;
  public:
  void clear_unit_shields_ratio();
  const ::SC2APIProtocol::ImageData& unit_shields_ratio() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_shields_ratio();
  ::SC2APIProtocol::ImageData* mutable_unit_shields_ratio();
  void set_allocated_unit_shields_ratio(::SC2APIProtocol::ImageData* unit_shields_ratio);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_shields_ratio() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_shields_ratio();
  public:
  void unsafe_arena_set_allocated_unit_shields_ratio(
      ::SC2APIProtocol::ImageData* unit_shields_ratio);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_shields_ratio();

  // optional .SC2APIProtocol.ImageData effects = 20;
  bool has_effects() const;
  private:
  bool _internal_has_effects() const;
  public:
  void clear_effects();
  const ::SC2APIProtocol::ImageData& effects() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_effects();
  ::SC2APIProtocol::ImageData* mutable_effects();
  void set_allocated_effects(::SC2APIProtocol::ImageData* effects);
  private:
  const ::SC2APIProtocol::ImageData& _internal_effects() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_effects();
  public:
  void unsafe_arena_set_allocated_effects(
      ::SC2APIProtocol::ImageData* effects);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_effects();

  // optional .SC2APIProtocol.ImageData hallucinations = 21;
  bool has_hallucinations() const;
  private:
  bool _internal_has_hallucinations() const;
  public:
  void clear_hallucinations();
  const ::SC2APIProtocol::ImageData& hallucinations() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_hallucinations();
  ::SC2APIProtocol::ImageData* mutable_hallucinations();
  void set_allocated_hallucinations(::SC2APIProtocol::ImageData* hallucinations);
  private:
  const ::SC2APIProtocol::ImageData& _internal_hallucinations() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_hallucinations();
  public:
  void unsafe_arena_set_allocated_hallucinations(
      ::SC2APIProtocol::ImageData* hallucinations);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_hallucinations();

  // optional .SC2APIProtocol.ImageData cloaked = 22;
  bool has_cloaked() const;
  private:
  bool _internal_has_cloaked() const;
  public:
  void clear_cloaked();
  const ::SC2APIProtocol::ImageData& cloaked() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_cloaked();
  ::SC2APIProtocol::ImageData* mutable_cloaked();
  void set_allocated_cloaked(::SC2APIProtocol::ImageData* cloaked);
  private:
  const ::SC2APIProtocol::ImageData& _internal_cloaked() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_cloaked();
  public:
  void unsafe_arena_set_allocated_cloaked(
      ::SC2APIProtocol::ImageData* cloaked);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_cloaked();

  // optional .SC2APIProtocol.ImageData blip = 23;
  bool has_blip() const;
  private:
  bool _internal_has_blip() const;
  public:
  void clear_blip();
  const ::SC2APIProtocol::ImageData& blip() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_blip();
  ::SC2APIProtocol::ImageData* mutable_blip();
  void set_allocated_blip(::SC2APIProtocol::ImageData* blip);
  private:
  const ::SC2APIProtocol::ImageData& _internal_blip() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_blip();
  public:
  void unsafe_arena_set_allocated_blip(
      ::SC2APIProtocol::ImageData* blip);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_blip();

  // optional .SC2APIProtocol.ImageData buffs = 24;
  bool has_buffs() const;
  private:
  bool _internal_has_buffs() const;
  public:
  void clear_buffs();
  const ::SC2APIProtocol::ImageData& buffs() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_buffs();
  ::SC2APIProtocol::ImageData* mutable_buffs();
  void set_allocated_buffs(::SC2APIProtocol::ImageData* buffs);
  private:
  const ::SC2APIProtocol::ImageData& _internal_buffs() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_buffs();
  public:
  void unsafe_arena_set_allocated_buffs(
      ::SC2APIProtocol::ImageData* buffs);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_buffs();

  // optional .SC2APIProtocol.ImageData active = 25;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  const ::SC2APIProtocol::ImageData& active() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_active();
  ::SC2APIProtocol::ImageData* mutable_active();
  void set_allocated_active(::SC2APIProtocol::ImageData* active);
  private:
  const ::SC2APIProtocol::ImageData& _internal_active() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_active();
  public:
  void unsafe_arena_set_allocated_active(
      ::SC2APIProtocol::ImageData* active);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_active();

  // optional .SC2APIProtocol.ImageData buff_duration = 26;
  bool has_buff_duration() const;
  private:
  bool _internal_has_buff_duration() const;
  public:
  void clear_buff_duration();
  const ::SC2APIProtocol::ImageData& buff_duration() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_buff_duration();
  ::SC2APIProtocol::ImageData* mutable_buff_duration();
  void set_allocated_buff_duration(::SC2APIProtocol::ImageData* buff_duration);
  private:
  const ::SC2APIProtocol::ImageData& _internal_buff_duration() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_buff_duration();
  public:
  void unsafe_arena_set_allocated_buff_duration(
      ::SC2APIProtocol::ImageData* buff_duration);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_buff_duration();

  // optional .SC2APIProtocol.ImageData build_progress = 27;
  bool has_build_progress() const;
  private:
  bool _internal_has_build_progress() const;
  public:
  void clear_build_progress();
  const ::SC2APIProtocol::ImageData& build_progress() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_build_progress();
  ::SC2APIProtocol::ImageData* mutable_build_progress();
  void set_allocated_build_progress(::SC2APIProtocol::ImageData* build_progress);
  private:
  const ::SC2APIProtocol::ImageData& _internal_build_progress() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_build_progress();
  public:
  void unsafe_arena_set_allocated_build_progress(
      ::SC2APIProtocol::ImageData* build_progress);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_build_progress();

  // optional .SC2APIProtocol.ImageData buildable = 28;
  bool has_buildable() const;
  private:
  bool _internal_has_buildable() const;
  public:
  void clear_buildable();
  const ::SC2APIProtocol::ImageData& buildable() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_buildable();
  ::SC2APIProtocol::ImageData* mutable_buildable();
  void set_allocated_buildable(::SC2APIProtocol::ImageData* buildable);
  private:
  const ::SC2APIProtocol::ImageData& _internal_buildable() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_buildable();
  public:
  void unsafe_arena_set_allocated_buildable(
      ::SC2APIProtocol::ImageData* buildable);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_buildable();

  // optional .SC2APIProtocol.ImageData pathable = 29;
  bool has_pathable() const;
  private:
  bool _internal_has_pathable() const;
  public:
  void clear_pathable();
  const ::SC2APIProtocol::ImageData& pathable() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_pathable();
  ::SC2APIProtocol::ImageData* mutable_pathable();
  void set_allocated_pathable(::SC2APIProtocol::ImageData* pathable);
  private:
  const ::SC2APIProtocol::ImageData& _internal_pathable() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_pathable();
  public:
  void unsafe_arena_set_allocated_pathable(
      ::SC2APIProtocol::ImageData* pathable);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_pathable();

  // optional .SC2APIProtocol.ImageData placeholder = 30;
  bool has_placeholder() const;
  private:
  bool _internal_has_placeholder() const;
  public:
  void clear_placeholder();
  const ::SC2APIProtocol::ImageData& placeholder() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_placeholder();
  ::SC2APIProtocol::ImageData* mutable_placeholder();
  void set_allocated_placeholder(::SC2APIProtocol::ImageData* placeholder);
  private:
  const ::SC2APIProtocol::ImageData& _internal_placeholder() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_placeholder();
  public:
  void unsafe_arena_set_allocated_placeholder(
      ::SC2APIProtocol::ImageData* placeholder);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_placeholder();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.FeatureLayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::ImageData* height_map_;
    ::SC2APIProtocol::ImageData* visibility_map_;
    ::SC2APIProtocol::ImageData* creep_;
    ::SC2APIProtocol::ImageData* power_;
    ::SC2APIProtocol::ImageData* player_id_;
    ::SC2APIProtocol::ImageData* unit_type_;
    ::SC2APIProtocol::ImageData* selected_;
    ::SC2APIProtocol::ImageData* unit_hit_points_;
    ::SC2APIProtocol::ImageData* unit_energy_;
    ::SC2APIProtocol::ImageData* unit_shields_;
    ::SC2APIProtocol::ImageData* player_relative_;
    ::SC2APIProtocol::ImageData* unit_density_aa_;
    ::SC2APIProtocol::ImageData* unit_density_;
    ::SC2APIProtocol::ImageData* unit_hit_points_ratio_;
    ::SC2APIProtocol::ImageData* unit_energy_ratio_;
    ::SC2APIProtocol::ImageData* unit_shields_ratio_;
    ::SC2APIProtocol::ImageData* effects_;
    ::SC2APIProtocol::ImageData* hallucinations_;
    ::SC2APIProtocol::ImageData* cloaked_;
    ::SC2APIProtocol::ImageData* blip_;
    ::SC2APIProtocol::ImageData* buffs_;
    ::SC2APIProtocol::ImageData* active_;
    ::SC2APIProtocol::ImageData* buff_duration_;
    ::SC2APIProtocol::ImageData* build_progress_;
    ::SC2APIProtocol::ImageData* buildable_;
    ::SC2APIProtocol::ImageData* pathable_;
    ::SC2APIProtocol::ImageData* placeholder_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class FeatureLayersMinimap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.FeatureLayersMinimap) */ {
 public:
  inline FeatureLayersMinimap() : FeatureLayersMinimap(nullptr) {}
  ~FeatureLayersMinimap() override;
  explicit PROTOBUF_CONSTEXPR FeatureLayersMinimap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeatureLayersMinimap(const FeatureLayersMinimap& from);
  FeatureLayersMinimap(FeatureLayersMinimap&& from) noexcept
    : FeatureLayersMinimap() {
    *this = ::std::move(from);
  }

  inline FeatureLayersMinimap& operator=(const FeatureLayersMinimap& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureLayersMinimap& operator=(FeatureLayersMinimap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeatureLayersMinimap& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureLayersMinimap* internal_default_instance() {
    return reinterpret_cast<const FeatureLayersMinimap*>(
               &_FeatureLayersMinimap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FeatureLayersMinimap& a, FeatureLayersMinimap& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureLayersMinimap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureLayersMinimap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureLayersMinimap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeatureLayersMinimap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeatureLayersMinimap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeatureLayersMinimap& from) {
    FeatureLayersMinimap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureLayersMinimap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.FeatureLayersMinimap";
  }
  protected:
  explicit FeatureLayersMinimap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightMapFieldNumber = 1,
    kVisibilityMapFieldNumber = 2,
    kCreepFieldNumber = 3,
    kCameraFieldNumber = 4,
    kPlayerIdFieldNumber = 5,
    kPlayerRelativeFieldNumber = 6,
    kSelectedFieldNumber = 7,
    kUnitTypeFieldNumber = 8,
    kAlertsFieldNumber = 9,
    kBuildableFieldNumber = 10,
    kPathableFieldNumber = 11,
  };
  // optional .SC2APIProtocol.ImageData height_map = 1;
  bool has_height_map() const;
  private:
  bool _internal_has_height_map() const;
  public:
  void clear_height_map();
  const ::SC2APIProtocol::ImageData& height_map() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_height_map();
  ::SC2APIProtocol::ImageData* mutable_height_map();
  void set_allocated_height_map(::SC2APIProtocol::ImageData* height_map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_height_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_height_map();
  public:
  void unsafe_arena_set_allocated_height_map(
      ::SC2APIProtocol::ImageData* height_map);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_height_map();

  // optional .SC2APIProtocol.ImageData visibility_map = 2;
  bool has_visibility_map() const;
  private:
  bool _internal_has_visibility_map() const;
  public:
  void clear_visibility_map();
  const ::SC2APIProtocol::ImageData& visibility_map() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_visibility_map();
  ::SC2APIProtocol::ImageData* mutable_visibility_map();
  void set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_visibility_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_visibility_map();
  public:
  void unsafe_arena_set_allocated_visibility_map(
      ::SC2APIProtocol::ImageData* visibility_map);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_visibility_map();

  // optional .SC2APIProtocol.ImageData creep = 3;
  bool has_creep() const;
  private:
  bool _internal_has_creep() const;
  public:
  void clear_creep();
  const ::SC2APIProtocol::ImageData& creep() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_creep();
  ::SC2APIProtocol::ImageData* mutable_creep();
  void set_allocated_creep(::SC2APIProtocol::ImageData* creep);
  private:
  const ::SC2APIProtocol::ImageData& _internal_creep() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_creep();
  public:
  void unsafe_arena_set_allocated_creep(
      ::SC2APIProtocol::ImageData* creep);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_creep();

  // optional .SC2APIProtocol.ImageData camera = 4;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::SC2APIProtocol::ImageData& camera() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_camera();
  ::SC2APIProtocol::ImageData* mutable_camera();
  void set_allocated_camera(::SC2APIProtocol::ImageData* camera);
  private:
  const ::SC2APIProtocol::ImageData& _internal_camera() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_camera();
  public:
  void unsafe_arena_set_allocated_camera(
      ::SC2APIProtocol::ImageData* camera);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_camera();

  // optional .SC2APIProtocol.ImageData player_id = 5;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::SC2APIProtocol::ImageData& player_id() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_player_id();
  ::SC2APIProtocol::ImageData* mutable_player_id();
  void set_allocated_player_id(::SC2APIProtocol::ImageData* player_id);
  private:
  const ::SC2APIProtocol::ImageData& _internal_player_id() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::SC2APIProtocol::ImageData* player_id);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_player_id();

  // optional .SC2APIProtocol.ImageData player_relative = 6;
  bool has_player_relative() const;
  private:
  bool _internal_has_player_relative() const;
  public:
  void clear_player_relative();
  const ::SC2APIProtocol::ImageData& player_relative() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_player_relative();
  ::SC2APIProtocol::ImageData* mutable_player_relative();
  void set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative);
  private:
  const ::SC2APIProtocol::ImageData& _internal_player_relative() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_player_relative();
  public:
  void unsafe_arena_set_allocated_player_relative(
      ::SC2APIProtocol::ImageData* player_relative);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_player_relative();

  // optional .SC2APIProtocol.ImageData selected = 7;
  bool has_selected() const;
  private:
  bool _internal_has_selected() const;
  public:
  void clear_selected();
  const ::SC2APIProtocol::ImageData& selected() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_selected();
  ::SC2APIProtocol::ImageData* mutable_selected();
  void set_allocated_selected(::SC2APIProtocol::ImageData* selected);
  private:
  const ::SC2APIProtocol::ImageData& _internal_selected() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_selected();
  public:
  void unsafe_arena_set_allocated_selected(
      ::SC2APIProtocol::ImageData* selected);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_selected();

  // optional .SC2APIProtocol.ImageData unit_type = 8;
  bool has_unit_type() const;
  private:
  bool _internal_has_unit_type() const;
  public:
  void clear_unit_type();
  const ::SC2APIProtocol::ImageData& unit_type() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_unit_type();
  ::SC2APIProtocol::ImageData* mutable_unit_type();
  void set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_type() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_type();
  public:
  void unsafe_arena_set_allocated_unit_type(
      ::SC2APIProtocol::ImageData* unit_type);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_unit_type();

  // optional .SC2APIProtocol.ImageData alerts = 9;
  bool has_alerts() const;
  private:
  bool _internal_has_alerts() const;
  public:
  void clear_alerts();
  const ::SC2APIProtocol::ImageData& alerts() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_alerts();
  ::SC2APIProtocol::ImageData* mutable_alerts();
  void set_allocated_alerts(::SC2APIProtocol::ImageData* alerts);
  private:
  const ::SC2APIProtocol::ImageData& _internal_alerts() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_alerts();
  public:
  void unsafe_arena_set_allocated_alerts(
      ::SC2APIProtocol::ImageData* alerts);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_alerts();

  // optional .SC2APIProtocol.ImageData buildable = 10;
  bool has_buildable() const;
  private:
  bool _internal_has_buildable() const;
  public:
  void clear_buildable();
  const ::SC2APIProtocol::ImageData& buildable() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_buildable();
  ::SC2APIProtocol::ImageData* mutable_buildable();
  void set_allocated_buildable(::SC2APIProtocol::ImageData* buildable);
  private:
  const ::SC2APIProtocol::ImageData& _internal_buildable() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_buildable();
  public:
  void unsafe_arena_set_allocated_buildable(
      ::SC2APIProtocol::ImageData* buildable);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_buildable();

  // optional .SC2APIProtocol.ImageData pathable = 11;
  bool has_pathable() const;
  private:
  bool _internal_has_pathable() const;
  public:
  void clear_pathable();
  const ::SC2APIProtocol::ImageData& pathable() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_pathable();
  ::SC2APIProtocol::ImageData* mutable_pathable();
  void set_allocated_pathable(::SC2APIProtocol::ImageData* pathable);
  private:
  const ::SC2APIProtocol::ImageData& _internal_pathable() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_pathable();
  public:
  void unsafe_arena_set_allocated_pathable(
      ::SC2APIProtocol::ImageData* pathable);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_pathable();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.FeatureLayersMinimap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::ImageData* height_map_;
    ::SC2APIProtocol::ImageData* visibility_map_;
    ::SC2APIProtocol::ImageData* creep_;
    ::SC2APIProtocol::ImageData* camera_;
    ::SC2APIProtocol::ImageData* player_id_;
    ::SC2APIProtocol::ImageData* player_relative_;
    ::SC2APIProtocol::ImageData* selected_;
    ::SC2APIProtocol::ImageData* unit_type_;
    ::SC2APIProtocol::ImageData* alerts_;
    ::SC2APIProtocol::ImageData* buildable_;
    ::SC2APIProtocol::ImageData* pathable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ObservationRender final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObservationRender) */ {
 public:
  inline ObservationRender() : ObservationRender(nullptr) {}
  ~ObservationRender() override;
  explicit PROTOBUF_CONSTEXPR ObservationRender(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObservationRender(const ObservationRender& from);
  ObservationRender(ObservationRender&& from) noexcept
    : ObservationRender() {
    *this = ::std::move(from);
  }

  inline ObservationRender& operator=(const ObservationRender& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObservationRender& operator=(ObservationRender&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObservationRender& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObservationRender* internal_default_instance() {
    return reinterpret_cast<const ObservationRender*>(
               &_ObservationRender_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObservationRender& a, ObservationRender& b) {
    a.Swap(&b);
  }
  inline void Swap(ObservationRender* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObservationRender* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObservationRender* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObservationRender>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObservationRender& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObservationRender& from) {
    ObservationRender::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationRender* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ObservationRender";
  }
  protected:
  explicit ObservationRender(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapFieldNumber = 1,
    kMinimapFieldNumber = 2,
  };
  // optional .SC2APIProtocol.ImageData map = 1;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::SC2APIProtocol::ImageData& map() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_map();
  ::SC2APIProtocol::ImageData* mutable_map();
  void set_allocated_map(::SC2APIProtocol::ImageData* map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::SC2APIProtocol::ImageData* map);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_map();

  // optional .SC2APIProtocol.ImageData minimap = 2;
  bool has_minimap() const;
  private:
  bool _internal_has_minimap() const;
  public:
  void clear_minimap();
  const ::SC2APIProtocol::ImageData& minimap() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_minimap();
  ::SC2APIProtocol::ImageData* mutable_minimap();
  void set_allocated_minimap(::SC2APIProtocol::ImageData* minimap);
  private:
  const ::SC2APIProtocol::ImageData& _internal_minimap() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_minimap();
  public:
  void unsafe_arena_set_allocated_minimap(
      ::SC2APIProtocol::ImageData* minimap);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_minimap();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObservationRender)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::ImageData* map_;
    ::SC2APIProtocol::ImageData* minimap_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatial final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatial) */ {
 public:
  inline ActionSpatial() : ActionSpatial(nullptr) {}
  ~ActionSpatial() override;
  explicit PROTOBUF_CONSTEXPR ActionSpatial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionSpatial(const ActionSpatial& from);
  ActionSpatial(ActionSpatial&& from) noexcept
    : ActionSpatial() {
    *this = ::std::move(from);
  }

  inline ActionSpatial& operator=(const ActionSpatial& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatial& operator=(ActionSpatial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionSpatial& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kUnitCommand = 1,
    kCameraMove = 2,
    kUnitSelectionPoint = 3,
    kUnitSelectionRect = 4,
    ACTION_NOT_SET = 0,
  };

  static inline const ActionSpatial* internal_default_instance() {
    return reinterpret_cast<const ActionSpatial*>(
               &_ActionSpatial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ActionSpatial& a, ActionSpatial& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionSpatial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionSpatial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionSpatial>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionSpatial& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionSpatial& from) {
    ActionSpatial::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatial* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatial";
  }
  protected:
  explicit ActionSpatial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitCommandFieldNumber = 1,
    kCameraMoveFieldNumber = 2,
    kUnitSelectionPointFieldNumber = 3,
    kUnitSelectionRectFieldNumber = 4,
  };
  // .SC2APIProtocol.ActionSpatialUnitCommand unit_command = 1;
  bool has_unit_command() const;
  private:
  bool _internal_has_unit_command() const;
  public:
  void clear_unit_command();
  const ::SC2APIProtocol::ActionSpatialUnitCommand& unit_command() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ActionSpatialUnitCommand* release_unit_command();
  ::SC2APIProtocol::ActionSpatialUnitCommand* mutable_unit_command();
  void set_allocated_unit_command(::SC2APIProtocol::ActionSpatialUnitCommand* unit_command);
  private:
  const ::SC2APIProtocol::ActionSpatialUnitCommand& _internal_unit_command() const;
  ::SC2APIProtocol::ActionSpatialUnitCommand* _internal_mutable_unit_command();
  public:
  void unsafe_arena_set_allocated_unit_command(
      ::SC2APIProtocol::ActionSpatialUnitCommand* unit_command);
  ::SC2APIProtocol::ActionSpatialUnitCommand* unsafe_arena_release_unit_command();

  // .SC2APIProtocol.ActionSpatialCameraMove camera_move = 2;
  bool has_camera_move() const;
  private:
  bool _internal_has_camera_move() const;
  public:
  void clear_camera_move();
  const ::SC2APIProtocol::ActionSpatialCameraMove& camera_move() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ActionSpatialCameraMove* release_camera_move();
  ::SC2APIProtocol::ActionSpatialCameraMove* mutable_camera_move();
  void set_allocated_camera_move(::SC2APIProtocol::ActionSpatialCameraMove* camera_move);
  private:
  const ::SC2APIProtocol::ActionSpatialCameraMove& _internal_camera_move() const;
  ::SC2APIProtocol::ActionSpatialCameraMove* _internal_mutable_camera_move();
  public:
  void unsafe_arena_set_allocated_camera_move(
      ::SC2APIProtocol::ActionSpatialCameraMove* camera_move);
  ::SC2APIProtocol::ActionSpatialCameraMove* unsafe_arena_release_camera_move();

  // .SC2APIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;
  bool has_unit_selection_point() const;
  private:
  bool _internal_has_unit_selection_point() const;
  public:
  void clear_unit_selection_point();
  const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& unit_selection_point() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* release_unit_selection_point();
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* mutable_unit_selection_point();
  void set_allocated_unit_selection_point(::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point);
  private:
  const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& _internal_unit_selection_point() const;
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* _internal_mutable_unit_selection_point();
  public:
  void unsafe_arena_set_allocated_unit_selection_point(
      ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point);
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unsafe_arena_release_unit_selection_point();

  // .SC2APIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;
  bool has_unit_selection_rect() const;
  private:
  bool _internal_has_unit_selection_rect() const;
  public:
  void clear_unit_selection_rect();
  const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& unit_selection_rect() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ActionSpatialUnitSelectionRect* release_unit_selection_rect();
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* mutable_unit_selection_rect();
  void set_allocated_unit_selection_rect(::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect);
  private:
  const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& _internal_unit_selection_rect() const;
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* _internal_mutable_unit_selection_rect();
  public:
  void unsafe_arena_set_allocated_unit_selection_rect(
      ::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect);
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* unsafe_arena_release_unit_selection_rect();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatial)
 private:
  class _Internal;
  void set_has_unit_command();
  void set_has_camera_move();
  void set_has_unit_selection_point();
  void set_has_unit_selection_rect();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SC2APIProtocol::ActionSpatialUnitCommand* unit_command_;
      ::SC2APIProtocol::ActionSpatialCameraMove* camera_move_;
      ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point_;
      ::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatialUnitCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitCommand) */ {
 public:
  inline ActionSpatialUnitCommand() : ActionSpatialUnitCommand(nullptr) {}
  ~ActionSpatialUnitCommand() override;
  explicit PROTOBUF_CONSTEXPR ActionSpatialUnitCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionSpatialUnitCommand(const ActionSpatialUnitCommand& from);
  ActionSpatialUnitCommand(ActionSpatialUnitCommand&& from) noexcept
    : ActionSpatialUnitCommand() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitCommand& operator=(const ActionSpatialUnitCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatialUnitCommand& operator=(ActionSpatialUnitCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionSpatialUnitCommand& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kTargetScreenCoord = 2,
    kTargetMinimapCoord = 3,
    TARGET_NOT_SET = 0,
  };

  static inline const ActionSpatialUnitCommand* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitCommand*>(
               &_ActionSpatialUnitCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ActionSpatialUnitCommand& a, ActionSpatialUnitCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatialUnitCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionSpatialUnitCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionSpatialUnitCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionSpatialUnitCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionSpatialUnitCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionSpatialUnitCommand& from) {
    ActionSpatialUnitCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatialUnitCommand";
  }
  protected:
  explicit ActionSpatialUnitCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilityIdFieldNumber = 1,
    kQueueCommandFieldNumber = 4,
    kTargetScreenCoordFieldNumber = 2,
    kTargetMinimapCoordFieldNumber = 3,
  };
  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  int32_t ability_id() const;
  void set_ability_id(int32_t value);
  private:
  int32_t _internal_ability_id() const;
  void _internal_set_ability_id(int32_t value);
  public:

  // optional bool queue_command = 4;
  bool has_queue_command() const;
  private:
  bool _internal_has_queue_command() const;
  public:
  void clear_queue_command();
  bool queue_command() const;
  void set_queue_command(bool value);
  private:
  bool _internal_queue_command() const;
  void _internal_set_queue_command(bool value);
  public:

  // .SC2APIProtocol.PointI target_screen_coord = 2;
  bool has_target_screen_coord() const;
  private:
  bool _internal_has_target_screen_coord() const;
  public:
  void clear_target_screen_coord();
  const ::SC2APIProtocol::PointI& target_screen_coord() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::PointI* release_target_screen_coord();
  ::SC2APIProtocol::PointI* mutable_target_screen_coord();
  void set_allocated_target_screen_coord(::SC2APIProtocol::PointI* target_screen_coord);
  private:
  const ::SC2APIProtocol::PointI& _internal_target_screen_coord() const;
  ::SC2APIProtocol::PointI* _internal_mutable_target_screen_coord();
  public:
  void unsafe_arena_set_allocated_target_screen_coord(
      ::SC2APIProtocol::PointI* target_screen_coord);
  ::SC2APIProtocol::PointI* unsafe_arena_release_target_screen_coord();

  // .SC2APIProtocol.PointI target_minimap_coord = 3;
  bool has_target_minimap_coord() const;
  private:
  bool _internal_has_target_minimap_coord() const;
  public:
  void clear_target_minimap_coord();
  const ::SC2APIProtocol::PointI& target_minimap_coord() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::PointI* release_target_minimap_coord();
  ::SC2APIProtocol::PointI* mutable_target_minimap_coord();
  void set_allocated_target_minimap_coord(::SC2APIProtocol::PointI* target_minimap_coord);
  private:
  const ::SC2APIProtocol::PointI& _internal_target_minimap_coord() const;
  ::SC2APIProtocol::PointI* _internal_mutable_target_minimap_coord();
  public:
  void unsafe_arena_set_allocated_target_minimap_coord(
      ::SC2APIProtocol::PointI* target_minimap_coord);
  ::SC2APIProtocol::PointI* unsafe_arena_release_target_minimap_coord();

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitCommand)
 private:
  class _Internal;
  void set_has_target_screen_coord();
  void set_has_target_minimap_coord();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t ability_id_;
    bool queue_command_;
    union TargetUnion {
      constexpr TargetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SC2APIProtocol::PointI* target_screen_coord_;
      ::SC2APIProtocol::PointI* target_minimap_coord_;
    } target_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatialCameraMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialCameraMove) */ {
 public:
  inline ActionSpatialCameraMove() : ActionSpatialCameraMove(nullptr) {}
  ~ActionSpatialCameraMove() override;
  explicit PROTOBUF_CONSTEXPR ActionSpatialCameraMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionSpatialCameraMove(const ActionSpatialCameraMove& from);
  ActionSpatialCameraMove(ActionSpatialCameraMove&& from) noexcept
    : ActionSpatialCameraMove() {
    *this = ::std::move(from);
  }

  inline ActionSpatialCameraMove& operator=(const ActionSpatialCameraMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatialCameraMove& operator=(ActionSpatialCameraMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionSpatialCameraMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionSpatialCameraMove* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialCameraMove*>(
               &_ActionSpatialCameraMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ActionSpatialCameraMove& a, ActionSpatialCameraMove& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatialCameraMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionSpatialCameraMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionSpatialCameraMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionSpatialCameraMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionSpatialCameraMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionSpatialCameraMove& from) {
    ActionSpatialCameraMove::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialCameraMove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatialCameraMove";
  }
  protected:
  explicit ActionSpatialCameraMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterMinimapFieldNumber = 1,
  };
  // optional .SC2APIProtocol.PointI center_minimap = 1;
  bool has_center_minimap() const;
  private:
  bool _internal_has_center_minimap() const;
  public:
  void clear_center_minimap();
  const ::SC2APIProtocol::PointI& center_minimap() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::PointI* release_center_minimap();
  ::SC2APIProtocol::PointI* mutable_center_minimap();
  void set_allocated_center_minimap(::SC2APIProtocol::PointI* center_minimap);
  private:
  const ::SC2APIProtocol::PointI& _internal_center_minimap() const;
  ::SC2APIProtocol::PointI* _internal_mutable_center_minimap();
  public:
  void unsafe_arena_set_allocated_center_minimap(
      ::SC2APIProtocol::PointI* center_minimap);
  ::SC2APIProtocol::PointI* unsafe_arena_release_center_minimap();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialCameraMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::PointI* center_minimap_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatialUnitSelectionPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitSelectionPoint) */ {
 public:
  inline ActionSpatialUnitSelectionPoint() : ActionSpatialUnitSelectionPoint(nullptr) {}
  ~ActionSpatialUnitSelectionPoint() override;
  explicit PROTOBUF_CONSTEXPR ActionSpatialUnitSelectionPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionSpatialUnitSelectionPoint(const ActionSpatialUnitSelectionPoint& from);
  ActionSpatialUnitSelectionPoint(ActionSpatialUnitSelectionPoint&& from) noexcept
    : ActionSpatialUnitSelectionPoint() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitSelectionPoint& operator=(const ActionSpatialUnitSelectionPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatialUnitSelectionPoint& operator=(ActionSpatialUnitSelectionPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionSpatialUnitSelectionPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionSpatialUnitSelectionPoint* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitSelectionPoint*>(
               &_ActionSpatialUnitSelectionPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ActionSpatialUnitSelectionPoint& a, ActionSpatialUnitSelectionPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatialUnitSelectionPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionSpatialUnitSelectionPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionSpatialUnitSelectionPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionSpatialUnitSelectionPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionSpatialUnitSelectionPoint& from) {
    ActionSpatialUnitSelectionPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitSelectionPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatialUnitSelectionPoint";
  }
  protected:
  explicit ActionSpatialUnitSelectionPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionSpatialUnitSelectionPoint_Type Type;
  static constexpr Type Select =
    ActionSpatialUnitSelectionPoint_Type_Select;
  static constexpr Type Toggle =
    ActionSpatialUnitSelectionPoint_Type_Toggle;
  static constexpr Type AllType =
    ActionSpatialUnitSelectionPoint_Type_AllType;
  static constexpr Type AddAllType =
    ActionSpatialUnitSelectionPoint_Type_AddAllType;
  static inline bool Type_IsValid(int value) {
    return ActionSpatialUnitSelectionPoint_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ActionSpatialUnitSelectionPoint_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ActionSpatialUnitSelectionPoint_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ActionSpatialUnitSelectionPoint_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ActionSpatialUnitSelectionPoint_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ActionSpatialUnitSelectionPoint_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ActionSpatialUnitSelectionPoint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSelectionScreenCoordFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional .SC2APIProtocol.PointI selection_screen_coord = 1;
  bool has_selection_screen_coord() const;
  private:
  bool _internal_has_selection_screen_coord() const;
  public:
  void clear_selection_screen_coord();
  const ::SC2APIProtocol::PointI& selection_screen_coord() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::PointI* release_selection_screen_coord();
  ::SC2APIProtocol::PointI* mutable_selection_screen_coord();
  void set_allocated_selection_screen_coord(::SC2APIProtocol::PointI* selection_screen_coord);
  private:
  const ::SC2APIProtocol::PointI& _internal_selection_screen_coord() const;
  ::SC2APIProtocol::PointI* _internal_mutable_selection_screen_coord();
  public:
  void unsafe_arena_set_allocated_selection_screen_coord(
      ::SC2APIProtocol::PointI* selection_screen_coord);
  ::SC2APIProtocol::PointI* unsafe_arena_release_selection_screen_coord();

  // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type type() const;
  void set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value);
  private:
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type _internal_type() const;
  void _internal_set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitSelectionPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::PointI* selection_screen_coord_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatialUnitSelectionRect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitSelectionRect) */ {
 public:
  inline ActionSpatialUnitSelectionRect() : ActionSpatialUnitSelectionRect(nullptr) {}
  ~ActionSpatialUnitSelectionRect() override;
  explicit PROTOBUF_CONSTEXPR ActionSpatialUnitSelectionRect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionSpatialUnitSelectionRect(const ActionSpatialUnitSelectionRect& from);
  ActionSpatialUnitSelectionRect(ActionSpatialUnitSelectionRect&& from) noexcept
    : ActionSpatialUnitSelectionRect() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitSelectionRect& operator=(const ActionSpatialUnitSelectionRect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatialUnitSelectionRect& operator=(ActionSpatialUnitSelectionRect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionSpatialUnitSelectionRect& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionSpatialUnitSelectionRect* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitSelectionRect*>(
               &_ActionSpatialUnitSelectionRect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ActionSpatialUnitSelectionRect& a, ActionSpatialUnitSelectionRect& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatialUnitSelectionRect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionSpatialUnitSelectionRect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionSpatialUnitSelectionRect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionRect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionSpatialUnitSelectionRect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionSpatialUnitSelectionRect& from) {
    ActionSpatialUnitSelectionRect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitSelectionRect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatialUnitSelectionRect";
  }
  protected:
  explicit ActionSpatialUnitSelectionRect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectionScreenCoordFieldNumber = 1,
    kSelectionAddFieldNumber = 2,
  };
  // repeated .SC2APIProtocol.RectangleI selection_screen_coord = 1;
  int selection_screen_coord_size() const;
  private:
  int _internal_selection_screen_coord_size() const;
  public:
  void clear_selection_screen_coord();
  ::SC2APIProtocol::RectangleI* mutable_selection_screen_coord(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI >*
      mutable_selection_screen_coord();
  private:
  const ::SC2APIProtocol::RectangleI& _internal_selection_screen_coord(int index) const;
  ::SC2APIProtocol::RectangleI* _internal_add_selection_screen_coord();
  public:
  const ::SC2APIProtocol::RectangleI& selection_screen_coord(int index) const;
  ::SC2APIProtocol::RectangleI* add_selection_screen_coord();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI >&
      selection_screen_coord() const;

  // optional bool selection_add = 2;
  bool has_selection_add() const;
  private:
  bool _internal_has_selection_add() const;
  public:
  void clear_selection_add();
  bool selection_add() const;
  void set_selection_add(bool value);
  private:
  bool _internal_selection_add() const;
  void _internal_set_selection_add(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitSelectionRect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI > selection_screen_coord_;
    bool selection_add_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObservationFeatureLayer

// optional .SC2APIProtocol.FeatureLayers renders = 1;
inline bool ObservationFeatureLayer::_internal_has_renders() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.renders_ != nullptr);
  return value;
}
inline bool ObservationFeatureLayer::has_renders() const {
  return _internal_has_renders();
}
inline void ObservationFeatureLayer::clear_renders() {
  if (_impl_.renders_ != nullptr) _impl_.renders_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::FeatureLayers& ObservationFeatureLayer::_internal_renders() const {
  const ::SC2APIProtocol::FeatureLayers* p = _impl_.renders_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::FeatureLayers&>(
      ::SC2APIProtocol::_FeatureLayers_default_instance_);
}
inline const ::SC2APIProtocol::FeatureLayers& ObservationFeatureLayer::renders() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationFeatureLayer.renders)
  return _internal_renders();
}
inline void ObservationFeatureLayer::unsafe_arena_set_allocated_renders(
    ::SC2APIProtocol::FeatureLayers* renders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.renders_);
  }
  _impl_.renders_ = renders;
  if (renders) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ObservationFeatureLayer.renders)
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::release_renders() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::FeatureLayers* temp = _impl_.renders_;
  _impl_.renders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::unsafe_arena_release_renders() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationFeatureLayer.renders)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::FeatureLayers* temp = _impl_.renders_;
  _impl_.renders_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::_internal_mutable_renders() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.renders_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::FeatureLayers>(GetArenaForAllocation());
    _impl_.renders_ = p;
  }
  return _impl_.renders_;
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::mutable_renders() {
  ::SC2APIProtocol::FeatureLayers* _msg = _internal_mutable_renders();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationFeatureLayer.renders)
  return _msg;
}
inline void ObservationFeatureLayer::set_allocated_renders(::SC2APIProtocol::FeatureLayers* renders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.renders_;
  }
  if (renders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(renders);
    if (message_arena != submessage_arena) {
      renders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, renders, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.renders_ = renders;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationFeatureLayer.renders)
}

// optional .SC2APIProtocol.FeatureLayersMinimap minimap_renders = 2;
inline bool ObservationFeatureLayer::_internal_has_minimap_renders() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimap_renders_ != nullptr);
  return value;
}
inline bool ObservationFeatureLayer::has_minimap_renders() const {
  return _internal_has_minimap_renders();
}
inline void ObservationFeatureLayer::clear_minimap_renders() {
  if (_impl_.minimap_renders_ != nullptr) _impl_.minimap_renders_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::FeatureLayersMinimap& ObservationFeatureLayer::_internal_minimap_renders() const {
  const ::SC2APIProtocol::FeatureLayersMinimap* p = _impl_.minimap_renders_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::FeatureLayersMinimap&>(
      ::SC2APIProtocol::_FeatureLayersMinimap_default_instance_);
}
inline const ::SC2APIProtocol::FeatureLayersMinimap& ObservationFeatureLayer::minimap_renders() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  return _internal_minimap_renders();
}
inline void ObservationFeatureLayer::unsafe_arena_set_allocated_minimap_renders(
    ::SC2APIProtocol::FeatureLayersMinimap* minimap_renders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minimap_renders_);
  }
  _impl_.minimap_renders_ = minimap_renders;
  if (minimap_renders) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::release_minimap_renders() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::FeatureLayersMinimap* temp = _impl_.minimap_renders_;
  _impl_.minimap_renders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::unsafe_arena_release_minimap_renders() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::FeatureLayersMinimap* temp = _impl_.minimap_renders_;
  _impl_.minimap_renders_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::_internal_mutable_minimap_renders() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.minimap_renders_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::FeatureLayersMinimap>(GetArenaForAllocation());
    _impl_.minimap_renders_ = p;
  }
  return _impl_.minimap_renders_;
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::mutable_minimap_renders() {
  ::SC2APIProtocol::FeatureLayersMinimap* _msg = _internal_mutable_minimap_renders();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  return _msg;
}
inline void ObservationFeatureLayer::set_allocated_minimap_renders(::SC2APIProtocol::FeatureLayersMinimap* minimap_renders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.minimap_renders_;
  }
  if (minimap_renders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(minimap_renders);
    if (message_arena != submessage_arena) {
      minimap_renders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimap_renders, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.minimap_renders_ = minimap_renders;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
}

// -------------------------------------------------------------------

// FeatureLayers

// optional .SC2APIProtocol.ImageData height_map = 1;
inline bool FeatureLayers::_internal_has_height_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.height_map_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_height_map() const {
  return _internal_has_height_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_height_map() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.height_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::height_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.height_map)
  return _internal_height_map();
}
inline void FeatureLayers::unsafe_arena_set_allocated_height_map(
    ::SC2APIProtocol::ImageData* height_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.height_map_);
  }
  _impl_.height_map_ = height_map;
  if (height_map) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.height_map)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_height_map() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = _impl_.height_map_;
  _impl_.height_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_height_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.height_map)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = _impl_.height_map_;
  _impl_.height_map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_height_map() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.height_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.height_map_ = p;
  }
  return _impl_.height_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_height_map() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_height_map();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.height_map)
  return _msg;
}
inline void FeatureLayers::set_allocated_height_map(::SC2APIProtocol::ImageData* height_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.height_map_);
  }
  if (height_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(height_map));
    if (message_arena != submessage_arena) {
      height_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, height_map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.height_map_ = height_map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.height_map)
}

// optional .SC2APIProtocol.ImageData visibility_map = 2;
inline bool FeatureLayers::_internal_has_visibility_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.visibility_map_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_visibility_map() const {
  return _internal_has_visibility_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_visibility_map() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.visibility_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::visibility_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.visibility_map)
  return _internal_visibility_map();
}
inline void FeatureLayers::unsafe_arena_set_allocated_visibility_map(
    ::SC2APIProtocol::ImageData* visibility_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_map_);
  }
  _impl_.visibility_map_ = visibility_map;
  if (visibility_map) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.visibility_map)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_visibility_map() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.visibility_map_;
  _impl_.visibility_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_visibility_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.visibility_map)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.visibility_map_;
  _impl_.visibility_map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_visibility_map() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.visibility_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.visibility_map_ = p;
  }
  return _impl_.visibility_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_visibility_map() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_visibility_map();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.visibility_map)
  return _msg;
}
inline void FeatureLayers::set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_map_);
  }
  if (visibility_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visibility_map));
    if (message_arena != submessage_arena) {
      visibility_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility_map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.visibility_map_ = visibility_map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.visibility_map)
}

// optional .SC2APIProtocol.ImageData creep = 3;
inline bool FeatureLayers::_internal_has_creep() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creep_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_creep() const {
  return _internal_has_creep();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_creep() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.creep_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::creep() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.creep)
  return _internal_creep();
}
inline void FeatureLayers::unsafe_arena_set_allocated_creep(
    ::SC2APIProtocol::ImageData* creep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creep_);
  }
  _impl_.creep_ = creep;
  if (creep) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.creep)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_creep() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ImageData* temp = _impl_.creep_;
  _impl_.creep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_creep() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.creep)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ImageData* temp = _impl_.creep_;
  _impl_.creep_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_creep() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.creep_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.creep_ = p;
  }
  return _impl_.creep_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_creep() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_creep();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.creep)
  return _msg;
}
inline void FeatureLayers::set_allocated_creep(::SC2APIProtocol::ImageData* creep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creep_);
  }
  if (creep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creep));
    if (message_arena != submessage_arena) {
      creep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.creep)
}

// optional .SC2APIProtocol.ImageData power = 4;
inline bool FeatureLayers::_internal_has_power() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.power_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_power() const {
  return _internal_has_power();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_power() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.power_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::power() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.power)
  return _internal_power();
}
inline void FeatureLayers::unsafe_arena_set_allocated_power(
    ::SC2APIProtocol::ImageData* power) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.power_);
  }
  _impl_.power_ = power;
  if (power) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.power)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_power() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ImageData* temp = _impl_.power_;
  _impl_.power_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_power() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.power)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ImageData* temp = _impl_.power_;
  _impl_.power_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_power() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.power_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.power_ = p;
  }
  return _impl_.power_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_power() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_power();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.power)
  return _msg;
}
inline void FeatureLayers::set_allocated_power(::SC2APIProtocol::ImageData* power) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.power_);
  }
  if (power) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(power));
    if (message_arena != submessage_arena) {
      power = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.power_ = power;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.power)
}

// optional .SC2APIProtocol.ImageData player_id = 5;
inline bool FeatureLayers::_internal_has_player_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_id_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_player_id() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.player_id)
  return _internal_player_id();
}
inline void FeatureLayers::unsafe_arena_set_allocated_player_id(
    ::SC2APIProtocol::ImageData* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_id_);
  }
  _impl_.player_id_ = player_id;
  if (player_id) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.player_id)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_player_id() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::ImageData* temp = _impl_.player_id_;
  _impl_.player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.player_id)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::ImageData* temp = _impl_.player_id_;
  _impl_.player_id_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_player_id() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.player_id_ = p;
  }
  return _impl_.player_id_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_player_id() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.player_id)
  return _msg;
}
inline void FeatureLayers::set_allocated_player_id(::SC2APIProtocol::ImageData* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.player_id)
}

// optional .SC2APIProtocol.ImageData unit_type = 6;
inline bool FeatureLayers::_internal_has_unit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_type_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_type() const {
  return _internal_has_unit_type();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_type() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_type)
  return _internal_unit_type();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_type(
    ::SC2APIProtocol::ImageData* unit_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_type_);
  }
  _impl_.unit_type_ = unit_type;
  if (unit_type) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_type)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_type() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_type_;
  _impl_.unit_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_type() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_type)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_type_;
  _impl_.unit_type_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_type() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.unit_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_type_ = p;
  }
  return _impl_.unit_type_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_type() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_type();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_type)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_type_);
  }
  if (unit_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_type));
    if (message_arena != submessage_arena) {
      unit_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.unit_type_ = unit_type;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_type)
}

// optional .SC2APIProtocol.ImageData selected = 7;
inline bool FeatureLayers::_internal_has_selected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selected_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_selected() const {
  return _internal_has_selected();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_selected() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.selected_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::selected() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.selected)
  return _internal_selected();
}
inline void FeatureLayers::unsafe_arena_set_allocated_selected(
    ::SC2APIProtocol::ImageData* selected) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selected_);
  }
  _impl_.selected_ = selected;
  if (selected) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.selected)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_selected() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::SC2APIProtocol::ImageData* temp = _impl_.selected_;
  _impl_.selected_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_selected() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.selected)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::SC2APIProtocol::ImageData* temp = _impl_.selected_;
  _impl_.selected_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_selected() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.selected_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.selected_ = p;
  }
  return _impl_.selected_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_selected() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_selected();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.selected)
  return _msg;
}
inline void FeatureLayers::set_allocated_selected(::SC2APIProtocol::ImageData* selected) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selected_);
  }
  if (selected) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(selected));
    if (message_arena != submessage_arena) {
      selected = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selected, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.selected_ = selected;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.selected)
}

// optional .SC2APIProtocol.ImageData unit_hit_points = 8;
inline bool FeatureLayers::_internal_has_unit_hit_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_hit_points_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_hit_points() const {
  return _internal_has_unit_hit_points();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_hit_points() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_hit_points_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_hit_points() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_hit_points)
  return _internal_unit_hit_points();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_hit_points(
    ::SC2APIProtocol::ImageData* unit_hit_points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_hit_points_);
  }
  _impl_.unit_hit_points_ = unit_hit_points;
  if (unit_hit_points) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_hit_points)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_hit_points() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_hit_points_;
  _impl_.unit_hit_points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_hit_points() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_hit_points)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_hit_points_;
  _impl_.unit_hit_points_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_hit_points() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.unit_hit_points_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_hit_points_ = p;
  }
  return _impl_.unit_hit_points_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_hit_points() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_hit_points();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_hit_points)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_hit_points(::SC2APIProtocol::ImageData* unit_hit_points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_hit_points_);
  }
  if (unit_hit_points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_hit_points));
    if (message_arena != submessage_arena) {
      unit_hit_points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_hit_points, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.unit_hit_points_ = unit_hit_points;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_hit_points)
}

// optional .SC2APIProtocol.ImageData unit_hit_points_ratio = 17;
inline bool FeatureLayers::_internal_has_unit_hit_points_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_hit_points_ratio_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_hit_points_ratio() const {
  return _internal_has_unit_hit_points_ratio();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_hit_points_ratio() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_hit_points_ratio_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_hit_points_ratio() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  return _internal_unit_hit_points_ratio();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_hit_points_ratio(
    ::SC2APIProtocol::ImageData* unit_hit_points_ratio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_hit_points_ratio_);
  }
  _impl_.unit_hit_points_ratio_ = unit_hit_points_ratio;
  if (unit_hit_points_ratio) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_hit_points_ratio() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_hit_points_ratio_;
  _impl_.unit_hit_points_ratio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_hit_points_ratio() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_hit_points_ratio_;
  _impl_.unit_hit_points_ratio_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_hit_points_ratio() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.unit_hit_points_ratio_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_hit_points_ratio_ = p;
  }
  return _impl_.unit_hit_points_ratio_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_hit_points_ratio() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_hit_points_ratio();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_hit_points_ratio(::SC2APIProtocol::ImageData* unit_hit_points_ratio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_hit_points_ratio_);
  }
  if (unit_hit_points_ratio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_hit_points_ratio));
    if (message_arena != submessage_arena) {
      unit_hit_points_ratio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_hit_points_ratio, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.unit_hit_points_ratio_ = unit_hit_points_ratio;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
}

// optional .SC2APIProtocol.ImageData unit_energy = 9;
inline bool FeatureLayers::_internal_has_unit_energy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_energy_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_energy() const {
  return _internal_has_unit_energy();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_energy() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_energy_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_energy() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_energy)
  return _internal_unit_energy();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_energy(
    ::SC2APIProtocol::ImageData* unit_energy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_energy_);
  }
  _impl_.unit_energy_ = unit_energy;
  if (unit_energy) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_energy)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_energy() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_energy_;
  _impl_.unit_energy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_energy() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_energy)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_energy_;
  _impl_.unit_energy_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_energy() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.unit_energy_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_energy_ = p;
  }
  return _impl_.unit_energy_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_energy() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_energy();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_energy)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_energy(::SC2APIProtocol::ImageData* unit_energy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_energy_);
  }
  if (unit_energy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_energy));
    if (message_arena != submessage_arena) {
      unit_energy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_energy, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.unit_energy_ = unit_energy;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_energy)
}

// optional .SC2APIProtocol.ImageData unit_energy_ratio = 18;
inline bool FeatureLayers::_internal_has_unit_energy_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_energy_ratio_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_energy_ratio() const {
  return _internal_has_unit_energy_ratio();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_energy_ratio() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_energy_ratio_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_energy_ratio() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
  return _internal_unit_energy_ratio();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_energy_ratio(
    ::SC2APIProtocol::ImageData* unit_energy_ratio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_energy_ratio_);
  }
  _impl_.unit_energy_ratio_ = unit_energy_ratio;
  if (unit_energy_ratio) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_energy_ratio() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_energy_ratio_;
  _impl_.unit_energy_ratio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_energy_ratio() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_energy_ratio_;
  _impl_.unit_energy_ratio_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_energy_ratio() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.unit_energy_ratio_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_energy_ratio_ = p;
  }
  return _impl_.unit_energy_ratio_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_energy_ratio() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_energy_ratio();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_energy_ratio(::SC2APIProtocol::ImageData* unit_energy_ratio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_energy_ratio_);
  }
  if (unit_energy_ratio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_energy_ratio));
    if (message_arena != submessage_arena) {
      unit_energy_ratio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_energy_ratio, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.unit_energy_ratio_ = unit_energy_ratio;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
}

// optional .SC2APIProtocol.ImageData unit_shields = 10;
inline bool FeatureLayers::_internal_has_unit_shields() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_shields_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_shields() const {
  return _internal_has_unit_shields();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_shields() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_shields_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_shields() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_shields)
  return _internal_unit_shields();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_shields(
    ::SC2APIProtocol::ImageData* unit_shields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_shields_);
  }
  _impl_.unit_shields_ = unit_shields;
  if (unit_shields) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_shields)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_shields() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_shields_;
  _impl_.unit_shields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_shields() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_shields)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_shields_;
  _impl_.unit_shields_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_shields() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.unit_shields_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_shields_ = p;
  }
  return _impl_.unit_shields_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_shields() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_shields();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_shields)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_shields(::SC2APIProtocol::ImageData* unit_shields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_shields_);
  }
  if (unit_shields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_shields));
    if (message_arena != submessage_arena) {
      unit_shields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_shields, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.unit_shields_ = unit_shields;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_shields)
}

// optional .SC2APIProtocol.ImageData unit_shields_ratio = 19;
inline bool FeatureLayers::_internal_has_unit_shields_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_shields_ratio_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_shields_ratio() const {
  return _internal_has_unit_shields_ratio();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_shields_ratio() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_shields_ratio_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_shields_ratio() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
  return _internal_unit_shields_ratio();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_shields_ratio(
    ::SC2APIProtocol::ImageData* unit_shields_ratio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_shields_ratio_);
  }
  _impl_.unit_shields_ratio_ = unit_shields_ratio;
  if (unit_shields_ratio) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_shields_ratio() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_shields_ratio_;
  _impl_.unit_shields_ratio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_shields_ratio() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_shields_ratio_;
  _impl_.unit_shields_ratio_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_shields_ratio() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.unit_shields_ratio_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_shields_ratio_ = p;
  }
  return _impl_.unit_shields_ratio_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_shields_ratio() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_shields_ratio();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_shields_ratio(::SC2APIProtocol::ImageData* unit_shields_ratio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_shields_ratio_);
  }
  if (unit_shields_ratio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_shields_ratio));
    if (message_arena != submessage_arena) {
      unit_shields_ratio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_shields_ratio, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.unit_shields_ratio_ = unit_shields_ratio;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
}

// optional .SC2APIProtocol.ImageData player_relative = 11;
inline bool FeatureLayers::_internal_has_player_relative() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_relative_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_player_relative() const {
  return _internal_has_player_relative();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_player_relative() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.player_relative_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::player_relative() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.player_relative)
  return _internal_player_relative();
}
inline void FeatureLayers::unsafe_arena_set_allocated_player_relative(
    ::SC2APIProtocol::ImageData* player_relative) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_relative_);
  }
  _impl_.player_relative_ = player_relative;
  if (player_relative) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.player_relative)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_player_relative() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::SC2APIProtocol::ImageData* temp = _impl_.player_relative_;
  _impl_.player_relative_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_player_relative() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.player_relative)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::SC2APIProtocol::ImageData* temp = _impl_.player_relative_;
  _impl_.player_relative_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_player_relative() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.player_relative_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.player_relative_ = p;
  }
  return _impl_.player_relative_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_player_relative() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_player_relative();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.player_relative)
  return _msg;
}
inline void FeatureLayers::set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_relative_);
  }
  if (player_relative) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_relative));
    if (message_arena != submessage_arena) {
      player_relative = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_relative, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.player_relative_ = player_relative;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.player_relative)
}

// optional .SC2APIProtocol.ImageData unit_density_aa = 14;
inline bool FeatureLayers::_internal_has_unit_density_aa() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_density_aa_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_density_aa() const {
  return _internal_has_unit_density_aa();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_density_aa() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_density_aa_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_density_aa() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_density_aa)
  return _internal_unit_density_aa();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_density_aa(
    ::SC2APIProtocol::ImageData* unit_density_aa) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_density_aa_);
  }
  _impl_.unit_density_aa_ = unit_density_aa;
  if (unit_density_aa) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_density_aa)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_density_aa() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_density_aa_;
  _impl_.unit_density_aa_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_density_aa() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_density_aa)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_density_aa_;
  _impl_.unit_density_aa_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_density_aa() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.unit_density_aa_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_density_aa_ = p;
  }
  return _impl_.unit_density_aa_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_density_aa() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_density_aa();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_density_aa)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_density_aa(::SC2APIProtocol::ImageData* unit_density_aa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_density_aa_);
  }
  if (unit_density_aa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_density_aa));
    if (message_arena != submessage_arena) {
      unit_density_aa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_density_aa, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.unit_density_aa_ = unit_density_aa;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_density_aa)
}

// optional .SC2APIProtocol.ImageData unit_density = 15;
inline bool FeatureLayers::_internal_has_unit_density() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_density_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_density() const {
  return _internal_has_unit_density();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_density() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_density_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_density() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_density)
  return _internal_unit_density();
}
inline void FeatureLayers::unsafe_arena_set_allocated_unit_density(
    ::SC2APIProtocol::ImageData* unit_density) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_density_);
  }
  _impl_.unit_density_ = unit_density;
  if (unit_density) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.unit_density)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_density() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_density_;
  _impl_.unit_density_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_unit_density() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_density)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_density_;
  _impl_.unit_density_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_density() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.unit_density_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_density_ = p;
  }
  return _impl_.unit_density_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_density() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_density();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_density)
  return _msg;
}
inline void FeatureLayers::set_allocated_unit_density(::SC2APIProtocol::ImageData* unit_density) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_density_);
  }
  if (unit_density) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_density));
    if (message_arena != submessage_arena) {
      unit_density = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_density, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.unit_density_ = unit_density;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_density)
}

// optional .SC2APIProtocol.ImageData effects = 20;
inline bool FeatureLayers::_internal_has_effects() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.effects_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_effects() const {
  return _internal_has_effects();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_effects() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.effects_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::effects() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.effects)
  return _internal_effects();
}
inline void FeatureLayers::unsafe_arena_set_allocated_effects(
    ::SC2APIProtocol::ImageData* effects) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.effects_);
  }
  _impl_.effects_ = effects;
  if (effects) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.effects)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_effects() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.effects_;
  _impl_.effects_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_effects() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.effects)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.effects_;
  _impl_.effects_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_effects() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.effects_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.effects_ = p;
  }
  return _impl_.effects_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_effects() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_effects();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.effects)
  return _msg;
}
inline void FeatureLayers::set_allocated_effects(::SC2APIProtocol::ImageData* effects) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.effects_);
  }
  if (effects) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(effects));
    if (message_arena != submessage_arena) {
      effects = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, effects, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.effects_ = effects;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.effects)
}

// optional .SC2APIProtocol.ImageData hallucinations = 21;
inline bool FeatureLayers::_internal_has_hallucinations() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hallucinations_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_hallucinations() const {
  return _internal_has_hallucinations();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_hallucinations() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.hallucinations_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::hallucinations() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.hallucinations)
  return _internal_hallucinations();
}
inline void FeatureLayers::unsafe_arena_set_allocated_hallucinations(
    ::SC2APIProtocol::ImageData* hallucinations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hallucinations_);
  }
  _impl_.hallucinations_ = hallucinations;
  if (hallucinations) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.hallucinations)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_hallucinations() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.hallucinations_;
  _impl_.hallucinations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_hallucinations() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.hallucinations)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.hallucinations_;
  _impl_.hallucinations_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_hallucinations() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.hallucinations_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.hallucinations_ = p;
  }
  return _impl_.hallucinations_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_hallucinations() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_hallucinations();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.hallucinations)
  return _msg;
}
inline void FeatureLayers::set_allocated_hallucinations(::SC2APIProtocol::ImageData* hallucinations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hallucinations_);
  }
  if (hallucinations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hallucinations));
    if (message_arena != submessage_arena) {
      hallucinations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hallucinations, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.hallucinations_ = hallucinations;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.hallucinations)
}

// optional .SC2APIProtocol.ImageData cloaked = 22;
inline bool FeatureLayers::_internal_has_cloaked() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cloaked_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_cloaked() const {
  return _internal_has_cloaked();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_cloaked() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.cloaked_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::cloaked() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.cloaked)
  return _internal_cloaked();
}
inline void FeatureLayers::unsafe_arena_set_allocated_cloaked(
    ::SC2APIProtocol::ImageData* cloaked) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cloaked_);
  }
  _impl_.cloaked_ = cloaked;
  if (cloaked) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.cloaked)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_cloaked() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.cloaked_;
  _impl_.cloaked_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_cloaked() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.cloaked)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.cloaked_;
  _impl_.cloaked_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_cloaked() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.cloaked_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.cloaked_ = p;
  }
  return _impl_.cloaked_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_cloaked() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_cloaked();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.cloaked)
  return _msg;
}
inline void FeatureLayers::set_allocated_cloaked(::SC2APIProtocol::ImageData* cloaked) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cloaked_);
  }
  if (cloaked) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cloaked));
    if (message_arena != submessage_arena) {
      cloaked = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cloaked, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.cloaked_ = cloaked;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.cloaked)
}

// optional .SC2APIProtocol.ImageData blip = 23;
inline bool FeatureLayers::_internal_has_blip() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.blip_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_blip() const {
  return _internal_has_blip();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_blip() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.blip_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::blip() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.blip)
  return _internal_blip();
}
inline void FeatureLayers::unsafe_arena_set_allocated_blip(
    ::SC2APIProtocol::ImageData* blip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blip_);
  }
  _impl_.blip_ = blip;
  if (blip) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.blip)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_blip() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.blip_;
  _impl_.blip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_blip() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.blip)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.blip_;
  _impl_.blip_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_blip() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.blip_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.blip_ = p;
  }
  return _impl_.blip_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_blip() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_blip();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.blip)
  return _msg;
}
inline void FeatureLayers::set_allocated_blip(::SC2APIProtocol::ImageData* blip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blip_);
  }
  if (blip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blip));
    if (message_arena != submessage_arena) {
      blip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.blip_ = blip;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.blip)
}

// optional .SC2APIProtocol.ImageData buffs = 24;
inline bool FeatureLayers::_internal_has_buffs() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buffs_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_buffs() const {
  return _internal_has_buffs();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_buffs() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.buffs_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::buffs() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.buffs)
  return _internal_buffs();
}
inline void FeatureLayers::unsafe_arena_set_allocated_buffs(
    ::SC2APIProtocol::ImageData* buffs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buffs_);
  }
  _impl_.buffs_ = buffs;
  if (buffs) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.buffs)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_buffs() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.buffs_;
  _impl_.buffs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_buffs() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.buffs)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.buffs_;
  _impl_.buffs_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_buffs() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.buffs_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.buffs_ = p;
  }
  return _impl_.buffs_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_buffs() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_buffs();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.buffs)
  return _msg;
}
inline void FeatureLayers::set_allocated_buffs(::SC2APIProtocol::ImageData* buffs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buffs_);
  }
  if (buffs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(buffs));
    if (message_arena != submessage_arena) {
      buffs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.buffs_ = buffs;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.buffs)
}

// optional .SC2APIProtocol.ImageData buff_duration = 26;
inline bool FeatureLayers::_internal_has_buff_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buff_duration_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_buff_duration() const {
  return _internal_has_buff_duration();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_buff_duration() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.buff_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::buff_duration() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.buff_duration)
  return _internal_buff_duration();
}
inline void FeatureLayers::unsafe_arena_set_allocated_buff_duration(
    ::SC2APIProtocol::ImageData* buff_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buff_duration_);
  }
  _impl_.buff_duration_ = buff_duration;
  if (buff_duration) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.buff_duration)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_buff_duration() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.buff_duration_;
  _impl_.buff_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_buff_duration() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.buff_duration)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.buff_duration_;
  _impl_.buff_duration_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_buff_duration() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.buff_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.buff_duration_ = p;
  }
  return _impl_.buff_duration_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_buff_duration() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_buff_duration();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.buff_duration)
  return _msg;
}
inline void FeatureLayers::set_allocated_buff_duration(::SC2APIProtocol::ImageData* buff_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buff_duration_);
  }
  if (buff_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(buff_duration));
    if (message_arena != submessage_arena) {
      buff_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buff_duration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.buff_duration_ = buff_duration;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.buff_duration)
}

// optional .SC2APIProtocol.ImageData active = 25;
inline bool FeatureLayers::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_active() const {
  return _internal_has_active();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_active() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.active_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::active() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.active)
  return _internal_active();
}
inline void FeatureLayers::unsafe_arena_set_allocated_active(
    ::SC2APIProtocol::ImageData* active) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_);
  }
  _impl_.active_ = active;
  if (active) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.active)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_active() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.active_;
  _impl_.active_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_active() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.active)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.active_;
  _impl_.active_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_active() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.active_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.active_ = p;
  }
  return _impl_.active_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_active() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_active();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.active)
  return _msg;
}
inline void FeatureLayers::set_allocated_active(::SC2APIProtocol::ImageData* active) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.active_);
  }
  if (active) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active));
    if (message_arena != submessage_arena) {
      active = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.active_ = active;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.active)
}

// optional .SC2APIProtocol.ImageData build_progress = 27;
inline bool FeatureLayers::_internal_has_build_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.build_progress_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_build_progress() const {
  return _internal_has_build_progress();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_build_progress() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.build_progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::build_progress() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.build_progress)
  return _internal_build_progress();
}
inline void FeatureLayers::unsafe_arena_set_allocated_build_progress(
    ::SC2APIProtocol::ImageData* build_progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.build_progress_);
  }
  _impl_.build_progress_ = build_progress;
  if (build_progress) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.build_progress)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_build_progress() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.build_progress_;
  _impl_.build_progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_build_progress() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.build_progress)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.build_progress_;
  _impl_.build_progress_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_build_progress() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.build_progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.build_progress_ = p;
  }
  return _impl_.build_progress_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_build_progress() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_build_progress();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.build_progress)
  return _msg;
}
inline void FeatureLayers::set_allocated_build_progress(::SC2APIProtocol::ImageData* build_progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.build_progress_);
  }
  if (build_progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(build_progress));
    if (message_arena != submessage_arena) {
      build_progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, build_progress, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.build_progress_ = build_progress;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.build_progress)
}

// optional .SC2APIProtocol.ImageData buildable = 28;
inline bool FeatureLayers::_internal_has_buildable() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buildable_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_buildable() const {
  return _internal_has_buildable();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_buildable() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.buildable_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::buildable() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.buildable)
  return _internal_buildable();
}
inline void FeatureLayers::unsafe_arena_set_allocated_buildable(
    ::SC2APIProtocol::ImageData* buildable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buildable_);
  }
  _impl_.buildable_ = buildable;
  if (buildable) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.buildable)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_buildable() {
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.buildable_;
  _impl_.buildable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_buildable() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.buildable)
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.buildable_;
  _impl_.buildable_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_buildable() {
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.buildable_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.buildable_ = p;
  }
  return _impl_.buildable_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_buildable() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_buildable();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.buildable)
  return _msg;
}
inline void FeatureLayers::set_allocated_buildable(::SC2APIProtocol::ImageData* buildable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buildable_);
  }
  if (buildable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(buildable));
    if (message_arena != submessage_arena) {
      buildable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buildable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.buildable_ = buildable;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.buildable)
}

// optional .SC2APIProtocol.ImageData pathable = 29;
inline bool FeatureLayers::_internal_has_pathable() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathable_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_pathable() const {
  return _internal_has_pathable();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_pathable() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.pathable_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::pathable() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.pathable)
  return _internal_pathable();
}
inline void FeatureLayers::unsafe_arena_set_allocated_pathable(
    ::SC2APIProtocol::ImageData* pathable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathable_);
  }
  _impl_.pathable_ = pathable;
  if (pathable) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.pathable)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_pathable() {
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.pathable_;
  _impl_.pathable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_pathable() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.pathable)
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.pathable_;
  _impl_.pathable_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_pathable() {
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.pathable_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.pathable_ = p;
  }
  return _impl_.pathable_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_pathable() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_pathable();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.pathable)
  return _msg;
}
inline void FeatureLayers::set_allocated_pathable(::SC2APIProtocol::ImageData* pathable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathable_);
  }
  if (pathable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathable));
    if (message_arena != submessage_arena) {
      pathable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.pathable_ = pathable;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.pathable)
}

// optional .SC2APIProtocol.ImageData placeholder = 30;
inline bool FeatureLayers::_internal_has_placeholder() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.placeholder_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_placeholder() const {
  return _internal_has_placeholder();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_placeholder() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.placeholder_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::placeholder() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.placeholder)
  return _internal_placeholder();
}
inline void FeatureLayers::unsafe_arena_set_allocated_placeholder(
    ::SC2APIProtocol::ImageData* placeholder) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placeholder_);
  }
  _impl_.placeholder_ = placeholder;
  if (placeholder) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayers.placeholder)
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_placeholder() {
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.placeholder_;
  _impl_.placeholder_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::unsafe_arena_release_placeholder() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.placeholder)
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::SC2APIProtocol::ImageData* temp = _impl_.placeholder_;
  _impl_.placeholder_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_placeholder() {
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.placeholder_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.placeholder_ = p;
  }
  return _impl_.placeholder_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_placeholder() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_placeholder();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.placeholder)
  return _msg;
}
inline void FeatureLayers::set_allocated_placeholder(::SC2APIProtocol::ImageData* placeholder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placeholder_);
  }
  if (placeholder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placeholder));
    if (message_arena != submessage_arena) {
      placeholder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placeholder, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.placeholder_ = placeholder;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.placeholder)
}

// -------------------------------------------------------------------

// FeatureLayersMinimap

// optional .SC2APIProtocol.ImageData height_map = 1;
inline bool FeatureLayersMinimap::_internal_has_height_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.height_map_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_height_map() const {
  return _internal_has_height_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_height_map() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.height_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::height_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.height_map)
  return _internal_height_map();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_height_map(
    ::SC2APIProtocol::ImageData* height_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.height_map_);
  }
  _impl_.height_map_ = height_map;
  if (height_map) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.height_map)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_height_map() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = _impl_.height_map_;
  _impl_.height_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_height_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.height_map)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = _impl_.height_map_;
  _impl_.height_map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_height_map() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.height_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.height_map_ = p;
  }
  return _impl_.height_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_height_map() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_height_map();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.height_map)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_height_map(::SC2APIProtocol::ImageData* height_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.height_map_);
  }
  if (height_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(height_map));
    if (message_arena != submessage_arena) {
      height_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, height_map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.height_map_ = height_map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.height_map)
}

// optional .SC2APIProtocol.ImageData visibility_map = 2;
inline bool FeatureLayersMinimap::_internal_has_visibility_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.visibility_map_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_visibility_map() const {
  return _internal_has_visibility_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_visibility_map() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.visibility_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::visibility_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  return _internal_visibility_map();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_visibility_map(
    ::SC2APIProtocol::ImageData* visibility_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_map_);
  }
  _impl_.visibility_map_ = visibility_map;
  if (visibility_map) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_visibility_map() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.visibility_map_;
  _impl_.visibility_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_visibility_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.visibility_map_;
  _impl_.visibility_map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_visibility_map() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.visibility_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.visibility_map_ = p;
  }
  return _impl_.visibility_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_visibility_map() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_visibility_map();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_map_);
  }
  if (visibility_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visibility_map));
    if (message_arena != submessage_arena) {
      visibility_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility_map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.visibility_map_ = visibility_map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
}

// optional .SC2APIProtocol.ImageData creep = 3;
inline bool FeatureLayersMinimap::_internal_has_creep() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creep_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_creep() const {
  return _internal_has_creep();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_creep() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.creep_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::creep() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.creep)
  return _internal_creep();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_creep(
    ::SC2APIProtocol::ImageData* creep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creep_);
  }
  _impl_.creep_ = creep;
  if (creep) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.creep)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_creep() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ImageData* temp = _impl_.creep_;
  _impl_.creep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_creep() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.creep)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ImageData* temp = _impl_.creep_;
  _impl_.creep_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_creep() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.creep_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.creep_ = p;
  }
  return _impl_.creep_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_creep() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_creep();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.creep)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_creep(::SC2APIProtocol::ImageData* creep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creep_);
  }
  if (creep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creep));
    if (message_arena != submessage_arena) {
      creep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.creep)
}

// optional .SC2APIProtocol.ImageData camera = 4;
inline bool FeatureLayersMinimap::_internal_has_camera() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_camera() const {
  return _internal_has_camera();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_camera() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::camera() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.camera)
  return _internal_camera();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_camera(
    ::SC2APIProtocol::ImageData* camera) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_);
  }
  _impl_.camera_ = camera;
  if (camera) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.camera)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_camera() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ImageData* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.camera)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ImageData* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_camera() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.camera_ = p;
  }
  return _impl_.camera_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_camera() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.camera)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_camera(::SC2APIProtocol::ImageData* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_);
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera));
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.camera)
}

// optional .SC2APIProtocol.ImageData player_id = 5;
inline bool FeatureLayersMinimap::_internal_has_player_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_id_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_player_id() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.player_id)
  return _internal_player_id();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_player_id(
    ::SC2APIProtocol::ImageData* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_id_);
  }
  _impl_.player_id_ = player_id;
  if (player_id) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.player_id)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_player_id() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::ImageData* temp = _impl_.player_id_;
  _impl_.player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.player_id)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::ImageData* temp = _impl_.player_id_;
  _impl_.player_id_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_player_id() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.player_id_ = p;
  }
  return _impl_.player_id_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_player_id() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.player_id)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_player_id(::SC2APIProtocol::ImageData* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.player_id)
}

// optional .SC2APIProtocol.ImageData player_relative = 6;
inline bool FeatureLayersMinimap::_internal_has_player_relative() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_relative_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_player_relative() const {
  return _internal_has_player_relative();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_player_relative() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.player_relative_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::player_relative() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  return _internal_player_relative();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_player_relative(
    ::SC2APIProtocol::ImageData* player_relative) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_relative_);
  }
  _impl_.player_relative_ = player_relative;
  if (player_relative) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.player_relative)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_player_relative() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::SC2APIProtocol::ImageData* temp = _impl_.player_relative_;
  _impl_.player_relative_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_player_relative() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::SC2APIProtocol::ImageData* temp = _impl_.player_relative_;
  _impl_.player_relative_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_player_relative() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.player_relative_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.player_relative_ = p;
  }
  return _impl_.player_relative_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_player_relative() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_player_relative();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_relative_);
  }
  if (player_relative) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_relative));
    if (message_arena != submessage_arena) {
      player_relative = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_relative, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.player_relative_ = player_relative;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.player_relative)
}

// optional .SC2APIProtocol.ImageData selected = 7;
inline bool FeatureLayersMinimap::_internal_has_selected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selected_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_selected() const {
  return _internal_has_selected();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_selected() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.selected_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::selected() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.selected)
  return _internal_selected();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_selected(
    ::SC2APIProtocol::ImageData* selected) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selected_);
  }
  _impl_.selected_ = selected;
  if (selected) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.selected)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_selected() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::SC2APIProtocol::ImageData* temp = _impl_.selected_;
  _impl_.selected_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_selected() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.selected)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::SC2APIProtocol::ImageData* temp = _impl_.selected_;
  _impl_.selected_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_selected() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.selected_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.selected_ = p;
  }
  return _impl_.selected_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_selected() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_selected();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.selected)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_selected(::SC2APIProtocol::ImageData* selected) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selected_);
  }
  if (selected) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(selected));
    if (message_arena != submessage_arena) {
      selected = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selected, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.selected_ = selected;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.selected)
}

// optional .SC2APIProtocol.ImageData alerts = 9;
inline bool FeatureLayersMinimap::_internal_has_alerts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alerts_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_alerts() const {
  return _internal_has_alerts();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_alerts() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.alerts_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::alerts() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.alerts)
  return _internal_alerts();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_alerts(
    ::SC2APIProtocol::ImageData* alerts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alerts_);
  }
  _impl_.alerts_ = alerts;
  if (alerts) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.alerts)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_alerts() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::SC2APIProtocol::ImageData* temp = _impl_.alerts_;
  _impl_.alerts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_alerts() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.alerts)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::SC2APIProtocol::ImageData* temp = _impl_.alerts_;
  _impl_.alerts_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_alerts() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.alerts_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.alerts_ = p;
  }
  return _impl_.alerts_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_alerts() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_alerts();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.alerts)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_alerts(::SC2APIProtocol::ImageData* alerts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alerts_);
  }
  if (alerts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alerts));
    if (message_arena != submessage_arena) {
      alerts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alerts, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.alerts_ = alerts;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.alerts)
}

// optional .SC2APIProtocol.ImageData buildable = 10;
inline bool FeatureLayersMinimap::_internal_has_buildable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buildable_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_buildable() const {
  return _internal_has_buildable();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_buildable() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.buildable_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::buildable() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.buildable)
  return _internal_buildable();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_buildable(
    ::SC2APIProtocol::ImageData* buildable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buildable_);
  }
  _impl_.buildable_ = buildable;
  if (buildable) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.buildable)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_buildable() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::SC2APIProtocol::ImageData* temp = _impl_.buildable_;
  _impl_.buildable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_buildable() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.buildable)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::SC2APIProtocol::ImageData* temp = _impl_.buildable_;
  _impl_.buildable_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_buildable() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.buildable_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.buildable_ = p;
  }
  return _impl_.buildable_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_buildable() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_buildable();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.buildable)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_buildable(::SC2APIProtocol::ImageData* buildable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buildable_);
  }
  if (buildable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(buildable));
    if (message_arena != submessage_arena) {
      buildable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buildable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.buildable_ = buildable;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.buildable)
}

// optional .SC2APIProtocol.ImageData pathable = 11;
inline bool FeatureLayersMinimap::_internal_has_pathable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathable_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_pathable() const {
  return _internal_has_pathable();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_pathable() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.pathable_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::pathable() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.pathable)
  return _internal_pathable();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_pathable(
    ::SC2APIProtocol::ImageData* pathable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathable_);
  }
  _impl_.pathable_ = pathable;
  if (pathable) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.pathable)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_pathable() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::SC2APIProtocol::ImageData* temp = _impl_.pathable_;
  _impl_.pathable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_pathable() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.pathable)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::SC2APIProtocol::ImageData* temp = _impl_.pathable_;
  _impl_.pathable_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_pathable() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.pathable_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.pathable_ = p;
  }
  return _impl_.pathable_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_pathable() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_pathable();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.pathable)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_pathable(::SC2APIProtocol::ImageData* pathable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathable_);
  }
  if (pathable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathable));
    if (message_arena != submessage_arena) {
      pathable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.pathable_ = pathable;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.pathable)
}

// optional .SC2APIProtocol.ImageData unit_type = 8;
inline bool FeatureLayersMinimap::_internal_has_unit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unit_type_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_unit_type() const {
  return _internal_has_unit_type();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_unit_type() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.unit_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  return _internal_unit_type();
}
inline void FeatureLayersMinimap::unsafe_arena_set_allocated_unit_type(
    ::SC2APIProtocol::ImageData* unit_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_type_);
  }
  _impl_.unit_type_ = unit_type;
  if (unit_type) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.FeatureLayersMinimap.unit_type)
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_unit_type() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_type_;
  _impl_.unit_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::unsafe_arena_release_unit_type() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::SC2APIProtocol::ImageData* temp = _impl_.unit_type_;
  _impl_.unit_type_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_unit_type() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.unit_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.unit_type_ = p;
  }
  return _impl_.unit_type_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_unit_type() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_unit_type();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  return _msg;
}
inline void FeatureLayersMinimap::set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unit_type_);
  }
  if (unit_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_type));
    if (message_arena != submessage_arena) {
      unit_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.unit_type_ = unit_type;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.unit_type)
}

// -------------------------------------------------------------------

// ObservationRender

// optional .SC2APIProtocol.ImageData map = 1;
inline bool ObservationRender::_internal_has_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.map_ != nullptr);
  return value;
}
inline bool ObservationRender::has_map() const {
  return _internal_has_map();
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::_internal_map() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.map_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRender.map)
  return _internal_map();
}
inline void ObservationRender::unsafe_arena_set_allocated_map(
    ::SC2APIProtocol::ImageData* map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  _impl_.map_ = map;
  if (map) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ObservationRender.map)
}
inline ::SC2APIProtocol::ImageData* ObservationRender::release_map() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = _impl_.map_;
  _impl_.map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRender.map)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = _impl_.map_;
  _impl_.map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::_internal_mutable_map() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.map_ = p;
  }
  return _impl_.map_;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::mutable_map() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRender.map)
  return _msg;
}
inline void ObservationRender::set_allocated_map(::SC2APIProtocol::ImageData* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(map));
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_ = map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRender.map)
}

// optional .SC2APIProtocol.ImageData minimap = 2;
inline bool ObservationRender::_internal_has_minimap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimap_ != nullptr);
  return value;
}
inline bool ObservationRender::has_minimap() const {
  return _internal_has_minimap();
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::_internal_minimap() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.minimap_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::minimap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRender.minimap)
  return _internal_minimap();
}
inline void ObservationRender::unsafe_arena_set_allocated_minimap(
    ::SC2APIProtocol::ImageData* minimap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minimap_);
  }
  _impl_.minimap_ = minimap;
  if (minimap) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ObservationRender.minimap)
}
inline ::SC2APIProtocol::ImageData* ObservationRender::release_minimap() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.minimap_;
  _impl_.minimap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::unsafe_arena_release_minimap() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRender.minimap)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.minimap_;
  _impl_.minimap_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::_internal_mutable_minimap() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.minimap_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.minimap_ = p;
  }
  return _impl_.minimap_;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::mutable_minimap() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_minimap();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRender.minimap)
  return _msg;
}
inline void ObservationRender::set_allocated_minimap(::SC2APIProtocol::ImageData* minimap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minimap_);
  }
  if (minimap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimap));
    if (message_arena != submessage_arena) {
      minimap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimap, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.minimap_ = minimap;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRender.minimap)
}

// -------------------------------------------------------------------

// ActionSpatial

// .SC2APIProtocol.ActionSpatialUnitCommand unit_command = 1;
inline bool ActionSpatial::_internal_has_unit_command() const {
  return action_case() == kUnitCommand;
}
inline bool ActionSpatial::has_unit_command() const {
  return _internal_has_unit_command();
}
inline void ActionSpatial::set_has_unit_command() {
  _impl_._oneof_case_[0] = kUnitCommand;
}
inline void ActionSpatial::clear_unit_command() {
  if (_internal_has_unit_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.unit_command_;
    }
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::release_unit_command() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_command)
  if (_internal_has_unit_command()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitCommand* temp = _impl_.action_.unit_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.unit_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionSpatialUnitCommand& ActionSpatial::_internal_unit_command() const {
  return _internal_has_unit_command()
      ? *_impl_.action_.unit_command_
      : reinterpret_cast< ::SC2APIProtocol::ActionSpatialUnitCommand&>(::SC2APIProtocol::_ActionSpatialUnitCommand_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatialUnitCommand& ActionSpatial::unit_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_command)
  return _internal_unit_command();
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::unsafe_arena_release_unit_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionSpatial.unit_command)
  if (_internal_has_unit_command()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitCommand* temp = _impl_.action_.unit_command_;
    _impl_.action_.unit_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionSpatial::unsafe_arena_set_allocated_unit_command(::SC2APIProtocol::ActionSpatialUnitCommand* unit_command) {
  clear_action();
  if (unit_command) {
    set_has_unit_command();
    _impl_.action_.unit_command_ = unit_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionSpatial.unit_command)
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::_internal_mutable_unit_command() {
  if (!_internal_has_unit_command()) {
    clear_action();
    set_has_unit_command();
    _impl_.action_.unit_command_ = CreateMaybeMessage< ::SC2APIProtocol::ActionSpatialUnitCommand >(GetArenaForAllocation());
  }
  return _impl_.action_.unit_command_;
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::mutable_unit_command() {
  ::SC2APIProtocol::ActionSpatialUnitCommand* _msg = _internal_mutable_unit_command();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_command)
  return _msg;
}

// .SC2APIProtocol.ActionSpatialCameraMove camera_move = 2;
inline bool ActionSpatial::_internal_has_camera_move() const {
  return action_case() == kCameraMove;
}
inline bool ActionSpatial::has_camera_move() const {
  return _internal_has_camera_move();
}
inline void ActionSpatial::set_has_camera_move() {
  _impl_._oneof_case_[0] = kCameraMove;
}
inline void ActionSpatial::clear_camera_move() {
  if (_internal_has_camera_move()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.camera_move_;
    }
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::release_camera_move() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.camera_move)
  if (_internal_has_camera_move()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialCameraMove* temp = _impl_.action_.camera_move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.camera_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionSpatialCameraMove& ActionSpatial::_internal_camera_move() const {
  return _internal_has_camera_move()
      ? *_impl_.action_.camera_move_
      : reinterpret_cast< ::SC2APIProtocol::ActionSpatialCameraMove&>(::SC2APIProtocol::_ActionSpatialCameraMove_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatialCameraMove& ActionSpatial::camera_move() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.camera_move)
  return _internal_camera_move();
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::unsafe_arena_release_camera_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionSpatial.camera_move)
  if (_internal_has_camera_move()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialCameraMove* temp = _impl_.action_.camera_move_;
    _impl_.action_.camera_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionSpatial::unsafe_arena_set_allocated_camera_move(::SC2APIProtocol::ActionSpatialCameraMove* camera_move) {
  clear_action();
  if (camera_move) {
    set_has_camera_move();
    _impl_.action_.camera_move_ = camera_move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionSpatial.camera_move)
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::_internal_mutable_camera_move() {
  if (!_internal_has_camera_move()) {
    clear_action();
    set_has_camera_move();
    _impl_.action_.camera_move_ = CreateMaybeMessage< ::SC2APIProtocol::ActionSpatialCameraMove >(GetArenaForAllocation());
  }
  return _impl_.action_.camera_move_;
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::mutable_camera_move() {
  ::SC2APIProtocol::ActionSpatialCameraMove* _msg = _internal_mutable_camera_move();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.camera_move)
  return _msg;
}

// .SC2APIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;
inline bool ActionSpatial::_internal_has_unit_selection_point() const {
  return action_case() == kUnitSelectionPoint;
}
inline bool ActionSpatial::has_unit_selection_point() const {
  return _internal_has_unit_selection_point();
}
inline void ActionSpatial::set_has_unit_selection_point() {
  _impl_._oneof_case_[0] = kUnitSelectionPoint;
}
inline void ActionSpatial::clear_unit_selection_point() {
  if (_internal_has_unit_selection_point()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.unit_selection_point_;
    }
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::release_unit_selection_point() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_selection_point)
  if (_internal_has_unit_selection_point()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* temp = _impl_.action_.unit_selection_point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.unit_selection_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& ActionSpatial::_internal_unit_selection_point() const {
  return _internal_has_unit_selection_point()
      ? *_impl_.action_.unit_selection_point_
      : reinterpret_cast< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint&>(::SC2APIProtocol::_ActionSpatialUnitSelectionPoint_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& ActionSpatial::unit_selection_point() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_selection_point)
  return _internal_unit_selection_point();
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::unsafe_arena_release_unit_selection_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionSpatial.unit_selection_point)
  if (_internal_has_unit_selection_point()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* temp = _impl_.action_.unit_selection_point_;
    _impl_.action_.unit_selection_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionSpatial::unsafe_arena_set_allocated_unit_selection_point(::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point) {
  clear_action();
  if (unit_selection_point) {
    set_has_unit_selection_point();
    _impl_.action_.unit_selection_point_ = unit_selection_point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionSpatial.unit_selection_point)
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::_internal_mutable_unit_selection_point() {
  if (!_internal_has_unit_selection_point()) {
    clear_action();
    set_has_unit_selection_point();
    _impl_.action_.unit_selection_point_ = CreateMaybeMessage< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint >(GetArenaForAllocation());
  }
  return _impl_.action_.unit_selection_point_;
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::mutable_unit_selection_point() {
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* _msg = _internal_mutable_unit_selection_point();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_selection_point)
  return _msg;
}

// .SC2APIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;
inline bool ActionSpatial::_internal_has_unit_selection_rect() const {
  return action_case() == kUnitSelectionRect;
}
inline bool ActionSpatial::has_unit_selection_rect() const {
  return _internal_has_unit_selection_rect();
}
inline void ActionSpatial::set_has_unit_selection_rect() {
  _impl_._oneof_case_[0] = kUnitSelectionRect;
}
inline void ActionSpatial::clear_unit_selection_rect() {
  if (_internal_has_unit_selection_rect()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.unit_selection_rect_;
    }
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::release_unit_selection_rect() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  if (_internal_has_unit_selection_rect()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitSelectionRect* temp = _impl_.action_.unit_selection_rect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.unit_selection_rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& ActionSpatial::_internal_unit_selection_rect() const {
  return _internal_has_unit_selection_rect()
      ? *_impl_.action_.unit_selection_rect_
      : reinterpret_cast< ::SC2APIProtocol::ActionSpatialUnitSelectionRect&>(::SC2APIProtocol::_ActionSpatialUnitSelectionRect_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& ActionSpatial::unit_selection_rect() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  return _internal_unit_selection_rect();
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::unsafe_arena_release_unit_selection_rect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  if (_internal_has_unit_selection_rect()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitSelectionRect* temp = _impl_.action_.unit_selection_rect_;
    _impl_.action_.unit_selection_rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionSpatial::unsafe_arena_set_allocated_unit_selection_rect(::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect) {
  clear_action();
  if (unit_selection_rect) {
    set_has_unit_selection_rect();
    _impl_.action_.unit_selection_rect_ = unit_selection_rect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionSpatial.unit_selection_rect)
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::_internal_mutable_unit_selection_rect() {
  if (!_internal_has_unit_selection_rect()) {
    clear_action();
    set_has_unit_selection_rect();
    _impl_.action_.unit_selection_rect_ = CreateMaybeMessage< ::SC2APIProtocol::ActionSpatialUnitSelectionRect >(GetArenaForAllocation());
  }
  return _impl_.action_.unit_selection_rect_;
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::mutable_unit_selection_rect() {
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* _msg = _internal_mutable_unit_selection_rect();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  return _msg;
}

inline bool ActionSpatial::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionSpatial::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionSpatial::ActionCase ActionSpatial::action_case() const {
  return ActionSpatial::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpatialUnitCommand

// optional int32 ability_id = 1;
inline bool ActionSpatialUnitCommand::_internal_has_ability_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionSpatialUnitCommand::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void ActionSpatialUnitCommand::clear_ability_id() {
  _impl_.ability_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ActionSpatialUnitCommand::_internal_ability_id() const {
  return _impl_.ability_id_;
}
inline int32_t ActionSpatialUnitCommand::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.ability_id)
  return _internal_ability_id();
}
inline void ActionSpatialUnitCommand::_internal_set_ability_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ability_id_ = value;
}
inline void ActionSpatialUnitCommand::set_ability_id(int32_t value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitCommand.ability_id)
}

// .SC2APIProtocol.PointI target_screen_coord = 2;
inline bool ActionSpatialUnitCommand::_internal_has_target_screen_coord() const {
  return target_case() == kTargetScreenCoord;
}
inline bool ActionSpatialUnitCommand::has_target_screen_coord() const {
  return _internal_has_target_screen_coord();
}
inline void ActionSpatialUnitCommand::set_has_target_screen_coord() {
  _impl_._oneof_case_[0] = kTargetScreenCoord;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::release_target_screen_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  if (_internal_has_target_screen_coord()) {
    clear_has_target();
    ::SC2APIProtocol::PointI* temp = _impl_.target_.target_screen_coord_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_.target_screen_coord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::_internal_target_screen_coord() const {
  return _internal_has_target_screen_coord()
      ? *_impl_.target_.target_screen_coord_
      : reinterpret_cast< ::SC2APIProtocol::PointI&>(::SC2APIProtocol::_PointI_default_instance_);
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::target_screen_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  return _internal_target_screen_coord();
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::unsafe_arena_release_target_screen_coord() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  if (_internal_has_target_screen_coord()) {
    clear_has_target();
    ::SC2APIProtocol::PointI* temp = _impl_.target_.target_screen_coord_;
    _impl_.target_.target_screen_coord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionSpatialUnitCommand::unsafe_arena_set_allocated_target_screen_coord(::SC2APIProtocol::PointI* target_screen_coord) {
  clear_target();
  if (target_screen_coord) {
    set_has_target_screen_coord();
    _impl_.target_.target_screen_coord_ = target_screen_coord;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::_internal_mutable_target_screen_coord() {
  if (!_internal_has_target_screen_coord()) {
    clear_target();
    set_has_target_screen_coord();
    _impl_.target_.target_screen_coord_ = CreateMaybeMessage< ::SC2APIProtocol::PointI >(GetArenaForAllocation());
  }
  return _impl_.target_.target_screen_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::mutable_target_screen_coord() {
  ::SC2APIProtocol::PointI* _msg = _internal_mutable_target_screen_coord();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  return _msg;
}

// .SC2APIProtocol.PointI target_minimap_coord = 3;
inline bool ActionSpatialUnitCommand::_internal_has_target_minimap_coord() const {
  return target_case() == kTargetMinimapCoord;
}
inline bool ActionSpatialUnitCommand::has_target_minimap_coord() const {
  return _internal_has_target_minimap_coord();
}
inline void ActionSpatialUnitCommand::set_has_target_minimap_coord() {
  _impl_._oneof_case_[0] = kTargetMinimapCoord;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::release_target_minimap_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  if (_internal_has_target_minimap_coord()) {
    clear_has_target();
    ::SC2APIProtocol::PointI* temp = _impl_.target_.target_minimap_coord_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_.target_minimap_coord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::_internal_target_minimap_coord() const {
  return _internal_has_target_minimap_coord()
      ? *_impl_.target_.target_minimap_coord_
      : reinterpret_cast< ::SC2APIProtocol::PointI&>(::SC2APIProtocol::_PointI_default_instance_);
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::target_minimap_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  return _internal_target_minimap_coord();
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::unsafe_arena_release_target_minimap_coord() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  if (_internal_has_target_minimap_coord()) {
    clear_has_target();
    ::SC2APIProtocol::PointI* temp = _impl_.target_.target_minimap_coord_;
    _impl_.target_.target_minimap_coord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionSpatialUnitCommand::unsafe_arena_set_allocated_target_minimap_coord(::SC2APIProtocol::PointI* target_minimap_coord) {
  clear_target();
  if (target_minimap_coord) {
    set_has_target_minimap_coord();
    _impl_.target_.target_minimap_coord_ = target_minimap_coord;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::_internal_mutable_target_minimap_coord() {
  if (!_internal_has_target_minimap_coord()) {
    clear_target();
    set_has_target_minimap_coord();
    _impl_.target_.target_minimap_coord_ = CreateMaybeMessage< ::SC2APIProtocol::PointI >(GetArenaForAllocation());
  }
  return _impl_.target_.target_minimap_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::mutable_target_minimap_coord() {
  ::SC2APIProtocol::PointI* _msg = _internal_mutable_target_minimap_coord();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  return _msg;
}

// optional bool queue_command = 4;
inline bool ActionSpatialUnitCommand::_internal_has_queue_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionSpatialUnitCommand::has_queue_command() const {
  return _internal_has_queue_command();
}
inline void ActionSpatialUnitCommand::clear_queue_command() {
  _impl_.queue_command_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ActionSpatialUnitCommand::_internal_queue_command() const {
  return _impl_.queue_command_;
}
inline bool ActionSpatialUnitCommand::queue_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.queue_command)
  return _internal_queue_command();
}
inline void ActionSpatialUnitCommand::_internal_set_queue_command(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.queue_command_ = value;
}
inline void ActionSpatialUnitCommand::set_queue_command(bool value) {
  _internal_set_queue_command(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitCommand.queue_command)
}

inline bool ActionSpatialUnitCommand::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ActionSpatialUnitCommand::clear_has_target() {
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}
inline ActionSpatialUnitCommand::TargetCase ActionSpatialUnitCommand::target_case() const {
  return ActionSpatialUnitCommand::TargetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpatialCameraMove

// optional .SC2APIProtocol.PointI center_minimap = 1;
inline bool ActionSpatialCameraMove::_internal_has_center_minimap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_minimap_ != nullptr);
  return value;
}
inline bool ActionSpatialCameraMove::has_center_minimap() const {
  return _internal_has_center_minimap();
}
inline const ::SC2APIProtocol::PointI& ActionSpatialCameraMove::_internal_center_minimap() const {
  const ::SC2APIProtocol::PointI* p = _impl_.center_minimap_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::PointI&>(
      ::SC2APIProtocol::_PointI_default_instance_);
}
inline const ::SC2APIProtocol::PointI& ActionSpatialCameraMove::center_minimap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  return _internal_center_minimap();
}
inline void ActionSpatialCameraMove::unsafe_arena_set_allocated_center_minimap(
    ::SC2APIProtocol::PointI* center_minimap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_minimap_);
  }
  _impl_.center_minimap_ = center_minimap;
  if (center_minimap) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::release_center_minimap() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PointI* temp = _impl_.center_minimap_;
  _impl_.center_minimap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::unsafe_arena_release_center_minimap() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PointI* temp = _impl_.center_minimap_;
  _impl_.center_minimap_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::_internal_mutable_center_minimap() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_minimap_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PointI>(GetArenaForAllocation());
    _impl_.center_minimap_ = p;
  }
  return _impl_.center_minimap_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::mutable_center_minimap() {
  ::SC2APIProtocol::PointI* _msg = _internal_mutable_center_minimap();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  return _msg;
}
inline void ActionSpatialCameraMove::set_allocated_center_minimap(::SC2APIProtocol::PointI* center_minimap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_minimap_);
  }
  if (center_minimap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_minimap));
    if (message_arena != submessage_arena) {
      center_minimap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_minimap, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.center_minimap_ = center_minimap;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
}

// -------------------------------------------------------------------

// ActionSpatialUnitSelectionPoint

// optional .SC2APIProtocol.PointI selection_screen_coord = 1;
inline bool ActionSpatialUnitSelectionPoint::_internal_has_selection_screen_coord() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selection_screen_coord_ != nullptr);
  return value;
}
inline bool ActionSpatialUnitSelectionPoint::has_selection_screen_coord() const {
  return _internal_has_selection_screen_coord();
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitSelectionPoint::_internal_selection_screen_coord() const {
  const ::SC2APIProtocol::PointI* p = _impl_.selection_screen_coord_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::PointI&>(
      ::SC2APIProtocol::_PointI_default_instance_);
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitSelectionPoint::selection_screen_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  return _internal_selection_screen_coord();
}
inline void ActionSpatialUnitSelectionPoint::unsafe_arena_set_allocated_selection_screen_coord(
    ::SC2APIProtocol::PointI* selection_screen_coord) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selection_screen_coord_);
  }
  _impl_.selection_screen_coord_ = selection_screen_coord;
  if (selection_screen_coord) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::release_selection_screen_coord() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PointI* temp = _impl_.selection_screen_coord_;
  _impl_.selection_screen_coord_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::unsafe_arena_release_selection_screen_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PointI* temp = _impl_.selection_screen_coord_;
  _impl_.selection_screen_coord_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::_internal_mutable_selection_screen_coord() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.selection_screen_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PointI>(GetArenaForAllocation());
    _impl_.selection_screen_coord_ = p;
  }
  return _impl_.selection_screen_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::mutable_selection_screen_coord() {
  ::SC2APIProtocol::PointI* _msg = _internal_mutable_selection_screen_coord();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  return _msg;
}
inline void ActionSpatialUnitSelectionPoint::set_allocated_selection_screen_coord(::SC2APIProtocol::PointI* selection_screen_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selection_screen_coord_);
  }
  if (selection_screen_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(selection_screen_coord));
    if (message_arena != submessage_arena) {
      selection_screen_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selection_screen_coord, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.selection_screen_coord_ = selection_screen_coord;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
}

// optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;
inline bool ActionSpatialUnitSelectionPoint::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionSpatialUnitSelectionPoint::has_type() const {
  return _internal_has_type();
}
inline void ActionSpatialUnitSelectionPoint::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint::_internal_type() const {
  return static_cast< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type >(_impl_.type_);
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionPoint.type)
  return _internal_type();
}
inline void ActionSpatialUnitSelectionPoint::_internal_set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value) {
  assert(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void ActionSpatialUnitSelectionPoint::set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitSelectionPoint.type)
}

// -------------------------------------------------------------------

// ActionSpatialUnitSelectionRect

// repeated .SC2APIProtocol.RectangleI selection_screen_coord = 1;
inline int ActionSpatialUnitSelectionRect::_internal_selection_screen_coord_size() const {
  return _impl_.selection_screen_coord_.size();
}
inline int ActionSpatialUnitSelectionRect::selection_screen_coord_size() const {
  return _internal_selection_screen_coord_size();
}
inline ::SC2APIProtocol::RectangleI* ActionSpatialUnitSelectionRect::mutable_selection_screen_coord(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return _impl_.selection_screen_coord_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI >*
ActionSpatialUnitSelectionRect::mutable_selection_screen_coord() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return &_impl_.selection_screen_coord_;
}
inline const ::SC2APIProtocol::RectangleI& ActionSpatialUnitSelectionRect::_internal_selection_screen_coord(int index) const {
  return _impl_.selection_screen_coord_.Get(index);
}
inline const ::SC2APIProtocol::RectangleI& ActionSpatialUnitSelectionRect::selection_screen_coord(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return _internal_selection_screen_coord(index);
}
inline ::SC2APIProtocol::RectangleI* ActionSpatialUnitSelectionRect::_internal_add_selection_screen_coord() {
  return _impl_.selection_screen_coord_.Add();
}
inline ::SC2APIProtocol::RectangleI* ActionSpatialUnitSelectionRect::add_selection_screen_coord() {
  ::SC2APIProtocol::RectangleI* _add = _internal_add_selection_screen_coord();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI >&
ActionSpatialUnitSelectionRect::selection_screen_coord() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return _impl_.selection_screen_coord_;
}

// optional bool selection_add = 2;
inline bool ActionSpatialUnitSelectionRect::_internal_has_selection_add() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionSpatialUnitSelectionRect::has_selection_add() const {
  return _internal_has_selection_add();
}
inline void ActionSpatialUnitSelectionRect::clear_selection_add() {
  _impl_.selection_add_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ActionSpatialUnitSelectionRect::_internal_selection_add() const {
  return _impl_.selection_add_;
}
inline bool ActionSpatialUnitSelectionRect::selection_add() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_add)
  return _internal_selection_add();
}
inline void ActionSpatialUnitSelectionRect::_internal_set_selection_add(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.selection_add_ = value;
}
inline void ActionSpatialUnitSelectionRect::set_selection_add(bool value) {
  _internal_set_selection_add(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_add)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type>() {
  return ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fspatial_2eproto
