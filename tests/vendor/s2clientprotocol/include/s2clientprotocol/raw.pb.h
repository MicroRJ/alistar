// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/raw.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fraw_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fraw_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_s2clientprotocol_2fraw_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fraw_2eproto;
namespace SC2APIProtocol {
class ActionRaw;
struct ActionRawDefaultTypeInternal;
extern ActionRawDefaultTypeInternal _ActionRaw_default_instance_;
class ActionRawCameraMove;
struct ActionRawCameraMoveDefaultTypeInternal;
extern ActionRawCameraMoveDefaultTypeInternal _ActionRawCameraMove_default_instance_;
class ActionRawToggleAutocast;
struct ActionRawToggleAutocastDefaultTypeInternal;
extern ActionRawToggleAutocastDefaultTypeInternal _ActionRawToggleAutocast_default_instance_;
class ActionRawUnitCommand;
struct ActionRawUnitCommandDefaultTypeInternal;
extern ActionRawUnitCommandDefaultTypeInternal _ActionRawUnitCommand_default_instance_;
class Effect;
struct EffectDefaultTypeInternal;
extern EffectDefaultTypeInternal _Effect_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class MapState;
struct MapStateDefaultTypeInternal;
extern MapStateDefaultTypeInternal _MapState_default_instance_;
class ObservationRaw;
struct ObservationRawDefaultTypeInternal;
extern ObservationRawDefaultTypeInternal _ObservationRaw_default_instance_;
class PassengerUnit;
struct PassengerUnitDefaultTypeInternal;
extern PassengerUnitDefaultTypeInternal _PassengerUnit_default_instance_;
class PlayerRaw;
struct PlayerRawDefaultTypeInternal;
extern PlayerRawDefaultTypeInternal _PlayerRaw_default_instance_;
class PowerSource;
struct PowerSourceDefaultTypeInternal;
extern PowerSourceDefaultTypeInternal _PowerSource_default_instance_;
class RadarRing;
struct RadarRingDefaultTypeInternal;
extern RadarRingDefaultTypeInternal _RadarRing_default_instance_;
class RallyTarget;
struct RallyTargetDefaultTypeInternal;
extern RallyTargetDefaultTypeInternal _RallyTarget_default_instance_;
class StartRaw;
struct StartRawDefaultTypeInternal;
extern StartRawDefaultTypeInternal _StartRaw_default_instance_;
class Unit;
struct UnitDefaultTypeInternal;
extern UnitDefaultTypeInternal _Unit_default_instance_;
class UnitOrder;
struct UnitOrderDefaultTypeInternal;
extern UnitOrderDefaultTypeInternal _UnitOrder_default_instance_;
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> ::SC2APIProtocol::ActionRaw* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionRaw>(Arena*);
template<> ::SC2APIProtocol::ActionRawCameraMove* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionRawCameraMove>(Arena*);
template<> ::SC2APIProtocol::ActionRawToggleAutocast* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionRawToggleAutocast>(Arena*);
template<> ::SC2APIProtocol::ActionRawUnitCommand* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionRawUnitCommand>(Arena*);
template<> ::SC2APIProtocol::Effect* Arena::CreateMaybeMessage<::SC2APIProtocol::Effect>(Arena*);
template<> ::SC2APIProtocol::Event* Arena::CreateMaybeMessage<::SC2APIProtocol::Event>(Arena*);
template<> ::SC2APIProtocol::MapState* Arena::CreateMaybeMessage<::SC2APIProtocol::MapState>(Arena*);
template<> ::SC2APIProtocol::ObservationRaw* Arena::CreateMaybeMessage<::SC2APIProtocol::ObservationRaw>(Arena*);
template<> ::SC2APIProtocol::PassengerUnit* Arena::CreateMaybeMessage<::SC2APIProtocol::PassengerUnit>(Arena*);
template<> ::SC2APIProtocol::PlayerRaw* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerRaw>(Arena*);
template<> ::SC2APIProtocol::PowerSource* Arena::CreateMaybeMessage<::SC2APIProtocol::PowerSource>(Arena*);
template<> ::SC2APIProtocol::RadarRing* Arena::CreateMaybeMessage<::SC2APIProtocol::RadarRing>(Arena*);
template<> ::SC2APIProtocol::RallyTarget* Arena::CreateMaybeMessage<::SC2APIProtocol::RallyTarget>(Arena*);
template<> ::SC2APIProtocol::StartRaw* Arena::CreateMaybeMessage<::SC2APIProtocol::StartRaw>(Arena*);
template<> ::SC2APIProtocol::Unit* Arena::CreateMaybeMessage<::SC2APIProtocol::Unit>(Arena*);
template<> ::SC2APIProtocol::UnitOrder* Arena::CreateMaybeMessage<::SC2APIProtocol::UnitOrder>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SC2APIProtocol {

enum DisplayType : int {
  Visible = 1,
  Snapshot = 2,
  Hidden = 3,
  Placeholder = 4
};
bool DisplayType_IsValid(int value);
constexpr DisplayType DisplayType_MIN = Visible;
constexpr DisplayType DisplayType_MAX = Placeholder;
constexpr int DisplayType_ARRAYSIZE = DisplayType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DisplayType_descriptor();
template<typename T>
inline const std::string& DisplayType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DisplayType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DisplayType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DisplayType_descriptor(), enum_t_value);
}
inline bool DisplayType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DisplayType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DisplayType>(
    DisplayType_descriptor(), name, value);
}
enum Alliance : int {
  Self = 1,
  Ally = 2,
  Neutral = 3,
  Enemy = 4
};
bool Alliance_IsValid(int value);
constexpr Alliance Alliance_MIN = Self;
constexpr Alliance Alliance_MAX = Enemy;
constexpr int Alliance_ARRAYSIZE = Alliance_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alliance_descriptor();
template<typename T>
inline const std::string& Alliance_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alliance>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alliance_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alliance_descriptor(), enum_t_value);
}
inline bool Alliance_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Alliance* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alliance>(
    Alliance_descriptor(), name, value);
}
enum CloakState : int {
  CloakedUnknown = 0,
  Cloaked = 1,
  CloakedDetected = 2,
  NotCloaked = 3,
  CloakedAllied = 4
};
bool CloakState_IsValid(int value);
constexpr CloakState CloakState_MIN = CloakedUnknown;
constexpr CloakState CloakState_MAX = CloakedAllied;
constexpr int CloakState_ARRAYSIZE = CloakState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CloakState_descriptor();
template<typename T>
inline const std::string& CloakState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CloakState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CloakState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CloakState_descriptor(), enum_t_value);
}
inline bool CloakState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CloakState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CloakState>(
    CloakState_descriptor(), name, value);
}
// ===================================================================

class StartRaw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.StartRaw) */ {
 public:
  inline StartRaw() : StartRaw(nullptr) {}
  ~StartRaw() override;
  explicit PROTOBUF_CONSTEXPR StartRaw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartRaw(const StartRaw& from);
  StartRaw(StartRaw&& from) noexcept
    : StartRaw() {
    *this = ::std::move(from);
  }

  inline StartRaw& operator=(const StartRaw& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartRaw& operator=(StartRaw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartRaw& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartRaw* internal_default_instance() {
    return reinterpret_cast<const StartRaw*>(
               &_StartRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StartRaw& a, StartRaw& b) {
    a.Swap(&b);
  }
  inline void Swap(StartRaw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartRaw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartRaw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartRaw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartRaw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartRaw& from) {
    StartRaw::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartRaw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.StartRaw";
  }
  protected:
  explicit StartRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartLocationsFieldNumber = 6,
    kMapSizeFieldNumber = 1,
    kPathingGridFieldNumber = 2,
    kTerrainHeightFieldNumber = 3,
    kPlacementGridFieldNumber = 4,
    kPlayableAreaFieldNumber = 5,
  };
  // repeated .SC2APIProtocol.Point2D start_locations = 6;
  int start_locations_size() const;
  private:
  int _internal_start_locations_size() const;
  public:
  void clear_start_locations();
  ::SC2APIProtocol::Point2D* mutable_start_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D >*
      mutable_start_locations();
  private:
  const ::SC2APIProtocol::Point2D& _internal_start_locations(int index) const;
  ::SC2APIProtocol::Point2D* _internal_add_start_locations();
  public:
  const ::SC2APIProtocol::Point2D& start_locations(int index) const;
  ::SC2APIProtocol::Point2D* add_start_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D >&
      start_locations() const;

  // optional .SC2APIProtocol.Size2DI map_size = 1;
  bool has_map_size() const;
  private:
  bool _internal_has_map_size() const;
  public:
  void clear_map_size();
  const ::SC2APIProtocol::Size2DI& map_size() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Size2DI* release_map_size();
  ::SC2APIProtocol::Size2DI* mutable_map_size();
  void set_allocated_map_size(::SC2APIProtocol::Size2DI* map_size);
  private:
  const ::SC2APIProtocol::Size2DI& _internal_map_size() const;
  ::SC2APIProtocol::Size2DI* _internal_mutable_map_size();
  public:
  void unsafe_arena_set_allocated_map_size(
      ::SC2APIProtocol::Size2DI* map_size);
  ::SC2APIProtocol::Size2DI* unsafe_arena_release_map_size();

  // optional .SC2APIProtocol.ImageData pathing_grid = 2;
  bool has_pathing_grid() const;
  private:
  bool _internal_has_pathing_grid() const;
  public:
  void clear_pathing_grid();
  const ::SC2APIProtocol::ImageData& pathing_grid() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_pathing_grid();
  ::SC2APIProtocol::ImageData* mutable_pathing_grid();
  void set_allocated_pathing_grid(::SC2APIProtocol::ImageData* pathing_grid);
  private:
  const ::SC2APIProtocol::ImageData& _internal_pathing_grid() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_pathing_grid();
  public:
  void unsafe_arena_set_allocated_pathing_grid(
      ::SC2APIProtocol::ImageData* pathing_grid);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_pathing_grid();

  // optional .SC2APIProtocol.ImageData terrain_height = 3;
  bool has_terrain_height() const;
  private:
  bool _internal_has_terrain_height() const;
  public:
  void clear_terrain_height();
  const ::SC2APIProtocol::ImageData& terrain_height() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_terrain_height();
  ::SC2APIProtocol::ImageData* mutable_terrain_height();
  void set_allocated_terrain_height(::SC2APIProtocol::ImageData* terrain_height);
  private:
  const ::SC2APIProtocol::ImageData& _internal_terrain_height() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_terrain_height();
  public:
  void unsafe_arena_set_allocated_terrain_height(
      ::SC2APIProtocol::ImageData* terrain_height);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_terrain_height();

  // optional .SC2APIProtocol.ImageData placement_grid = 4;
  bool has_placement_grid() const;
  private:
  bool _internal_has_placement_grid() const;
  public:
  void clear_placement_grid();
  const ::SC2APIProtocol::ImageData& placement_grid() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_placement_grid();
  ::SC2APIProtocol::ImageData* mutable_placement_grid();
  void set_allocated_placement_grid(::SC2APIProtocol::ImageData* placement_grid);
  private:
  const ::SC2APIProtocol::ImageData& _internal_placement_grid() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_placement_grid();
  public:
  void unsafe_arena_set_allocated_placement_grid(
      ::SC2APIProtocol::ImageData* placement_grid);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_placement_grid();

  // optional .SC2APIProtocol.RectangleI playable_area = 5;
  bool has_playable_area() const;
  private:
  bool _internal_has_playable_area() const;
  public:
  void clear_playable_area();
  const ::SC2APIProtocol::RectangleI& playable_area() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::RectangleI* release_playable_area();
  ::SC2APIProtocol::RectangleI* mutable_playable_area();
  void set_allocated_playable_area(::SC2APIProtocol::RectangleI* playable_area);
  private:
  const ::SC2APIProtocol::RectangleI& _internal_playable_area() const;
  ::SC2APIProtocol::RectangleI* _internal_mutable_playable_area();
  public:
  void unsafe_arena_set_allocated_playable_area(
      ::SC2APIProtocol::RectangleI* playable_area);
  ::SC2APIProtocol::RectangleI* unsafe_arena_release_playable_area();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.StartRaw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D > start_locations_;
    ::SC2APIProtocol::Size2DI* map_size_;
    ::SC2APIProtocol::ImageData* pathing_grid_;
    ::SC2APIProtocol::ImageData* terrain_height_;
    ::SC2APIProtocol::ImageData* placement_grid_;
    ::SC2APIProtocol::RectangleI* playable_area_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class ObservationRaw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObservationRaw) */ {
 public:
  inline ObservationRaw() : ObservationRaw(nullptr) {}
  ~ObservationRaw() override;
  explicit PROTOBUF_CONSTEXPR ObservationRaw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObservationRaw(const ObservationRaw& from);
  ObservationRaw(ObservationRaw&& from) noexcept
    : ObservationRaw() {
    *this = ::std::move(from);
  }

  inline ObservationRaw& operator=(const ObservationRaw& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObservationRaw& operator=(ObservationRaw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObservationRaw& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObservationRaw* internal_default_instance() {
    return reinterpret_cast<const ObservationRaw*>(
               &_ObservationRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ObservationRaw& a, ObservationRaw& b) {
    a.Swap(&b);
  }
  inline void Swap(ObservationRaw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObservationRaw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObservationRaw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObservationRaw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObservationRaw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObservationRaw& from) {
    ObservationRaw::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationRaw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ObservationRaw";
  }
  protected:
  explicit ObservationRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitsFieldNumber = 2,
    kEffectsFieldNumber = 5,
    kRadarFieldNumber = 6,
    kPlayerFieldNumber = 1,
    kMapStateFieldNumber = 3,
    kEventFieldNumber = 4,
  };
  // repeated .SC2APIProtocol.Unit units = 2;
  int units_size() const;
  private:
  int _internal_units_size() const;
  public:
  void clear_units();
  ::SC2APIProtocol::Unit* mutable_units(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Unit >*
      mutable_units();
  private:
  const ::SC2APIProtocol::Unit& _internal_units(int index) const;
  ::SC2APIProtocol::Unit* _internal_add_units();
  public:
  const ::SC2APIProtocol::Unit& units(int index) const;
  ::SC2APIProtocol::Unit* add_units();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Unit >&
      units() const;

  // repeated .SC2APIProtocol.Effect effects = 5;
  int effects_size() const;
  private:
  int _internal_effects_size() const;
  public:
  void clear_effects();
  ::SC2APIProtocol::Effect* mutable_effects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Effect >*
      mutable_effects();
  private:
  const ::SC2APIProtocol::Effect& _internal_effects(int index) const;
  ::SC2APIProtocol::Effect* _internal_add_effects();
  public:
  const ::SC2APIProtocol::Effect& effects(int index) const;
  ::SC2APIProtocol::Effect* add_effects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Effect >&
      effects() const;

  // repeated .SC2APIProtocol.RadarRing radar = 6;
  int radar_size() const;
  private:
  int _internal_radar_size() const;
  public:
  void clear_radar();
  ::SC2APIProtocol::RadarRing* mutable_radar(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RadarRing >*
      mutable_radar();
  private:
  const ::SC2APIProtocol::RadarRing& _internal_radar(int index) const;
  ::SC2APIProtocol::RadarRing* _internal_add_radar();
  public:
  const ::SC2APIProtocol::RadarRing& radar(int index) const;
  ::SC2APIProtocol::RadarRing* add_radar();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RadarRing >&
      radar() const;

  // optional .SC2APIProtocol.PlayerRaw player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::SC2APIProtocol::PlayerRaw& player() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::PlayerRaw* release_player();
  ::SC2APIProtocol::PlayerRaw* mutable_player();
  void set_allocated_player(::SC2APIProtocol::PlayerRaw* player);
  private:
  const ::SC2APIProtocol::PlayerRaw& _internal_player() const;
  ::SC2APIProtocol::PlayerRaw* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::SC2APIProtocol::PlayerRaw* player);
  ::SC2APIProtocol::PlayerRaw* unsafe_arena_release_player();

  // optional .SC2APIProtocol.MapState map_state = 3;
  bool has_map_state() const;
  private:
  bool _internal_has_map_state() const;
  public:
  void clear_map_state();
  const ::SC2APIProtocol::MapState& map_state() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::MapState* release_map_state();
  ::SC2APIProtocol::MapState* mutable_map_state();
  void set_allocated_map_state(::SC2APIProtocol::MapState* map_state);
  private:
  const ::SC2APIProtocol::MapState& _internal_map_state() const;
  ::SC2APIProtocol::MapState* _internal_mutable_map_state();
  public:
  void unsafe_arena_set_allocated_map_state(
      ::SC2APIProtocol::MapState* map_state);
  ::SC2APIProtocol::MapState* unsafe_arena_release_map_state();

  // optional .SC2APIProtocol.Event event = 4;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::SC2APIProtocol::Event& event() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Event* release_event();
  ::SC2APIProtocol::Event* mutable_event();
  void set_allocated_event(::SC2APIProtocol::Event* event);
  private:
  const ::SC2APIProtocol::Event& _internal_event() const;
  ::SC2APIProtocol::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::SC2APIProtocol::Event* event);
  ::SC2APIProtocol::Event* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObservationRaw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Unit > units_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Effect > effects_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RadarRing > radar_;
    ::SC2APIProtocol::PlayerRaw* player_;
    ::SC2APIProtocol::MapState* map_state_;
    ::SC2APIProtocol::Event* event_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class RadarRing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RadarRing) */ {
 public:
  inline RadarRing() : RadarRing(nullptr) {}
  ~RadarRing() override;
  explicit PROTOBUF_CONSTEXPR RadarRing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadarRing(const RadarRing& from);
  RadarRing(RadarRing&& from) noexcept
    : RadarRing() {
    *this = ::std::move(from);
  }

  inline RadarRing& operator=(const RadarRing& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarRing& operator=(RadarRing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarRing& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarRing* internal_default_instance() {
    return reinterpret_cast<const RadarRing*>(
               &_RadarRing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RadarRing& a, RadarRing& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarRing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarRing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadarRing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadarRing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadarRing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadarRing& from) {
    RadarRing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarRing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RadarRing";
  }
  protected:
  explicit RadarRing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // optional .SC2APIProtocol.Point pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::SC2APIProtocol::Point& pos() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_pos();
  ::SC2APIProtocol::Point* mutable_pos();
  void set_allocated_pos(::SC2APIProtocol::Point* pos);
  private:
  const ::SC2APIProtocol::Point& _internal_pos() const;
  ::SC2APIProtocol::Point* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::SC2APIProtocol::Point* pos);
  ::SC2APIProtocol::Point* unsafe_arena_release_pos();

  // optional float radius = 2;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RadarRing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Point* pos_;
    float radius_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class PowerSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PowerSource) */ {
 public:
  inline PowerSource() : PowerSource(nullptr) {}
  ~PowerSource() override;
  explicit PROTOBUF_CONSTEXPR PowerSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PowerSource(const PowerSource& from);
  PowerSource(PowerSource&& from) noexcept
    : PowerSource() {
    *this = ::std::move(from);
  }

  inline PowerSource& operator=(const PowerSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerSource& operator=(PowerSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PowerSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const PowerSource* internal_default_instance() {
    return reinterpret_cast<const PowerSource*>(
               &_PowerSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PowerSource& a, PowerSource& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PowerSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PowerSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PowerSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PowerSource& from) {
    PowerSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PowerSource";
  }
  protected:
  explicit PowerSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kTagFieldNumber = 3,
    kRadiusFieldNumber = 2,
  };
  // optional .SC2APIProtocol.Point pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::SC2APIProtocol::Point& pos() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_pos();
  ::SC2APIProtocol::Point* mutable_pos();
  void set_allocated_pos(::SC2APIProtocol::Point* pos);
  private:
  const ::SC2APIProtocol::Point& _internal_pos() const;
  ::SC2APIProtocol::Point* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::SC2APIProtocol::Point* pos);
  ::SC2APIProtocol::Point* unsafe_arena_release_pos();

  // optional uint64 tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  uint64_t tag() const;
  void set_tag(uint64_t value);
  private:
  uint64_t _internal_tag() const;
  void _internal_set_tag(uint64_t value);
  public:

  // optional float radius = 2;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PowerSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Point* pos_;
    uint64_t tag_;
    float radius_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class PlayerRaw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerRaw) */ {
 public:
  inline PlayerRaw() : PlayerRaw(nullptr) {}
  ~PlayerRaw() override;
  explicit PROTOBUF_CONSTEXPR PlayerRaw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerRaw(const PlayerRaw& from);
  PlayerRaw(PlayerRaw&& from) noexcept
    : PlayerRaw() {
    *this = ::std::move(from);
  }

  inline PlayerRaw& operator=(const PlayerRaw& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRaw& operator=(PlayerRaw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerRaw& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerRaw* internal_default_instance() {
    return reinterpret_cast<const PlayerRaw*>(
               &_PlayerRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerRaw& a, PlayerRaw& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRaw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRaw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerRaw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerRaw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerRaw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerRaw& from) {
    PlayerRaw::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerRaw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PlayerRaw";
  }
  protected:
  explicit PlayerRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerSourcesFieldNumber = 1,
    kUpgradeIdsFieldNumber = 3,
    kCameraFieldNumber = 2,
  };
  // repeated .SC2APIProtocol.PowerSource power_sources = 1;
  int power_sources_size() const;
  private:
  int _internal_power_sources_size() const;
  public:
  void clear_power_sources();
  ::SC2APIProtocol::PowerSource* mutable_power_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PowerSource >*
      mutable_power_sources();
  private:
  const ::SC2APIProtocol::PowerSource& _internal_power_sources(int index) const;
  ::SC2APIProtocol::PowerSource* _internal_add_power_sources();
  public:
  const ::SC2APIProtocol::PowerSource& power_sources(int index) const;
  ::SC2APIProtocol::PowerSource* add_power_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PowerSource >&
      power_sources() const;

  // repeated uint32 upgrade_ids = 3;
  int upgrade_ids_size() const;
  private:
  int _internal_upgrade_ids_size() const;
  public:
  void clear_upgrade_ids();
  private:
  uint32_t _internal_upgrade_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_upgrade_ids() const;
  void _internal_add_upgrade_ids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_upgrade_ids();
  public:
  uint32_t upgrade_ids(int index) const;
  void set_upgrade_ids(int index, uint32_t value);
  void add_upgrade_ids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      upgrade_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_upgrade_ids();

  // optional .SC2APIProtocol.Point camera = 2;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::SC2APIProtocol::Point& camera() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_camera();
  ::SC2APIProtocol::Point* mutable_camera();
  void set_allocated_camera(::SC2APIProtocol::Point* camera);
  private:
  const ::SC2APIProtocol::Point& _internal_camera() const;
  ::SC2APIProtocol::Point* _internal_mutable_camera();
  public:
  void unsafe_arena_set_allocated_camera(
      ::SC2APIProtocol::Point* camera);
  ::SC2APIProtocol::Point* unsafe_arena_release_camera();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerRaw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PowerSource > power_sources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > upgrade_ids_;
    ::SC2APIProtocol::Point* camera_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class UnitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.UnitOrder) */ {
 public:
  inline UnitOrder() : UnitOrder(nullptr) {}
  ~UnitOrder() override;
  explicit PROTOBUF_CONSTEXPR UnitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnitOrder(const UnitOrder& from);
  UnitOrder(UnitOrder&& from) noexcept
    : UnitOrder() {
    *this = ::std::move(from);
  }

  inline UnitOrder& operator=(const UnitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitOrder& operator=(UnitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnitOrder& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kTargetWorldSpacePos = 2,
    kTargetUnitTag = 3,
    TARGET_NOT_SET = 0,
  };

  static inline const UnitOrder* internal_default_instance() {
    return reinterpret_cast<const UnitOrder*>(
               &_UnitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UnitOrder& a, UnitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnitOrder& from) {
    UnitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.UnitOrder";
  }
  protected:
  explicit UnitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilityIdFieldNumber = 1,
    kProgressFieldNumber = 4,
    kTargetWorldSpacePosFieldNumber = 2,
    kTargetUnitTagFieldNumber = 3,
  };
  // optional uint32 ability_id = 1;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  uint32_t ability_id() const;
  void set_ability_id(uint32_t value);
  private:
  uint32_t _internal_ability_id() const;
  void _internal_set_ability_id(uint32_t value);
  public:

  // optional float progress = 4;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // .SC2APIProtocol.Point target_world_space_pos = 2;
  bool has_target_world_space_pos() const;
  private:
  bool _internal_has_target_world_space_pos() const;
  public:
  void clear_target_world_space_pos();
  const ::SC2APIProtocol::Point& target_world_space_pos() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_target_world_space_pos();
  ::SC2APIProtocol::Point* mutable_target_world_space_pos();
  void set_allocated_target_world_space_pos(::SC2APIProtocol::Point* target_world_space_pos);
  private:
  const ::SC2APIProtocol::Point& _internal_target_world_space_pos() const;
  ::SC2APIProtocol::Point* _internal_mutable_target_world_space_pos();
  public:
  void unsafe_arena_set_allocated_target_world_space_pos(
      ::SC2APIProtocol::Point* target_world_space_pos);
  ::SC2APIProtocol::Point* unsafe_arena_release_target_world_space_pos();

  // uint64 target_unit_tag = 3;
  bool has_target_unit_tag() const;
  private:
  bool _internal_has_target_unit_tag() const;
  public:
  void clear_target_unit_tag();
  uint64_t target_unit_tag() const;
  void set_target_unit_tag(uint64_t value);
  private:
  uint64_t _internal_target_unit_tag() const;
  void _internal_set_target_unit_tag(uint64_t value);
  public:

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.UnitOrder)
 private:
  class _Internal;
  void set_has_target_world_space_pos();
  void set_has_target_unit_tag();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t ability_id_;
    float progress_;
    union TargetUnion {
      constexpr TargetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SC2APIProtocol::Point* target_world_space_pos_;
      uint64_t target_unit_tag_;
    } target_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class PassengerUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PassengerUnit) */ {
 public:
  inline PassengerUnit() : PassengerUnit(nullptr) {}
  ~PassengerUnit() override;
  explicit PROTOBUF_CONSTEXPR PassengerUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PassengerUnit(const PassengerUnit& from);
  PassengerUnit(PassengerUnit&& from) noexcept
    : PassengerUnit() {
    *this = ::std::move(from);
  }

  inline PassengerUnit& operator=(const PassengerUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline PassengerUnit& operator=(PassengerUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PassengerUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const PassengerUnit* internal_default_instance() {
    return reinterpret_cast<const PassengerUnit*>(
               &_PassengerUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PassengerUnit& a, PassengerUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(PassengerUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PassengerUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PassengerUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PassengerUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PassengerUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PassengerUnit& from) {
    PassengerUnit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PassengerUnit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PassengerUnit";
  }
  protected:
  explicit PassengerUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kHealthFieldNumber = 2,
    kHealthMaxFieldNumber = 3,
    kShieldFieldNumber = 4,
    kEnergyFieldNumber = 5,
    kUnitTypeFieldNumber = 6,
    kShieldMaxFieldNumber = 7,
    kEnergyMaxFieldNumber = 8,
  };
  // optional uint64 tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  uint64_t tag() const;
  void set_tag(uint64_t value);
  private:
  uint64_t _internal_tag() const;
  void _internal_set_tag(uint64_t value);
  public:

  // optional float health = 2;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  float health() const;
  void set_health(float value);
  private:
  float _internal_health() const;
  void _internal_set_health(float value);
  public:

  // optional float health_max = 3;
  bool has_health_max() const;
  private:
  bool _internal_has_health_max() const;
  public:
  void clear_health_max();
  float health_max() const;
  void set_health_max(float value);
  private:
  float _internal_health_max() const;
  void _internal_set_health_max(float value);
  public:

  // optional float shield = 4;
  bool has_shield() const;
  private:
  bool _internal_has_shield() const;
  public:
  void clear_shield();
  float shield() const;
  void set_shield(float value);
  private:
  float _internal_shield() const;
  void _internal_set_shield(float value);
  public:

  // optional float energy = 5;
  bool has_energy() const;
  private:
  bool _internal_has_energy() const;
  public:
  void clear_energy();
  float energy() const;
  void set_energy(float value);
  private:
  float _internal_energy() const;
  void _internal_set_energy(float value);
  public:

  // optional uint32 unit_type = 6;
  bool has_unit_type() const;
  private:
  bool _internal_has_unit_type() const;
  public:
  void clear_unit_type();
  uint32_t unit_type() const;
  void set_unit_type(uint32_t value);
  private:
  uint32_t _internal_unit_type() const;
  void _internal_set_unit_type(uint32_t value);
  public:

  // optional float shield_max = 7;
  bool has_shield_max() const;
  private:
  bool _internal_has_shield_max() const;
  public:
  void clear_shield_max();
  float shield_max() const;
  void set_shield_max(float value);
  private:
  float _internal_shield_max() const;
  void _internal_set_shield_max(float value);
  public:

  // optional float energy_max = 8;
  bool has_energy_max() const;
  private:
  bool _internal_has_energy_max() const;
  public:
  void clear_energy_max();
  float energy_max() const;
  void set_energy_max(float value);
  private:
  float _internal_energy_max() const;
  void _internal_set_energy_max(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PassengerUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t tag_;
    float health_;
    float health_max_;
    float shield_;
    float energy_;
    uint32_t unit_type_;
    float shield_max_;
    float energy_max_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class RallyTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RallyTarget) */ {
 public:
  inline RallyTarget() : RallyTarget(nullptr) {}
  ~RallyTarget() override;
  explicit PROTOBUF_CONSTEXPR RallyTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RallyTarget(const RallyTarget& from);
  RallyTarget(RallyTarget&& from) noexcept
    : RallyTarget() {
    *this = ::std::move(from);
  }

  inline RallyTarget& operator=(const RallyTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline RallyTarget& operator=(RallyTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RallyTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const RallyTarget* internal_default_instance() {
    return reinterpret_cast<const RallyTarget*>(
               &_RallyTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RallyTarget& a, RallyTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(RallyTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RallyTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RallyTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RallyTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RallyTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RallyTarget& from) {
    RallyTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RallyTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RallyTarget";
  }
  protected:
  explicit RallyTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kTagFieldNumber = 2,
  };
  // optional .SC2APIProtocol.Point point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::SC2APIProtocol::Point& point() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_point();
  ::SC2APIProtocol::Point* mutable_point();
  void set_allocated_point(::SC2APIProtocol::Point* point);
  private:
  const ::SC2APIProtocol::Point& _internal_point() const;
  ::SC2APIProtocol::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::SC2APIProtocol::Point* point);
  ::SC2APIProtocol::Point* unsafe_arena_release_point();

  // optional uint64 tag = 2;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  uint64_t tag() const;
  void set_tag(uint64_t value);
  private:
  uint64_t _internal_tag() const;
  void _internal_set_tag(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RallyTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Point* point_;
    uint64_t tag_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Unit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Unit) */ {
 public:
  inline Unit() : Unit(nullptr) {}
  ~Unit() override;
  explicit PROTOBUF_CONSTEXPR Unit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Unit(const Unit& from);
  Unit(Unit&& from) noexcept
    : Unit() {
    *this = ::std::move(from);
  }

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unit& operator=(Unit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Unit* internal_default_instance() {
    return reinterpret_cast<const Unit*>(
               &_Unit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Unit& a, Unit& b) {
    a.Swap(&b);
  }
  inline void Swap(Unit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Unit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Unit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Unit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Unit& from) {
    Unit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Unit";
  }
  protected:
  explicit Unit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 22,
    kPassengersFieldNumber = 24,
    kBuffIdsFieldNumber = 27,
    kRallyTargetsFieldNumber = 45,
    kPosFieldNumber = 6,
    kTagFieldNumber = 3,
    kUnitTypeFieldNumber = 4,
    kOwnerFieldNumber = 5,
    kFacingFieldNumber = 7,
    kRadiusFieldNumber = 8,
    kBuildProgressFieldNumber = 9,
    kCloakFieldNumber = 10,
    kHealthFieldNumber = 14,
    kHealthMaxFieldNumber = 15,
    kShieldFieldNumber = 16,
    kEnergyFieldNumber = 17,
    kIsSelectedFieldNumber = 11,
    kIsOnScreenFieldNumber = 12,
    kIsBlipFieldNumber = 13,
    kIsPoweredFieldNumber = 35,
    kMineralContentsFieldNumber = 18,
    kVespeneContentsFieldNumber = 19,
    kCargoSpaceTakenFieldNumber = 25,
    kAddOnTagFieldNumber = 23,
    kCargoSpaceMaxFieldNumber = 26,
    kAssignedHarvestersFieldNumber = 28,
    kIdealHarvestersFieldNumber = 29,
    kIsActiveFieldNumber = 39,
    kIsFlyingFieldNumber = 20,
    kIsBurrowedFieldNumber = 21,
    kIsHallucinationFieldNumber = 38,
    kWeaponCooldownFieldNumber = 30,
    kDetectRangeFieldNumber = 31,
    kEngagedTargetTagFieldNumber = 34,
    kRadarRangeFieldNumber = 32,
    kShieldMaxFieldNumber = 36,
    kEnergyMaxFieldNumber = 37,
    kAttackUpgradeLevelFieldNumber = 40,
    kArmorUpgradeLevelFieldNumber = 41,
    kShieldUpgradeLevelFieldNumber = 42,
    kBuffDurationRemainFieldNumber = 43,
    kBuffDurationMaxFieldNumber = 44,
    kDisplayTypeFieldNumber = 1,
    kAllianceFieldNumber = 2,
  };
  // repeated .SC2APIProtocol.UnitOrder orders = 22;
  int orders_size() const;
  private:
  int _internal_orders_size() const;
  public:
  void clear_orders();
  ::SC2APIProtocol::UnitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitOrder >*
      mutable_orders();
  private:
  const ::SC2APIProtocol::UnitOrder& _internal_orders(int index) const;
  ::SC2APIProtocol::UnitOrder* _internal_add_orders();
  public:
  const ::SC2APIProtocol::UnitOrder& orders(int index) const;
  ::SC2APIProtocol::UnitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitOrder >&
      orders() const;

  // repeated .SC2APIProtocol.PassengerUnit passengers = 24;
  int passengers_size() const;
  private:
  int _internal_passengers_size() const;
  public:
  void clear_passengers();
  ::SC2APIProtocol::PassengerUnit* mutable_passengers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit >*
      mutable_passengers();
  private:
  const ::SC2APIProtocol::PassengerUnit& _internal_passengers(int index) const;
  ::SC2APIProtocol::PassengerUnit* _internal_add_passengers();
  public:
  const ::SC2APIProtocol::PassengerUnit& passengers(int index) const;
  ::SC2APIProtocol::PassengerUnit* add_passengers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit >&
      passengers() const;

  // repeated uint32 buff_ids = 27;
  int buff_ids_size() const;
  private:
  int _internal_buff_ids_size() const;
  public:
  void clear_buff_ids();
  private:
  uint32_t _internal_buff_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_buff_ids() const;
  void _internal_add_buff_ids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_buff_ids();
  public:
  uint32_t buff_ids(int index) const;
  void set_buff_ids(int index, uint32_t value);
  void add_buff_ids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      buff_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_buff_ids();

  // repeated .SC2APIProtocol.RallyTarget rally_targets = 45;
  int rally_targets_size() const;
  private:
  int _internal_rally_targets_size() const;
  public:
  void clear_rally_targets();
  ::SC2APIProtocol::RallyTarget* mutable_rally_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RallyTarget >*
      mutable_rally_targets();
  private:
  const ::SC2APIProtocol::RallyTarget& _internal_rally_targets(int index) const;
  ::SC2APIProtocol::RallyTarget* _internal_add_rally_targets();
  public:
  const ::SC2APIProtocol::RallyTarget& rally_targets(int index) const;
  ::SC2APIProtocol::RallyTarget* add_rally_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RallyTarget >&
      rally_targets() const;

  // optional .SC2APIProtocol.Point pos = 6;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::SC2APIProtocol::Point& pos() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_pos();
  ::SC2APIProtocol::Point* mutable_pos();
  void set_allocated_pos(::SC2APIProtocol::Point* pos);
  private:
  const ::SC2APIProtocol::Point& _internal_pos() const;
  ::SC2APIProtocol::Point* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::SC2APIProtocol::Point* pos);
  ::SC2APIProtocol::Point* unsafe_arena_release_pos();

  // optional uint64 tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  uint64_t tag() const;
  void set_tag(uint64_t value);
  private:
  uint64_t _internal_tag() const;
  void _internal_set_tag(uint64_t value);
  public:

  // optional uint32 unit_type = 4;
  bool has_unit_type() const;
  private:
  bool _internal_has_unit_type() const;
  public:
  void clear_unit_type();
  uint32_t unit_type() const;
  void set_unit_type(uint32_t value);
  private:
  uint32_t _internal_unit_type() const;
  void _internal_set_unit_type(uint32_t value);
  public:

  // optional int32 owner = 5;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  int32_t owner() const;
  void set_owner(int32_t value);
  private:
  int32_t _internal_owner() const;
  void _internal_set_owner(int32_t value);
  public:

  // optional float facing = 7;
  bool has_facing() const;
  private:
  bool _internal_has_facing() const;
  public:
  void clear_facing();
  float facing() const;
  void set_facing(float value);
  private:
  float _internal_facing() const;
  void _internal_set_facing(float value);
  public:

  // optional float radius = 8;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // optional float build_progress = 9;
  bool has_build_progress() const;
  private:
  bool _internal_has_build_progress() const;
  public:
  void clear_build_progress();
  float build_progress() const;
  void set_build_progress(float value);
  private:
  float _internal_build_progress() const;
  void _internal_set_build_progress(float value);
  public:

  // optional .SC2APIProtocol.CloakState cloak = 10;
  bool has_cloak() const;
  private:
  bool _internal_has_cloak() const;
  public:
  void clear_cloak();
  ::SC2APIProtocol::CloakState cloak() const;
  void set_cloak(::SC2APIProtocol::CloakState value);
  private:
  ::SC2APIProtocol::CloakState _internal_cloak() const;
  void _internal_set_cloak(::SC2APIProtocol::CloakState value);
  public:

  // optional float health = 14;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  float health() const;
  void set_health(float value);
  private:
  float _internal_health() const;
  void _internal_set_health(float value);
  public:

  // optional float health_max = 15;
  bool has_health_max() const;
  private:
  bool _internal_has_health_max() const;
  public:
  void clear_health_max();
  float health_max() const;
  void set_health_max(float value);
  private:
  float _internal_health_max() const;
  void _internal_set_health_max(float value);
  public:

  // optional float shield = 16;
  bool has_shield() const;
  private:
  bool _internal_has_shield() const;
  public:
  void clear_shield();
  float shield() const;
  void set_shield(float value);
  private:
  float _internal_shield() const;
  void _internal_set_shield(float value);
  public:

  // optional float energy = 17;
  bool has_energy() const;
  private:
  bool _internal_has_energy() const;
  public:
  void clear_energy();
  float energy() const;
  void set_energy(float value);
  private:
  float _internal_energy() const;
  void _internal_set_energy(float value);
  public:

  // optional bool is_selected = 11;
  bool has_is_selected() const;
  private:
  bool _internal_has_is_selected() const;
  public:
  void clear_is_selected();
  bool is_selected() const;
  void set_is_selected(bool value);
  private:
  bool _internal_is_selected() const;
  void _internal_set_is_selected(bool value);
  public:

  // optional bool is_on_screen = 12;
  bool has_is_on_screen() const;
  private:
  bool _internal_has_is_on_screen() const;
  public:
  void clear_is_on_screen();
  bool is_on_screen() const;
  void set_is_on_screen(bool value);
  private:
  bool _internal_is_on_screen() const;
  void _internal_set_is_on_screen(bool value);
  public:

  // optional bool is_blip = 13;
  bool has_is_blip() const;
  private:
  bool _internal_has_is_blip() const;
  public:
  void clear_is_blip();
  bool is_blip() const;
  void set_is_blip(bool value);
  private:
  bool _internal_is_blip() const;
  void _internal_set_is_blip(bool value);
  public:

  // optional bool is_powered = 35;
  bool has_is_powered() const;
  private:
  bool _internal_has_is_powered() const;
  public:
  void clear_is_powered();
  bool is_powered() const;
  void set_is_powered(bool value);
  private:
  bool _internal_is_powered() const;
  void _internal_set_is_powered(bool value);
  public:

  // optional int32 mineral_contents = 18;
  bool has_mineral_contents() const;
  private:
  bool _internal_has_mineral_contents() const;
  public:
  void clear_mineral_contents();
  int32_t mineral_contents() const;
  void set_mineral_contents(int32_t value);
  private:
  int32_t _internal_mineral_contents() const;
  void _internal_set_mineral_contents(int32_t value);
  public:

  // optional int32 vespene_contents = 19;
  bool has_vespene_contents() const;
  private:
  bool _internal_has_vespene_contents() const;
  public:
  void clear_vespene_contents();
  int32_t vespene_contents() const;
  void set_vespene_contents(int32_t value);
  private:
  int32_t _internal_vespene_contents() const;
  void _internal_set_vespene_contents(int32_t value);
  public:

  // optional int32 cargo_space_taken = 25;
  bool has_cargo_space_taken() const;
  private:
  bool _internal_has_cargo_space_taken() const;
  public:
  void clear_cargo_space_taken();
  int32_t cargo_space_taken() const;
  void set_cargo_space_taken(int32_t value);
  private:
  int32_t _internal_cargo_space_taken() const;
  void _internal_set_cargo_space_taken(int32_t value);
  public:

  // optional uint64 add_on_tag = 23;
  bool has_add_on_tag() const;
  private:
  bool _internal_has_add_on_tag() const;
  public:
  void clear_add_on_tag();
  uint64_t add_on_tag() const;
  void set_add_on_tag(uint64_t value);
  private:
  uint64_t _internal_add_on_tag() const;
  void _internal_set_add_on_tag(uint64_t value);
  public:

  // optional int32 cargo_space_max = 26;
  bool has_cargo_space_max() const;
  private:
  bool _internal_has_cargo_space_max() const;
  public:
  void clear_cargo_space_max();
  int32_t cargo_space_max() const;
  void set_cargo_space_max(int32_t value);
  private:
  int32_t _internal_cargo_space_max() const;
  void _internal_set_cargo_space_max(int32_t value);
  public:

  // optional int32 assigned_harvesters = 28;
  bool has_assigned_harvesters() const;
  private:
  bool _internal_has_assigned_harvesters() const;
  public:
  void clear_assigned_harvesters();
  int32_t assigned_harvesters() const;
  void set_assigned_harvesters(int32_t value);
  private:
  int32_t _internal_assigned_harvesters() const;
  void _internal_set_assigned_harvesters(int32_t value);
  public:

  // optional int32 ideal_harvesters = 29;
  bool has_ideal_harvesters() const;
  private:
  bool _internal_has_ideal_harvesters() const;
  public:
  void clear_ideal_harvesters();
  int32_t ideal_harvesters() const;
  void set_ideal_harvesters(int32_t value);
  private:
  int32_t _internal_ideal_harvesters() const;
  void _internal_set_ideal_harvesters(int32_t value);
  public:

  // optional bool is_active = 39;
  bool has_is_active() const;
  private:
  bool _internal_has_is_active() const;
  public:
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // optional bool is_flying = 20;
  bool has_is_flying() const;
  private:
  bool _internal_has_is_flying() const;
  public:
  void clear_is_flying();
  bool is_flying() const;
  void set_is_flying(bool value);
  private:
  bool _internal_is_flying() const;
  void _internal_set_is_flying(bool value);
  public:

  // optional bool is_burrowed = 21;
  bool has_is_burrowed() const;
  private:
  bool _internal_has_is_burrowed() const;
  public:
  void clear_is_burrowed();
  bool is_burrowed() const;
  void set_is_burrowed(bool value);
  private:
  bool _internal_is_burrowed() const;
  void _internal_set_is_burrowed(bool value);
  public:

  // optional bool is_hallucination = 38;
  bool has_is_hallucination() const;
  private:
  bool _internal_has_is_hallucination() const;
  public:
  void clear_is_hallucination();
  bool is_hallucination() const;
  void set_is_hallucination(bool value);
  private:
  bool _internal_is_hallucination() const;
  void _internal_set_is_hallucination(bool value);
  public:

  // optional float weapon_cooldown = 30;
  bool has_weapon_cooldown() const;
  private:
  bool _internal_has_weapon_cooldown() const;
  public:
  void clear_weapon_cooldown();
  float weapon_cooldown() const;
  void set_weapon_cooldown(float value);
  private:
  float _internal_weapon_cooldown() const;
  void _internal_set_weapon_cooldown(float value);
  public:

  // optional float detect_range = 31;
  bool has_detect_range() const;
  private:
  bool _internal_has_detect_range() const;
  public:
  void clear_detect_range();
  float detect_range() const;
  void set_detect_range(float value);
  private:
  float _internal_detect_range() const;
  void _internal_set_detect_range(float value);
  public:

  // optional uint64 engaged_target_tag = 34;
  bool has_engaged_target_tag() const;
  private:
  bool _internal_has_engaged_target_tag() const;
  public:
  void clear_engaged_target_tag();
  uint64_t engaged_target_tag() const;
  void set_engaged_target_tag(uint64_t value);
  private:
  uint64_t _internal_engaged_target_tag() const;
  void _internal_set_engaged_target_tag(uint64_t value);
  public:

  // optional float radar_range = 32;
  bool has_radar_range() const;
  private:
  bool _internal_has_radar_range() const;
  public:
  void clear_radar_range();
  float radar_range() const;
  void set_radar_range(float value);
  private:
  float _internal_radar_range() const;
  void _internal_set_radar_range(float value);
  public:

  // optional float shield_max = 36;
  bool has_shield_max() const;
  private:
  bool _internal_has_shield_max() const;
  public:
  void clear_shield_max();
  float shield_max() const;
  void set_shield_max(float value);
  private:
  float _internal_shield_max() const;
  void _internal_set_shield_max(float value);
  public:

  // optional float energy_max = 37;
  bool has_energy_max() const;
  private:
  bool _internal_has_energy_max() const;
  public:
  void clear_energy_max();
  float energy_max() const;
  void set_energy_max(float value);
  private:
  float _internal_energy_max() const;
  void _internal_set_energy_max(float value);
  public:

  // optional int32 attack_upgrade_level = 40;
  bool has_attack_upgrade_level() const;
  private:
  bool _internal_has_attack_upgrade_level() const;
  public:
  void clear_attack_upgrade_level();
  int32_t attack_upgrade_level() const;
  void set_attack_upgrade_level(int32_t value);
  private:
  int32_t _internal_attack_upgrade_level() const;
  void _internal_set_attack_upgrade_level(int32_t value);
  public:

  // optional int32 armor_upgrade_level = 41;
  bool has_armor_upgrade_level() const;
  private:
  bool _internal_has_armor_upgrade_level() const;
  public:
  void clear_armor_upgrade_level();
  int32_t armor_upgrade_level() const;
  void set_armor_upgrade_level(int32_t value);
  private:
  int32_t _internal_armor_upgrade_level() const;
  void _internal_set_armor_upgrade_level(int32_t value);
  public:

  // optional int32 shield_upgrade_level = 42;
  bool has_shield_upgrade_level() const;
  private:
  bool _internal_has_shield_upgrade_level() const;
  public:
  void clear_shield_upgrade_level();
  int32_t shield_upgrade_level() const;
  void set_shield_upgrade_level(int32_t value);
  private:
  int32_t _internal_shield_upgrade_level() const;
  void _internal_set_shield_upgrade_level(int32_t value);
  public:

  // optional int32 buff_duration_remain = 43;
  bool has_buff_duration_remain() const;
  private:
  bool _internal_has_buff_duration_remain() const;
  public:
  void clear_buff_duration_remain();
  int32_t buff_duration_remain() const;
  void set_buff_duration_remain(int32_t value);
  private:
  int32_t _internal_buff_duration_remain() const;
  void _internal_set_buff_duration_remain(int32_t value);
  public:

  // optional int32 buff_duration_max = 44;
  bool has_buff_duration_max() const;
  private:
  bool _internal_has_buff_duration_max() const;
  public:
  void clear_buff_duration_max();
  int32_t buff_duration_max() const;
  void set_buff_duration_max(int32_t value);
  private:
  int32_t _internal_buff_duration_max() const;
  void _internal_set_buff_duration_max(int32_t value);
  public:

  // optional .SC2APIProtocol.DisplayType display_type = 1;
  bool has_display_type() const;
  private:
  bool _internal_has_display_type() const;
  public:
  void clear_display_type();
  ::SC2APIProtocol::DisplayType display_type() const;
  void set_display_type(::SC2APIProtocol::DisplayType value);
  private:
  ::SC2APIProtocol::DisplayType _internal_display_type() const;
  void _internal_set_display_type(::SC2APIProtocol::DisplayType value);
  public:

  // optional .SC2APIProtocol.Alliance alliance = 2;
  bool has_alliance() const;
  private:
  bool _internal_has_alliance() const;
  public:
  void clear_alliance();
  ::SC2APIProtocol::Alliance alliance() const;
  void set_alliance(::SC2APIProtocol::Alliance value);
  private:
  ::SC2APIProtocol::Alliance _internal_alliance() const;
  void _internal_set_alliance(::SC2APIProtocol::Alliance value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Unit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitOrder > orders_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit > passengers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > buff_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RallyTarget > rally_targets_;
    ::SC2APIProtocol::Point* pos_;
    uint64_t tag_;
    uint32_t unit_type_;
    int32_t owner_;
    float facing_;
    float radius_;
    float build_progress_;
    int cloak_;
    float health_;
    float health_max_;
    float shield_;
    float energy_;
    bool is_selected_;
    bool is_on_screen_;
    bool is_blip_;
    bool is_powered_;
    int32_t mineral_contents_;
    int32_t vespene_contents_;
    int32_t cargo_space_taken_;
    uint64_t add_on_tag_;
    int32_t cargo_space_max_;
    int32_t assigned_harvesters_;
    int32_t ideal_harvesters_;
    bool is_active_;
    bool is_flying_;
    bool is_burrowed_;
    bool is_hallucination_;
    float weapon_cooldown_;
    float detect_range_;
    uint64_t engaged_target_tag_;
    float radar_range_;
    float shield_max_;
    float energy_max_;
    int32_t attack_upgrade_level_;
    int32_t armor_upgrade_level_;
    int32_t shield_upgrade_level_;
    int32_t buff_duration_remain_;
    int32_t buff_duration_max_;
    int display_type_;
    int alliance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class MapState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.MapState) */ {
 public:
  inline MapState() : MapState(nullptr) {}
  ~MapState() override;
  explicit PROTOBUF_CONSTEXPR MapState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapState(const MapState& from);
  MapState(MapState&& from) noexcept
    : MapState() {
    *this = ::std::move(from);
  }

  inline MapState& operator=(const MapState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapState& operator=(MapState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapState* internal_default_instance() {
    return reinterpret_cast<const MapState*>(
               &_MapState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MapState& a, MapState& b) {
    a.Swap(&b);
  }
  inline void Swap(MapState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapState& from) {
    MapState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.MapState";
  }
  protected:
  explicit MapState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisibilityFieldNumber = 1,
    kCreepFieldNumber = 2,
  };
  // optional .SC2APIProtocol.ImageData visibility = 1;
  bool has_visibility() const;
  private:
  bool _internal_has_visibility() const;
  public:
  void clear_visibility();
  const ::SC2APIProtocol::ImageData& visibility() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_visibility();
  ::SC2APIProtocol::ImageData* mutable_visibility();
  void set_allocated_visibility(::SC2APIProtocol::ImageData* visibility);
  private:
  const ::SC2APIProtocol::ImageData& _internal_visibility() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_visibility();
  public:
  void unsafe_arena_set_allocated_visibility(
      ::SC2APIProtocol::ImageData* visibility);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_visibility();

  // optional .SC2APIProtocol.ImageData creep = 2;
  bool has_creep() const;
  private:
  bool _internal_has_creep() const;
  public:
  void clear_creep();
  const ::SC2APIProtocol::ImageData& creep() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ImageData* release_creep();
  ::SC2APIProtocol::ImageData* mutable_creep();
  void set_allocated_creep(::SC2APIProtocol::ImageData* creep);
  private:
  const ::SC2APIProtocol::ImageData& _internal_creep() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_creep();
  public:
  void unsafe_arena_set_allocated_creep(
      ::SC2APIProtocol::ImageData* creep);
  ::SC2APIProtocol::ImageData* unsafe_arena_release_creep();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.MapState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::ImageData* visibility_;
    ::SC2APIProtocol::ImageData* creep_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event& from) {
    Event::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeadUnitsFieldNumber = 1,
  };
  // repeated uint64 dead_units = 1;
  int dead_units_size() const;
  private:
  int _internal_dead_units_size() const;
  public:
  void clear_dead_units();
  private:
  uint64_t _internal_dead_units(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_dead_units() const;
  void _internal_add_dead_units(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_dead_units();
  public:
  uint64_t dead_units(int index) const;
  void set_dead_units(int index, uint64_t value);
  void add_dead_units(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      dead_units() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_dead_units();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > dead_units_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Effect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Effect) */ {
 public:
  inline Effect() : Effect(nullptr) {}
  ~Effect() override;
  explicit PROTOBUF_CONSTEXPR Effect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Effect(const Effect& from);
  Effect(Effect&& from) noexcept
    : Effect() {
    *this = ::std::move(from);
  }

  inline Effect& operator=(const Effect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Effect& operator=(Effect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Effect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Effect* internal_default_instance() {
    return reinterpret_cast<const Effect*>(
               &_Effect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Effect& a, Effect& b) {
    a.Swap(&b);
  }
  inline void Swap(Effect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Effect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Effect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Effect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Effect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Effect& from) {
    Effect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Effect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Effect";
  }
  protected:
  explicit Effect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kEffectIdFieldNumber = 1,
    kOwnerFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kAllianceFieldNumber = 3,
  };
  // repeated .SC2APIProtocol.Point2D pos = 2;
  int pos_size() const;
  private:
  int _internal_pos_size() const;
  public:
  void clear_pos();
  ::SC2APIProtocol::Point2D* mutable_pos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D >*
      mutable_pos();
  private:
  const ::SC2APIProtocol::Point2D& _internal_pos(int index) const;
  ::SC2APIProtocol::Point2D* _internal_add_pos();
  public:
  const ::SC2APIProtocol::Point2D& pos(int index) const;
  ::SC2APIProtocol::Point2D* add_pos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D >&
      pos() const;

  // optional uint32 effect_id = 1;
  bool has_effect_id() const;
  private:
  bool _internal_has_effect_id() const;
  public:
  void clear_effect_id();
  uint32_t effect_id() const;
  void set_effect_id(uint32_t value);
  private:
  uint32_t _internal_effect_id() const;
  void _internal_set_effect_id(uint32_t value);
  public:

  // optional int32 owner = 4;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  int32_t owner() const;
  void set_owner(int32_t value);
  private:
  int32_t _internal_owner() const;
  void _internal_set_owner(int32_t value);
  public:

  // optional float radius = 5;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // optional .SC2APIProtocol.Alliance alliance = 3;
  bool has_alliance() const;
  private:
  bool _internal_has_alliance() const;
  public:
  void clear_alliance();
  ::SC2APIProtocol::Alliance alliance() const;
  void set_alliance(::SC2APIProtocol::Alliance value);
  private:
  ::SC2APIProtocol::Alliance _internal_alliance() const;
  void _internal_set_alliance(::SC2APIProtocol::Alliance value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Effect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D > pos_;
    uint32_t effect_id_;
    int32_t owner_;
    float radius_;
    int alliance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class ActionRaw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionRaw) */ {
 public:
  inline ActionRaw() : ActionRaw(nullptr) {}
  ~ActionRaw() override;
  explicit PROTOBUF_CONSTEXPR ActionRaw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionRaw(const ActionRaw& from);
  ActionRaw(ActionRaw&& from) noexcept
    : ActionRaw() {
    *this = ::std::move(from);
  }

  inline ActionRaw& operator=(const ActionRaw& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionRaw& operator=(ActionRaw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionRaw& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kUnitCommand = 1,
    kCameraMove = 2,
    kToggleAutocast = 3,
    ACTION_NOT_SET = 0,
  };

  static inline const ActionRaw* internal_default_instance() {
    return reinterpret_cast<const ActionRaw*>(
               &_ActionRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ActionRaw& a, ActionRaw& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionRaw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionRaw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionRaw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionRaw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionRaw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionRaw& from) {
    ActionRaw::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRaw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionRaw";
  }
  protected:
  explicit ActionRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitCommandFieldNumber = 1,
    kCameraMoveFieldNumber = 2,
    kToggleAutocastFieldNumber = 3,
  };
  // .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;
  bool has_unit_command() const;
  private:
  bool _internal_has_unit_command() const;
  public:
  void clear_unit_command();
  const ::SC2APIProtocol::ActionRawUnitCommand& unit_command() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ActionRawUnitCommand* release_unit_command();
  ::SC2APIProtocol::ActionRawUnitCommand* mutable_unit_command();
  void set_allocated_unit_command(::SC2APIProtocol::ActionRawUnitCommand* unit_command);
  private:
  const ::SC2APIProtocol::ActionRawUnitCommand& _internal_unit_command() const;
  ::SC2APIProtocol::ActionRawUnitCommand* _internal_mutable_unit_command();
  public:
  void unsafe_arena_set_allocated_unit_command(
      ::SC2APIProtocol::ActionRawUnitCommand* unit_command);
  ::SC2APIProtocol::ActionRawUnitCommand* unsafe_arena_release_unit_command();

  // .SC2APIProtocol.ActionRawCameraMove camera_move = 2;
  bool has_camera_move() const;
  private:
  bool _internal_has_camera_move() const;
  public:
  void clear_camera_move();
  const ::SC2APIProtocol::ActionRawCameraMove& camera_move() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ActionRawCameraMove* release_camera_move();
  ::SC2APIProtocol::ActionRawCameraMove* mutable_camera_move();
  void set_allocated_camera_move(::SC2APIProtocol::ActionRawCameraMove* camera_move);
  private:
  const ::SC2APIProtocol::ActionRawCameraMove& _internal_camera_move() const;
  ::SC2APIProtocol::ActionRawCameraMove* _internal_mutable_camera_move();
  public:
  void unsafe_arena_set_allocated_camera_move(
      ::SC2APIProtocol::ActionRawCameraMove* camera_move);
  ::SC2APIProtocol::ActionRawCameraMove* unsafe_arena_release_camera_move();

  // .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
  bool has_toggle_autocast() const;
  private:
  bool _internal_has_toggle_autocast() const;
  public:
  void clear_toggle_autocast();
  const ::SC2APIProtocol::ActionRawToggleAutocast& toggle_autocast() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::ActionRawToggleAutocast* release_toggle_autocast();
  ::SC2APIProtocol::ActionRawToggleAutocast* mutable_toggle_autocast();
  void set_allocated_toggle_autocast(::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast);
  private:
  const ::SC2APIProtocol::ActionRawToggleAutocast& _internal_toggle_autocast() const;
  ::SC2APIProtocol::ActionRawToggleAutocast* _internal_mutable_toggle_autocast();
  public:
  void unsafe_arena_set_allocated_toggle_autocast(
      ::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast);
  ::SC2APIProtocol::ActionRawToggleAutocast* unsafe_arena_release_toggle_autocast();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionRaw)
 private:
  class _Internal;
  void set_has_unit_command();
  void set_has_camera_move();
  void set_has_toggle_autocast();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SC2APIProtocol::ActionRawUnitCommand* unit_command_;
      ::SC2APIProtocol::ActionRawCameraMove* camera_move_;
      ::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class ActionRawUnitCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionRawUnitCommand) */ {
 public:
  inline ActionRawUnitCommand() : ActionRawUnitCommand(nullptr) {}
  ~ActionRawUnitCommand() override;
  explicit PROTOBUF_CONSTEXPR ActionRawUnitCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionRawUnitCommand(const ActionRawUnitCommand& from);
  ActionRawUnitCommand(ActionRawUnitCommand&& from) noexcept
    : ActionRawUnitCommand() {
    *this = ::std::move(from);
  }

  inline ActionRawUnitCommand& operator=(const ActionRawUnitCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionRawUnitCommand& operator=(ActionRawUnitCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionRawUnitCommand& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kTargetWorldSpacePos = 2,
    kTargetUnitTag = 3,
    TARGET_NOT_SET = 0,
  };

  static inline const ActionRawUnitCommand* internal_default_instance() {
    return reinterpret_cast<const ActionRawUnitCommand*>(
               &_ActionRawUnitCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ActionRawUnitCommand& a, ActionRawUnitCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionRawUnitCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionRawUnitCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionRawUnitCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionRawUnitCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionRawUnitCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionRawUnitCommand& from) {
    ActionRawUnitCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRawUnitCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionRawUnitCommand";
  }
  protected:
  explicit ActionRawUnitCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitTagsFieldNumber = 4,
    kAbilityIdFieldNumber = 1,
    kQueueCommandFieldNumber = 5,
    kTargetWorldSpacePosFieldNumber = 2,
    kTargetUnitTagFieldNumber = 3,
  };
  // repeated uint64 unit_tags = 4;
  int unit_tags_size() const;
  private:
  int _internal_unit_tags_size() const;
  public:
  void clear_unit_tags();
  private:
  uint64_t _internal_unit_tags(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_unit_tags() const;
  void _internal_add_unit_tags(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_unit_tags();
  public:
  uint64_t unit_tags(int index) const;
  void set_unit_tags(int index, uint64_t value);
  void add_unit_tags(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      unit_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_unit_tags();

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  int32_t ability_id() const;
  void set_ability_id(int32_t value);
  private:
  int32_t _internal_ability_id() const;
  void _internal_set_ability_id(int32_t value);
  public:

  // optional bool queue_command = 5;
  bool has_queue_command() const;
  private:
  bool _internal_has_queue_command() const;
  public:
  void clear_queue_command();
  bool queue_command() const;
  void set_queue_command(bool value);
  private:
  bool _internal_queue_command() const;
  void _internal_set_queue_command(bool value);
  public:

  // .SC2APIProtocol.Point2D target_world_space_pos = 2;
  bool has_target_world_space_pos() const;
  private:
  bool _internal_has_target_world_space_pos() const;
  public:
  void clear_target_world_space_pos();
  const ::SC2APIProtocol::Point2D& target_world_space_pos() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point2D* release_target_world_space_pos();
  ::SC2APIProtocol::Point2D* mutable_target_world_space_pos();
  void set_allocated_target_world_space_pos(::SC2APIProtocol::Point2D* target_world_space_pos);
  private:
  const ::SC2APIProtocol::Point2D& _internal_target_world_space_pos() const;
  ::SC2APIProtocol::Point2D* _internal_mutable_target_world_space_pos();
  public:
  void unsafe_arena_set_allocated_target_world_space_pos(
      ::SC2APIProtocol::Point2D* target_world_space_pos);
  ::SC2APIProtocol::Point2D* unsafe_arena_release_target_world_space_pos();

  // uint64 target_unit_tag = 3;
  bool has_target_unit_tag() const;
  private:
  bool _internal_has_target_unit_tag() const;
  public:
  void clear_target_unit_tag();
  uint64_t target_unit_tag() const;
  void set_target_unit_tag(uint64_t value);
  private:
  uint64_t _internal_target_unit_tag() const;
  void _internal_set_target_unit_tag(uint64_t value);
  public:

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionRawUnitCommand)
 private:
  class _Internal;
  void set_has_target_world_space_pos();
  void set_has_target_unit_tag();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > unit_tags_;
    int32_t ability_id_;
    bool queue_command_;
    union TargetUnion {
      constexpr TargetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SC2APIProtocol::Point2D* target_world_space_pos_;
      uint64_t target_unit_tag_;
    } target_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class ActionRawCameraMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionRawCameraMove) */ {
 public:
  inline ActionRawCameraMove() : ActionRawCameraMove(nullptr) {}
  ~ActionRawCameraMove() override;
  explicit PROTOBUF_CONSTEXPR ActionRawCameraMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionRawCameraMove(const ActionRawCameraMove& from);
  ActionRawCameraMove(ActionRawCameraMove&& from) noexcept
    : ActionRawCameraMove() {
    *this = ::std::move(from);
  }

  inline ActionRawCameraMove& operator=(const ActionRawCameraMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionRawCameraMove& operator=(ActionRawCameraMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionRawCameraMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionRawCameraMove* internal_default_instance() {
    return reinterpret_cast<const ActionRawCameraMove*>(
               &_ActionRawCameraMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ActionRawCameraMove& a, ActionRawCameraMove& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionRawCameraMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionRawCameraMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionRawCameraMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionRawCameraMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionRawCameraMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionRawCameraMove& from) {
    ActionRawCameraMove::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRawCameraMove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionRawCameraMove";
  }
  protected:
  explicit ActionRawCameraMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterWorldSpaceFieldNumber = 1,
  };
  // optional .SC2APIProtocol.Point center_world_space = 1;
  bool has_center_world_space() const;
  private:
  bool _internal_has_center_world_space() const;
  public:
  void clear_center_world_space();
  const ::SC2APIProtocol::Point& center_world_space() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_center_world_space();
  ::SC2APIProtocol::Point* mutable_center_world_space();
  void set_allocated_center_world_space(::SC2APIProtocol::Point* center_world_space);
  private:
  const ::SC2APIProtocol::Point& _internal_center_world_space() const;
  ::SC2APIProtocol::Point* _internal_mutable_center_world_space();
  public:
  void unsafe_arena_set_allocated_center_world_space(
      ::SC2APIProtocol::Point* center_world_space);
  ::SC2APIProtocol::Point* unsafe_arena_release_center_world_space();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionRawCameraMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Point* center_world_space_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// -------------------------------------------------------------------

class ActionRawToggleAutocast final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionRawToggleAutocast) */ {
 public:
  inline ActionRawToggleAutocast() : ActionRawToggleAutocast(nullptr) {}
  ~ActionRawToggleAutocast() override;
  explicit PROTOBUF_CONSTEXPR ActionRawToggleAutocast(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionRawToggleAutocast(const ActionRawToggleAutocast& from);
  ActionRawToggleAutocast(ActionRawToggleAutocast&& from) noexcept
    : ActionRawToggleAutocast() {
    *this = ::std::move(from);
  }

  inline ActionRawToggleAutocast& operator=(const ActionRawToggleAutocast& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionRawToggleAutocast& operator=(ActionRawToggleAutocast&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionRawToggleAutocast& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionRawToggleAutocast* internal_default_instance() {
    return reinterpret_cast<const ActionRawToggleAutocast*>(
               &_ActionRawToggleAutocast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ActionRawToggleAutocast& a, ActionRawToggleAutocast& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionRawToggleAutocast* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionRawToggleAutocast* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionRawToggleAutocast* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionRawToggleAutocast>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionRawToggleAutocast& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionRawToggleAutocast& from) {
    ActionRawToggleAutocast::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRawToggleAutocast* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionRawToggleAutocast";
  }
  protected:
  explicit ActionRawToggleAutocast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitTagsFieldNumber = 2,
    kAbilityIdFieldNumber = 1,
  };
  // repeated uint64 unit_tags = 2;
  int unit_tags_size() const;
  private:
  int _internal_unit_tags_size() const;
  public:
  void clear_unit_tags();
  private:
  uint64_t _internal_unit_tags(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_unit_tags() const;
  void _internal_add_unit_tags(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_unit_tags();
  public:
  uint64_t unit_tags(int index) const;
  void set_unit_tags(int index, uint64_t value);
  void add_unit_tags(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      unit_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_unit_tags();

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  int32_t ability_id() const;
  void set_ability_id(int32_t value);
  private:
  int32_t _internal_ability_id() const;
  void _internal_set_ability_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionRawToggleAutocast)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > unit_tags_;
    int32_t ability_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fraw_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StartRaw

// optional .SC2APIProtocol.Size2DI map_size = 1;
inline bool StartRaw::_internal_has_map_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.map_size_ != nullptr);
  return value;
}
inline bool StartRaw::has_map_size() const {
  return _internal_has_map_size();
}
inline const ::SC2APIProtocol::Size2DI& StartRaw::_internal_map_size() const {
  const ::SC2APIProtocol::Size2DI* p = _impl_.map_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Size2DI&>(
      ::SC2APIProtocol::_Size2DI_default_instance_);
}
inline const ::SC2APIProtocol::Size2DI& StartRaw::map_size() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.map_size)
  return _internal_map_size();
}
inline void StartRaw::unsafe_arena_set_allocated_map_size(
    ::SC2APIProtocol::Size2DI* map_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_size_);
  }
  _impl_.map_size_ = map_size;
  if (map_size) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.StartRaw.map_size)
}
inline ::SC2APIProtocol::Size2DI* StartRaw::release_map_size() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Size2DI* temp = _impl_.map_size_;
  _impl_.map_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Size2DI* StartRaw::unsafe_arena_release_map_size() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.map_size)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Size2DI* temp = _impl_.map_size_;
  _impl_.map_size_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Size2DI* StartRaw::_internal_mutable_map_size() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.map_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Size2DI>(GetArenaForAllocation());
    _impl_.map_size_ = p;
  }
  return _impl_.map_size_;
}
inline ::SC2APIProtocol::Size2DI* StartRaw::mutable_map_size() {
  ::SC2APIProtocol::Size2DI* _msg = _internal_mutable_map_size();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.map_size)
  return _msg;
}
inline void StartRaw::set_allocated_map_size(::SC2APIProtocol::Size2DI* map_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_size_);
  }
  if (map_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(map_size));
    if (message_arena != submessage_arena) {
      map_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_size, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_size_ = map_size;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.map_size)
}

// optional .SC2APIProtocol.ImageData pathing_grid = 2;
inline bool StartRaw::_internal_has_pathing_grid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathing_grid_ != nullptr);
  return value;
}
inline bool StartRaw::has_pathing_grid() const {
  return _internal_has_pathing_grid();
}
inline const ::SC2APIProtocol::ImageData& StartRaw::_internal_pathing_grid() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.pathing_grid_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& StartRaw::pathing_grid() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.pathing_grid)
  return _internal_pathing_grid();
}
inline void StartRaw::unsafe_arena_set_allocated_pathing_grid(
    ::SC2APIProtocol::ImageData* pathing_grid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathing_grid_);
  }
  _impl_.pathing_grid_ = pathing_grid;
  if (pathing_grid) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.StartRaw.pathing_grid)
}
inline ::SC2APIProtocol::ImageData* StartRaw::release_pathing_grid() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.pathing_grid_;
  _impl_.pathing_grid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* StartRaw::unsafe_arena_release_pathing_grid() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.pathing_grid)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.pathing_grid_;
  _impl_.pathing_grid_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* StartRaw::_internal_mutable_pathing_grid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pathing_grid_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.pathing_grid_ = p;
  }
  return _impl_.pathing_grid_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::mutable_pathing_grid() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_pathing_grid();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.pathing_grid)
  return _msg;
}
inline void StartRaw::set_allocated_pathing_grid(::SC2APIProtocol::ImageData* pathing_grid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathing_grid_);
  }
  if (pathing_grid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathing_grid));
    if (message_arena != submessage_arena) {
      pathing_grid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathing_grid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pathing_grid_ = pathing_grid;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.pathing_grid)
}

// optional .SC2APIProtocol.ImageData terrain_height = 3;
inline bool StartRaw::_internal_has_terrain_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.terrain_height_ != nullptr);
  return value;
}
inline bool StartRaw::has_terrain_height() const {
  return _internal_has_terrain_height();
}
inline const ::SC2APIProtocol::ImageData& StartRaw::_internal_terrain_height() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.terrain_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& StartRaw::terrain_height() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.terrain_height)
  return _internal_terrain_height();
}
inline void StartRaw::unsafe_arena_set_allocated_terrain_height(
    ::SC2APIProtocol::ImageData* terrain_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terrain_height_);
  }
  _impl_.terrain_height_ = terrain_height;
  if (terrain_height) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.StartRaw.terrain_height)
}
inline ::SC2APIProtocol::ImageData* StartRaw::release_terrain_height() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ImageData* temp = _impl_.terrain_height_;
  _impl_.terrain_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* StartRaw::unsafe_arena_release_terrain_height() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.terrain_height)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ImageData* temp = _impl_.terrain_height_;
  _impl_.terrain_height_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* StartRaw::_internal_mutable_terrain_height() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.terrain_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.terrain_height_ = p;
  }
  return _impl_.terrain_height_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::mutable_terrain_height() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_terrain_height();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.terrain_height)
  return _msg;
}
inline void StartRaw::set_allocated_terrain_height(::SC2APIProtocol::ImageData* terrain_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terrain_height_);
  }
  if (terrain_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(terrain_height));
    if (message_arena != submessage_arena) {
      terrain_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terrain_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.terrain_height_ = terrain_height;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.terrain_height)
}

// optional .SC2APIProtocol.ImageData placement_grid = 4;
inline bool StartRaw::_internal_has_placement_grid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.placement_grid_ != nullptr);
  return value;
}
inline bool StartRaw::has_placement_grid() const {
  return _internal_has_placement_grid();
}
inline const ::SC2APIProtocol::ImageData& StartRaw::_internal_placement_grid() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.placement_grid_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& StartRaw::placement_grid() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.placement_grid)
  return _internal_placement_grid();
}
inline void StartRaw::unsafe_arena_set_allocated_placement_grid(
    ::SC2APIProtocol::ImageData* placement_grid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placement_grid_);
  }
  _impl_.placement_grid_ = placement_grid;
  if (placement_grid) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.StartRaw.placement_grid)
}
inline ::SC2APIProtocol::ImageData* StartRaw::release_placement_grid() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ImageData* temp = _impl_.placement_grid_;
  _impl_.placement_grid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* StartRaw::unsafe_arena_release_placement_grid() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.placement_grid)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ImageData* temp = _impl_.placement_grid_;
  _impl_.placement_grid_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* StartRaw::_internal_mutable_placement_grid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.placement_grid_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.placement_grid_ = p;
  }
  return _impl_.placement_grid_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::mutable_placement_grid() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_placement_grid();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.placement_grid)
  return _msg;
}
inline void StartRaw::set_allocated_placement_grid(::SC2APIProtocol::ImageData* placement_grid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placement_grid_);
  }
  if (placement_grid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placement_grid));
    if (message_arena != submessage_arena) {
      placement_grid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placement_grid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.placement_grid_ = placement_grid;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.placement_grid)
}

// optional .SC2APIProtocol.RectangleI playable_area = 5;
inline bool StartRaw::_internal_has_playable_area() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.playable_area_ != nullptr);
  return value;
}
inline bool StartRaw::has_playable_area() const {
  return _internal_has_playable_area();
}
inline const ::SC2APIProtocol::RectangleI& StartRaw::_internal_playable_area() const {
  const ::SC2APIProtocol::RectangleI* p = _impl_.playable_area_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::RectangleI&>(
      ::SC2APIProtocol::_RectangleI_default_instance_);
}
inline const ::SC2APIProtocol::RectangleI& StartRaw::playable_area() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.playable_area)
  return _internal_playable_area();
}
inline void StartRaw::unsafe_arena_set_allocated_playable_area(
    ::SC2APIProtocol::RectangleI* playable_area) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playable_area_);
  }
  _impl_.playable_area_ = playable_area;
  if (playable_area) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.StartRaw.playable_area)
}
inline ::SC2APIProtocol::RectangleI* StartRaw::release_playable_area() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::RectangleI* temp = _impl_.playable_area_;
  _impl_.playable_area_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::RectangleI* StartRaw::unsafe_arena_release_playable_area() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.playable_area)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::RectangleI* temp = _impl_.playable_area_;
  _impl_.playable_area_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::RectangleI* StartRaw::_internal_mutable_playable_area() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.playable_area_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::RectangleI>(GetArenaForAllocation());
    _impl_.playable_area_ = p;
  }
  return _impl_.playable_area_;
}
inline ::SC2APIProtocol::RectangleI* StartRaw::mutable_playable_area() {
  ::SC2APIProtocol::RectangleI* _msg = _internal_mutable_playable_area();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.playable_area)
  return _msg;
}
inline void StartRaw::set_allocated_playable_area(::SC2APIProtocol::RectangleI* playable_area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playable_area_);
  }
  if (playable_area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playable_area));
    if (message_arena != submessage_arena) {
      playable_area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playable_area, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.playable_area_ = playable_area;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.playable_area)
}

// repeated .SC2APIProtocol.Point2D start_locations = 6;
inline int StartRaw::_internal_start_locations_size() const {
  return _impl_.start_locations_.size();
}
inline int StartRaw::start_locations_size() const {
  return _internal_start_locations_size();
}
inline ::SC2APIProtocol::Point2D* StartRaw::mutable_start_locations(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.start_locations)
  return _impl_.start_locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D >*
StartRaw::mutable_start_locations() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.StartRaw.start_locations)
  return &_impl_.start_locations_;
}
inline const ::SC2APIProtocol::Point2D& StartRaw::_internal_start_locations(int index) const {
  return _impl_.start_locations_.Get(index);
}
inline const ::SC2APIProtocol::Point2D& StartRaw::start_locations(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.start_locations)
  return _internal_start_locations(index);
}
inline ::SC2APIProtocol::Point2D* StartRaw::_internal_add_start_locations() {
  return _impl_.start_locations_.Add();
}
inline ::SC2APIProtocol::Point2D* StartRaw::add_start_locations() {
  ::SC2APIProtocol::Point2D* _add = _internal_add_start_locations();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.StartRaw.start_locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D >&
StartRaw::start_locations() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.StartRaw.start_locations)
  return _impl_.start_locations_;
}

// -------------------------------------------------------------------

// ObservationRaw

// optional .SC2APIProtocol.PlayerRaw player = 1;
inline bool ObservationRaw::_internal_has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline bool ObservationRaw::has_player() const {
  return _internal_has_player();
}
inline void ObservationRaw::clear_player() {
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::PlayerRaw& ObservationRaw::_internal_player() const {
  const ::SC2APIProtocol::PlayerRaw* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::PlayerRaw&>(
      ::SC2APIProtocol::_PlayerRaw_default_instance_);
}
inline const ::SC2APIProtocol::PlayerRaw& ObservationRaw::player() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.player)
  return _internal_player();
}
inline void ObservationRaw::unsafe_arena_set_allocated_player(
    ::SC2APIProtocol::PlayerRaw* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ObservationRaw.player)
}
inline ::SC2APIProtocol::PlayerRaw* ObservationRaw::release_player() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PlayerRaw* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::PlayerRaw* ObservationRaw::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRaw.player)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PlayerRaw* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PlayerRaw* ObservationRaw::_internal_mutable_player() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PlayerRaw>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::SC2APIProtocol::PlayerRaw* ObservationRaw::mutable_player() {
  ::SC2APIProtocol::PlayerRaw* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.player)
  return _msg;
}
inline void ObservationRaw::set_allocated_player(::SC2APIProtocol::PlayerRaw* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRaw.player)
}

// repeated .SC2APIProtocol.Unit units = 2;
inline int ObservationRaw::_internal_units_size() const {
  return _impl_.units_.size();
}
inline int ObservationRaw::units_size() const {
  return _internal_units_size();
}
inline void ObservationRaw::clear_units() {
  _impl_.units_.Clear();
}
inline ::SC2APIProtocol::Unit* ObservationRaw::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.units)
  return _impl_.units_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Unit >*
ObservationRaw::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ObservationRaw.units)
  return &_impl_.units_;
}
inline const ::SC2APIProtocol::Unit& ObservationRaw::_internal_units(int index) const {
  return _impl_.units_.Get(index);
}
inline const ::SC2APIProtocol::Unit& ObservationRaw::units(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.units)
  return _internal_units(index);
}
inline ::SC2APIProtocol::Unit* ObservationRaw::_internal_add_units() {
  return _impl_.units_.Add();
}
inline ::SC2APIProtocol::Unit* ObservationRaw::add_units() {
  ::SC2APIProtocol::Unit* _add = _internal_add_units();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ObservationRaw.units)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Unit >&
ObservationRaw::units() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ObservationRaw.units)
  return _impl_.units_;
}

// optional .SC2APIProtocol.MapState map_state = 3;
inline bool ObservationRaw::_internal_has_map_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.map_state_ != nullptr);
  return value;
}
inline bool ObservationRaw::has_map_state() const {
  return _internal_has_map_state();
}
inline void ObservationRaw::clear_map_state() {
  if (_impl_.map_state_ != nullptr) _impl_.map_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::MapState& ObservationRaw::_internal_map_state() const {
  const ::SC2APIProtocol::MapState* p = _impl_.map_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::MapState&>(
      ::SC2APIProtocol::_MapState_default_instance_);
}
inline const ::SC2APIProtocol::MapState& ObservationRaw::map_state() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.map_state)
  return _internal_map_state();
}
inline void ObservationRaw::unsafe_arena_set_allocated_map_state(
    ::SC2APIProtocol::MapState* map_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_state_);
  }
  _impl_.map_state_ = map_state;
  if (map_state) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ObservationRaw.map_state)
}
inline ::SC2APIProtocol::MapState* ObservationRaw::release_map_state() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::MapState* temp = _impl_.map_state_;
  _impl_.map_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::MapState* ObservationRaw::unsafe_arena_release_map_state() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRaw.map_state)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::MapState* temp = _impl_.map_state_;
  _impl_.map_state_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::MapState* ObservationRaw::_internal_mutable_map_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.map_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::MapState>(GetArenaForAllocation());
    _impl_.map_state_ = p;
  }
  return _impl_.map_state_;
}
inline ::SC2APIProtocol::MapState* ObservationRaw::mutable_map_state() {
  ::SC2APIProtocol::MapState* _msg = _internal_mutable_map_state();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.map_state)
  return _msg;
}
inline void ObservationRaw::set_allocated_map_state(::SC2APIProtocol::MapState* map_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.map_state_;
  }
  if (map_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map_state);
    if (message_arena != submessage_arena) {
      map_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.map_state_ = map_state;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRaw.map_state)
}

// optional .SC2APIProtocol.Event event = 4;
inline bool ObservationRaw::_internal_has_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.event_ != nullptr);
  return value;
}
inline bool ObservationRaw::has_event() const {
  return _internal_has_event();
}
inline void ObservationRaw::clear_event() {
  if (_impl_.event_ != nullptr) _impl_.event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::SC2APIProtocol::Event& ObservationRaw::_internal_event() const {
  const ::SC2APIProtocol::Event* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Event&>(
      ::SC2APIProtocol::_Event_default_instance_);
}
inline const ::SC2APIProtocol::Event& ObservationRaw::event() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.event)
  return _internal_event();
}
inline void ObservationRaw::unsafe_arena_set_allocated_event(
    ::SC2APIProtocol::Event* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = event;
  if (event) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ObservationRaw.event)
}
inline ::SC2APIProtocol::Event* ObservationRaw::release_event() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Event* ObservationRaw::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRaw.event)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Event* ObservationRaw::_internal_mutable_event() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Event>(GetArenaForAllocation());
    _impl_.event_ = p;
  }
  return _impl_.event_;
}
inline ::SC2APIProtocol::Event* ObservationRaw::mutable_event() {
  ::SC2APIProtocol::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.event)
  return _msg;
}
inline void ObservationRaw::set_allocated_event(::SC2APIProtocol::Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.event_ = event;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRaw.event)
}

// repeated .SC2APIProtocol.Effect effects = 5;
inline int ObservationRaw::_internal_effects_size() const {
  return _impl_.effects_.size();
}
inline int ObservationRaw::effects_size() const {
  return _internal_effects_size();
}
inline void ObservationRaw::clear_effects() {
  _impl_.effects_.Clear();
}
inline ::SC2APIProtocol::Effect* ObservationRaw::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.effects)
  return _impl_.effects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Effect >*
ObservationRaw::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ObservationRaw.effects)
  return &_impl_.effects_;
}
inline const ::SC2APIProtocol::Effect& ObservationRaw::_internal_effects(int index) const {
  return _impl_.effects_.Get(index);
}
inline const ::SC2APIProtocol::Effect& ObservationRaw::effects(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.effects)
  return _internal_effects(index);
}
inline ::SC2APIProtocol::Effect* ObservationRaw::_internal_add_effects() {
  return _impl_.effects_.Add();
}
inline ::SC2APIProtocol::Effect* ObservationRaw::add_effects() {
  ::SC2APIProtocol::Effect* _add = _internal_add_effects();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ObservationRaw.effects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Effect >&
ObservationRaw::effects() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ObservationRaw.effects)
  return _impl_.effects_;
}

// repeated .SC2APIProtocol.RadarRing radar = 6;
inline int ObservationRaw::_internal_radar_size() const {
  return _impl_.radar_.size();
}
inline int ObservationRaw::radar_size() const {
  return _internal_radar_size();
}
inline void ObservationRaw::clear_radar() {
  _impl_.radar_.Clear();
}
inline ::SC2APIProtocol::RadarRing* ObservationRaw::mutable_radar(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.radar)
  return _impl_.radar_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RadarRing >*
ObservationRaw::mutable_radar() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ObservationRaw.radar)
  return &_impl_.radar_;
}
inline const ::SC2APIProtocol::RadarRing& ObservationRaw::_internal_radar(int index) const {
  return _impl_.radar_.Get(index);
}
inline const ::SC2APIProtocol::RadarRing& ObservationRaw::radar(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.radar)
  return _internal_radar(index);
}
inline ::SC2APIProtocol::RadarRing* ObservationRaw::_internal_add_radar() {
  return _impl_.radar_.Add();
}
inline ::SC2APIProtocol::RadarRing* ObservationRaw::add_radar() {
  ::SC2APIProtocol::RadarRing* _add = _internal_add_radar();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ObservationRaw.radar)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RadarRing >&
ObservationRaw::radar() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ObservationRaw.radar)
  return _impl_.radar_;
}

// -------------------------------------------------------------------

// RadarRing

// optional .SC2APIProtocol.Point pos = 1;
inline bool RadarRing::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline bool RadarRing::has_pos() const {
  return _internal_has_pos();
}
inline const ::SC2APIProtocol::Point& RadarRing::_internal_pos() const {
  const ::SC2APIProtocol::Point* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& RadarRing::pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RadarRing.pos)
  return _internal_pos();
}
inline void RadarRing::unsafe_arena_set_allocated_pos(
    ::SC2APIProtocol::Point* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.RadarRing.pos)
}
inline ::SC2APIProtocol::Point* RadarRing::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* RadarRing::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RadarRing.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* RadarRing::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::SC2APIProtocol::Point* RadarRing::mutable_pos() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RadarRing.pos)
  return _msg;
}
inline void RadarRing::set_allocated_pos(::SC2APIProtocol::Point* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RadarRing.pos)
}

// optional float radius = 2;
inline bool RadarRing::_internal_has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RadarRing::has_radius() const {
  return _internal_has_radius();
}
inline void RadarRing::clear_radius() {
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float RadarRing::_internal_radius() const {
  return _impl_.radius_;
}
inline float RadarRing::radius() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RadarRing.radius)
  return _internal_radius();
}
inline void RadarRing::_internal_set_radius(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.radius_ = value;
}
inline void RadarRing::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RadarRing.radius)
}

// -------------------------------------------------------------------

// PowerSource

// optional .SC2APIProtocol.Point pos = 1;
inline bool PowerSource::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline bool PowerSource::has_pos() const {
  return _internal_has_pos();
}
inline const ::SC2APIProtocol::Point& PowerSource::_internal_pos() const {
  const ::SC2APIProtocol::Point* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& PowerSource::pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PowerSource.pos)
  return _internal_pos();
}
inline void PowerSource::unsafe_arena_set_allocated_pos(
    ::SC2APIProtocol::Point* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.PowerSource.pos)
}
inline ::SC2APIProtocol::Point* PowerSource::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* PowerSource::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PowerSource.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* PowerSource::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::SC2APIProtocol::Point* PowerSource::mutable_pos() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PowerSource.pos)
  return _msg;
}
inline void PowerSource::set_allocated_pos(::SC2APIProtocol::Point* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PowerSource.pos)
}

// optional float radius = 2;
inline bool PowerSource::_internal_has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PowerSource::has_radius() const {
  return _internal_has_radius();
}
inline void PowerSource::clear_radius() {
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float PowerSource::_internal_radius() const {
  return _impl_.radius_;
}
inline float PowerSource::radius() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PowerSource.radius)
  return _internal_radius();
}
inline void PowerSource::_internal_set_radius(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.radius_ = value;
}
inline void PowerSource::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PowerSource.radius)
}

// optional uint64 tag = 3;
inline bool PowerSource::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PowerSource::has_tag() const {
  return _internal_has_tag();
}
inline void PowerSource::clear_tag() {
  _impl_.tag_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PowerSource::_internal_tag() const {
  return _impl_.tag_;
}
inline uint64_t PowerSource::tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PowerSource.tag)
  return _internal_tag();
}
inline void PowerSource::_internal_set_tag(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tag_ = value;
}
inline void PowerSource::set_tag(uint64_t value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PowerSource.tag)
}

// -------------------------------------------------------------------

// PlayerRaw

// repeated .SC2APIProtocol.PowerSource power_sources = 1;
inline int PlayerRaw::_internal_power_sources_size() const {
  return _impl_.power_sources_.size();
}
inline int PlayerRaw::power_sources_size() const {
  return _internal_power_sources_size();
}
inline void PlayerRaw::clear_power_sources() {
  _impl_.power_sources_.Clear();
}
inline ::SC2APIProtocol::PowerSource* PlayerRaw::mutable_power_sources(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerRaw.power_sources)
  return _impl_.power_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PowerSource >*
PlayerRaw::mutable_power_sources() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.PlayerRaw.power_sources)
  return &_impl_.power_sources_;
}
inline const ::SC2APIProtocol::PowerSource& PlayerRaw::_internal_power_sources(int index) const {
  return _impl_.power_sources_.Get(index);
}
inline const ::SC2APIProtocol::PowerSource& PlayerRaw::power_sources(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerRaw.power_sources)
  return _internal_power_sources(index);
}
inline ::SC2APIProtocol::PowerSource* PlayerRaw::_internal_add_power_sources() {
  return _impl_.power_sources_.Add();
}
inline ::SC2APIProtocol::PowerSource* PlayerRaw::add_power_sources() {
  ::SC2APIProtocol::PowerSource* _add = _internal_add_power_sources();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.PlayerRaw.power_sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PowerSource >&
PlayerRaw::power_sources() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.PlayerRaw.power_sources)
  return _impl_.power_sources_;
}

// optional .SC2APIProtocol.Point camera = 2;
inline bool PlayerRaw::_internal_has_camera() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_ != nullptr);
  return value;
}
inline bool PlayerRaw::has_camera() const {
  return _internal_has_camera();
}
inline const ::SC2APIProtocol::Point& PlayerRaw::_internal_camera() const {
  const ::SC2APIProtocol::Point* p = _impl_.camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& PlayerRaw::camera() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerRaw.camera)
  return _internal_camera();
}
inline void PlayerRaw::unsafe_arena_set_allocated_camera(
    ::SC2APIProtocol::Point* camera) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_);
  }
  _impl_.camera_ = camera;
  if (camera) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.PlayerRaw.camera)
}
inline ::SC2APIProtocol::Point* PlayerRaw::release_camera() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* PlayerRaw::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerRaw.camera)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* PlayerRaw::_internal_mutable_camera() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.camera_ = p;
  }
  return _impl_.camera_;
}
inline ::SC2APIProtocol::Point* PlayerRaw::mutable_camera() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerRaw.camera)
  return _msg;
}
inline void PlayerRaw::set_allocated_camera(::SC2APIProtocol::Point* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_);
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera));
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerRaw.camera)
}

// repeated uint32 upgrade_ids = 3;
inline int PlayerRaw::_internal_upgrade_ids_size() const {
  return _impl_.upgrade_ids_.size();
}
inline int PlayerRaw::upgrade_ids_size() const {
  return _internal_upgrade_ids_size();
}
inline void PlayerRaw::clear_upgrade_ids() {
  _impl_.upgrade_ids_.Clear();
}
inline uint32_t PlayerRaw::_internal_upgrade_ids(int index) const {
  return _impl_.upgrade_ids_.Get(index);
}
inline uint32_t PlayerRaw::upgrade_ids(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerRaw.upgrade_ids)
  return _internal_upgrade_ids(index);
}
inline void PlayerRaw::set_upgrade_ids(int index, uint32_t value) {
  _impl_.upgrade_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerRaw.upgrade_ids)
}
inline void PlayerRaw::_internal_add_upgrade_ids(uint32_t value) {
  _impl_.upgrade_ids_.Add(value);
}
inline void PlayerRaw::add_upgrade_ids(uint32_t value) {
  _internal_add_upgrade_ids(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.PlayerRaw.upgrade_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerRaw::_internal_upgrade_ids() const {
  return _impl_.upgrade_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerRaw::upgrade_ids() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.PlayerRaw.upgrade_ids)
  return _internal_upgrade_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerRaw::_internal_mutable_upgrade_ids() {
  return &_impl_.upgrade_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerRaw::mutable_upgrade_ids() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.PlayerRaw.upgrade_ids)
  return _internal_mutable_upgrade_ids();
}

// -------------------------------------------------------------------

// UnitOrder

// optional uint32 ability_id = 1;
inline bool UnitOrder::_internal_has_ability_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitOrder::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void UnitOrder::clear_ability_id() {
  _impl_.ability_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t UnitOrder::_internal_ability_id() const {
  return _impl_.ability_id_;
}
inline uint32_t UnitOrder::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitOrder.ability_id)
  return _internal_ability_id();
}
inline void UnitOrder::_internal_set_ability_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ability_id_ = value;
}
inline void UnitOrder::set_ability_id(uint32_t value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitOrder.ability_id)
}

// .SC2APIProtocol.Point target_world_space_pos = 2;
inline bool UnitOrder::_internal_has_target_world_space_pos() const {
  return target_case() == kTargetWorldSpacePos;
}
inline bool UnitOrder::has_target_world_space_pos() const {
  return _internal_has_target_world_space_pos();
}
inline void UnitOrder::set_has_target_world_space_pos() {
  _impl_._oneof_case_[0] = kTargetWorldSpacePos;
}
inline ::SC2APIProtocol::Point* UnitOrder::release_target_world_space_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.UnitOrder.target_world_space_pos)
  if (_internal_has_target_world_space_pos()) {
    clear_has_target();
    ::SC2APIProtocol::Point* temp = _impl_.target_.target_world_space_pos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_.target_world_space_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::Point& UnitOrder::_internal_target_world_space_pos() const {
  return _internal_has_target_world_space_pos()
      ? *_impl_.target_.target_world_space_pos_
      : reinterpret_cast< ::SC2APIProtocol::Point&>(::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& UnitOrder::target_world_space_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitOrder.target_world_space_pos)
  return _internal_target_world_space_pos();
}
inline ::SC2APIProtocol::Point* UnitOrder::unsafe_arena_release_target_world_space_pos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.UnitOrder.target_world_space_pos)
  if (_internal_has_target_world_space_pos()) {
    clear_has_target();
    ::SC2APIProtocol::Point* temp = _impl_.target_.target_world_space_pos_;
    _impl_.target_.target_world_space_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UnitOrder::unsafe_arena_set_allocated_target_world_space_pos(::SC2APIProtocol::Point* target_world_space_pos) {
  clear_target();
  if (target_world_space_pos) {
    set_has_target_world_space_pos();
    _impl_.target_.target_world_space_pos_ = target_world_space_pos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.UnitOrder.target_world_space_pos)
}
inline ::SC2APIProtocol::Point* UnitOrder::_internal_mutable_target_world_space_pos() {
  if (!_internal_has_target_world_space_pos()) {
    clear_target();
    set_has_target_world_space_pos();
    _impl_.target_.target_world_space_pos_ = CreateMaybeMessage< ::SC2APIProtocol::Point >(GetArenaForAllocation());
  }
  return _impl_.target_.target_world_space_pos_;
}
inline ::SC2APIProtocol::Point* UnitOrder::mutable_target_world_space_pos() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_target_world_space_pos();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.UnitOrder.target_world_space_pos)
  return _msg;
}

// uint64 target_unit_tag = 3;
inline bool UnitOrder::_internal_has_target_unit_tag() const {
  return target_case() == kTargetUnitTag;
}
inline bool UnitOrder::has_target_unit_tag() const {
  return _internal_has_target_unit_tag();
}
inline void UnitOrder::set_has_target_unit_tag() {
  _impl_._oneof_case_[0] = kTargetUnitTag;
}
inline void UnitOrder::clear_target_unit_tag() {
  if (_internal_has_target_unit_tag()) {
    _impl_.target_.target_unit_tag_ = uint64_t{0u};
    clear_has_target();
  }
}
inline uint64_t UnitOrder::_internal_target_unit_tag() const {
  if (_internal_has_target_unit_tag()) {
    return _impl_.target_.target_unit_tag_;
  }
  return uint64_t{0u};
}
inline void UnitOrder::_internal_set_target_unit_tag(uint64_t value) {
  if (!_internal_has_target_unit_tag()) {
    clear_target();
    set_has_target_unit_tag();
  }
  _impl_.target_.target_unit_tag_ = value;
}
inline uint64_t UnitOrder::target_unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitOrder.target_unit_tag)
  return _internal_target_unit_tag();
}
inline void UnitOrder::set_target_unit_tag(uint64_t value) {
  _internal_set_target_unit_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitOrder.target_unit_tag)
}

// optional float progress = 4;
inline bool UnitOrder::_internal_has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnitOrder::has_progress() const {
  return _internal_has_progress();
}
inline void UnitOrder::clear_progress() {
  _impl_.progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float UnitOrder::_internal_progress() const {
  return _impl_.progress_;
}
inline float UnitOrder::progress() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitOrder.progress)
  return _internal_progress();
}
inline void UnitOrder::_internal_set_progress(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.progress_ = value;
}
inline void UnitOrder::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitOrder.progress)
}

inline bool UnitOrder::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void UnitOrder::clear_has_target() {
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}
inline UnitOrder::TargetCase UnitOrder::target_case() const {
  return UnitOrder::TargetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PassengerUnit

// optional uint64 tag = 1;
inline bool PassengerUnit::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PassengerUnit::has_tag() const {
  return _internal_has_tag();
}
inline void PassengerUnit::clear_tag() {
  _impl_.tag_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PassengerUnit::_internal_tag() const {
  return _impl_.tag_;
}
inline uint64_t PassengerUnit::tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.tag)
  return _internal_tag();
}
inline void PassengerUnit::_internal_set_tag(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tag_ = value;
}
inline void PassengerUnit::set_tag(uint64_t value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.tag)
}

// optional float health = 2;
inline bool PassengerUnit::_internal_has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PassengerUnit::has_health() const {
  return _internal_has_health();
}
inline void PassengerUnit::clear_health() {
  _impl_.health_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float PassengerUnit::_internal_health() const {
  return _impl_.health_;
}
inline float PassengerUnit::health() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.health)
  return _internal_health();
}
inline void PassengerUnit::_internal_set_health(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.health_ = value;
}
inline void PassengerUnit::set_health(float value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.health)
}

// optional float health_max = 3;
inline bool PassengerUnit::_internal_has_health_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PassengerUnit::has_health_max() const {
  return _internal_has_health_max();
}
inline void PassengerUnit::clear_health_max() {
  _impl_.health_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float PassengerUnit::_internal_health_max() const {
  return _impl_.health_max_;
}
inline float PassengerUnit::health_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.health_max)
  return _internal_health_max();
}
inline void PassengerUnit::_internal_set_health_max(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.health_max_ = value;
}
inline void PassengerUnit::set_health_max(float value) {
  _internal_set_health_max(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.health_max)
}

// optional float shield = 4;
inline bool PassengerUnit::_internal_has_shield() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PassengerUnit::has_shield() const {
  return _internal_has_shield();
}
inline void PassengerUnit::clear_shield() {
  _impl_.shield_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float PassengerUnit::_internal_shield() const {
  return _impl_.shield_;
}
inline float PassengerUnit::shield() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.shield)
  return _internal_shield();
}
inline void PassengerUnit::_internal_set_shield(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.shield_ = value;
}
inline void PassengerUnit::set_shield(float value) {
  _internal_set_shield(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.shield)
}

// optional float shield_max = 7;
inline bool PassengerUnit::_internal_has_shield_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PassengerUnit::has_shield_max() const {
  return _internal_has_shield_max();
}
inline void PassengerUnit::clear_shield_max() {
  _impl_.shield_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float PassengerUnit::_internal_shield_max() const {
  return _impl_.shield_max_;
}
inline float PassengerUnit::shield_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.shield_max)
  return _internal_shield_max();
}
inline void PassengerUnit::_internal_set_shield_max(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.shield_max_ = value;
}
inline void PassengerUnit::set_shield_max(float value) {
  _internal_set_shield_max(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.shield_max)
}

// optional float energy = 5;
inline bool PassengerUnit::_internal_has_energy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PassengerUnit::has_energy() const {
  return _internal_has_energy();
}
inline void PassengerUnit::clear_energy() {
  _impl_.energy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float PassengerUnit::_internal_energy() const {
  return _impl_.energy_;
}
inline float PassengerUnit::energy() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.energy)
  return _internal_energy();
}
inline void PassengerUnit::_internal_set_energy(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.energy_ = value;
}
inline void PassengerUnit::set_energy(float value) {
  _internal_set_energy(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.energy)
}

// optional float energy_max = 8;
inline bool PassengerUnit::_internal_has_energy_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PassengerUnit::has_energy_max() const {
  return _internal_has_energy_max();
}
inline void PassengerUnit::clear_energy_max() {
  _impl_.energy_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float PassengerUnit::_internal_energy_max() const {
  return _impl_.energy_max_;
}
inline float PassengerUnit::energy_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.energy_max)
  return _internal_energy_max();
}
inline void PassengerUnit::_internal_set_energy_max(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.energy_max_ = value;
}
inline void PassengerUnit::set_energy_max(float value) {
  _internal_set_energy_max(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.energy_max)
}

// optional uint32 unit_type = 6;
inline bool PassengerUnit::_internal_has_unit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PassengerUnit::has_unit_type() const {
  return _internal_has_unit_type();
}
inline void PassengerUnit::clear_unit_type() {
  _impl_.unit_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t PassengerUnit::_internal_unit_type() const {
  return _impl_.unit_type_;
}
inline uint32_t PassengerUnit::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.unit_type)
  return _internal_unit_type();
}
inline void PassengerUnit::_internal_set_unit_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.unit_type_ = value;
}
inline void PassengerUnit::set_unit_type(uint32_t value) {
  _internal_set_unit_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.unit_type)
}

// -------------------------------------------------------------------

// RallyTarget

// optional .SC2APIProtocol.Point point = 1;
inline bool RallyTarget::_internal_has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline bool RallyTarget::has_point() const {
  return _internal_has_point();
}
inline const ::SC2APIProtocol::Point& RallyTarget::_internal_point() const {
  const ::SC2APIProtocol::Point* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& RallyTarget::point() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RallyTarget.point)
  return _internal_point();
}
inline void RallyTarget::unsafe_arena_set_allocated_point(
    ::SC2APIProtocol::Point* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.RallyTarget.point)
}
inline ::SC2APIProtocol::Point* RallyTarget::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* RallyTarget::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RallyTarget.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* RallyTarget::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::SC2APIProtocol::Point* RallyTarget::mutable_point() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RallyTarget.point)
  return _msg;
}
inline void RallyTarget::set_allocated_point(::SC2APIProtocol::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point));
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RallyTarget.point)
}

// optional uint64 tag = 2;
inline bool RallyTarget::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RallyTarget::has_tag() const {
  return _internal_has_tag();
}
inline void RallyTarget::clear_tag() {
  _impl_.tag_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RallyTarget::_internal_tag() const {
  return _impl_.tag_;
}
inline uint64_t RallyTarget::tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RallyTarget.tag)
  return _internal_tag();
}
inline void RallyTarget::_internal_set_tag(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tag_ = value;
}
inline void RallyTarget::set_tag(uint64_t value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RallyTarget.tag)
}

// -------------------------------------------------------------------

// Unit

// optional .SC2APIProtocol.DisplayType display_type = 1;
inline bool Unit::_internal_has_display_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool Unit::has_display_type() const {
  return _internal_has_display_type();
}
inline void Unit::clear_display_type() {
  _impl_.display_type_ = 1;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline ::SC2APIProtocol::DisplayType Unit::_internal_display_type() const {
  return static_cast< ::SC2APIProtocol::DisplayType >(_impl_.display_type_);
}
inline ::SC2APIProtocol::DisplayType Unit::display_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.display_type)
  return _internal_display_type();
}
inline void Unit::_internal_set_display_type(::SC2APIProtocol::DisplayType value) {
  assert(::SC2APIProtocol::DisplayType_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.display_type_ = value;
}
inline void Unit::set_display_type(::SC2APIProtocol::DisplayType value) {
  _internal_set_display_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.display_type)
}

// optional .SC2APIProtocol.Alliance alliance = 2;
inline bool Unit::_internal_has_alliance() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool Unit::has_alliance() const {
  return _internal_has_alliance();
}
inline void Unit::clear_alliance() {
  _impl_.alliance_ = 1;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline ::SC2APIProtocol::Alliance Unit::_internal_alliance() const {
  return static_cast< ::SC2APIProtocol::Alliance >(_impl_.alliance_);
}
inline ::SC2APIProtocol::Alliance Unit::alliance() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.alliance)
  return _internal_alliance();
}
inline void Unit::_internal_set_alliance(::SC2APIProtocol::Alliance value) {
  assert(::SC2APIProtocol::Alliance_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.alliance_ = value;
}
inline void Unit::set_alliance(::SC2APIProtocol::Alliance value) {
  _internal_set_alliance(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.alliance)
}

// optional uint64 tag = 3;
inline bool Unit::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Unit::has_tag() const {
  return _internal_has_tag();
}
inline void Unit::clear_tag() {
  _impl_.tag_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Unit::_internal_tag() const {
  return _impl_.tag_;
}
inline uint64_t Unit::tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.tag)
  return _internal_tag();
}
inline void Unit::_internal_set_tag(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tag_ = value;
}
inline void Unit::set_tag(uint64_t value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.tag)
}

// optional uint32 unit_type = 4;
inline bool Unit::_internal_has_unit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Unit::has_unit_type() const {
  return _internal_has_unit_type();
}
inline void Unit::clear_unit_type() {
  _impl_.unit_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Unit::_internal_unit_type() const {
  return _impl_.unit_type_;
}
inline uint32_t Unit::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.unit_type)
  return _internal_unit_type();
}
inline void Unit::_internal_set_unit_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.unit_type_ = value;
}
inline void Unit::set_unit_type(uint32_t value) {
  _internal_set_unit_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.unit_type)
}

// optional int32 owner = 5;
inline bool Unit::_internal_has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Unit::has_owner() const {
  return _internal_has_owner();
}
inline void Unit::clear_owner() {
  _impl_.owner_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Unit::_internal_owner() const {
  return _impl_.owner_;
}
inline int32_t Unit::owner() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.owner)
  return _internal_owner();
}
inline void Unit::_internal_set_owner(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.owner_ = value;
}
inline void Unit::set_owner(int32_t value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.owner)
}

// optional .SC2APIProtocol.Point pos = 6;
inline bool Unit::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline bool Unit::has_pos() const {
  return _internal_has_pos();
}
inline const ::SC2APIProtocol::Point& Unit::_internal_pos() const {
  const ::SC2APIProtocol::Point* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& Unit::pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.pos)
  return _internal_pos();
}
inline void Unit::unsafe_arena_set_allocated_pos(
    ::SC2APIProtocol::Point* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.Unit.pos)
}
inline ::SC2APIProtocol::Point* Unit::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* Unit::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Unit.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* Unit::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::SC2APIProtocol::Point* Unit::mutable_pos() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Unit.pos)
  return _msg;
}
inline void Unit::set_allocated_pos(::SC2APIProtocol::Point* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Unit.pos)
}

// optional float facing = 7;
inline bool Unit::_internal_has_facing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Unit::has_facing() const {
  return _internal_has_facing();
}
inline void Unit::clear_facing() {
  _impl_.facing_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Unit::_internal_facing() const {
  return _impl_.facing_;
}
inline float Unit::facing() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.facing)
  return _internal_facing();
}
inline void Unit::_internal_set_facing(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.facing_ = value;
}
inline void Unit::set_facing(float value) {
  _internal_set_facing(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.facing)
}

// optional float radius = 8;
inline bool Unit::_internal_has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Unit::has_radius() const {
  return _internal_has_radius();
}
inline void Unit::clear_radius() {
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Unit::_internal_radius() const {
  return _impl_.radius_;
}
inline float Unit::radius() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.radius)
  return _internal_radius();
}
inline void Unit::_internal_set_radius(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.radius_ = value;
}
inline void Unit::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.radius)
}

// optional float build_progress = 9;
inline bool Unit::_internal_has_build_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Unit::has_build_progress() const {
  return _internal_has_build_progress();
}
inline void Unit::clear_build_progress() {
  _impl_.build_progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float Unit::_internal_build_progress() const {
  return _impl_.build_progress_;
}
inline float Unit::build_progress() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.build_progress)
  return _internal_build_progress();
}
inline void Unit::_internal_set_build_progress(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.build_progress_ = value;
}
inline void Unit::set_build_progress(float value) {
  _internal_set_build_progress(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.build_progress)
}

// optional .SC2APIProtocol.CloakState cloak = 10;
inline bool Unit::_internal_has_cloak() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Unit::has_cloak() const {
  return _internal_has_cloak();
}
inline void Unit::clear_cloak() {
  _impl_.cloak_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::SC2APIProtocol::CloakState Unit::_internal_cloak() const {
  return static_cast< ::SC2APIProtocol::CloakState >(_impl_.cloak_);
}
inline ::SC2APIProtocol::CloakState Unit::cloak() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.cloak)
  return _internal_cloak();
}
inline void Unit::_internal_set_cloak(::SC2APIProtocol::CloakState value) {
  assert(::SC2APIProtocol::CloakState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.cloak_ = value;
}
inline void Unit::set_cloak(::SC2APIProtocol::CloakState value) {
  _internal_set_cloak(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.cloak)
}

// repeated uint32 buff_ids = 27;
inline int Unit::_internal_buff_ids_size() const {
  return _impl_.buff_ids_.size();
}
inline int Unit::buff_ids_size() const {
  return _internal_buff_ids_size();
}
inline void Unit::clear_buff_ids() {
  _impl_.buff_ids_.Clear();
}
inline uint32_t Unit::_internal_buff_ids(int index) const {
  return _impl_.buff_ids_.Get(index);
}
inline uint32_t Unit::buff_ids(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.buff_ids)
  return _internal_buff_ids(index);
}
inline void Unit::set_buff_ids(int index, uint32_t value) {
  _impl_.buff_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.buff_ids)
}
inline void Unit::_internal_add_buff_ids(uint32_t value) {
  _impl_.buff_ids_.Add(value);
}
inline void Unit::add_buff_ids(uint32_t value) {
  _internal_add_buff_ids(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Unit.buff_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Unit::_internal_buff_ids() const {
  return _impl_.buff_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Unit::buff_ids() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Unit.buff_ids)
  return _internal_buff_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Unit::_internal_mutable_buff_ids() {
  return &_impl_.buff_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Unit::mutable_buff_ids() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Unit.buff_ids)
  return _internal_mutable_buff_ids();
}

// optional float detect_range = 31;
inline bool Unit::_internal_has_detect_range() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool Unit::has_detect_range() const {
  return _internal_has_detect_range();
}
inline void Unit::clear_detect_range() {
  _impl_.detect_range_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline float Unit::_internal_detect_range() const {
  return _impl_.detect_range_;
}
inline float Unit::detect_range() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.detect_range)
  return _internal_detect_range();
}
inline void Unit::_internal_set_detect_range(float value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.detect_range_ = value;
}
inline void Unit::set_detect_range(float value) {
  _internal_set_detect_range(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.detect_range)
}

// optional float radar_range = 32;
inline bool Unit::_internal_has_radar_range() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool Unit::has_radar_range() const {
  return _internal_has_radar_range();
}
inline void Unit::clear_radar_range() {
  _impl_.radar_range_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline float Unit::_internal_radar_range() const {
  return _impl_.radar_range_;
}
inline float Unit::radar_range() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.radar_range)
  return _internal_radar_range();
}
inline void Unit::_internal_set_radar_range(float value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.radar_range_ = value;
}
inline void Unit::set_radar_range(float value) {
  _internal_set_radar_range(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.radar_range)
}

// optional bool is_selected = 11;
inline bool Unit::_internal_has_is_selected() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Unit::has_is_selected() const {
  return _internal_has_is_selected();
}
inline void Unit::clear_is_selected() {
  _impl_.is_selected_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool Unit::_internal_is_selected() const {
  return _impl_.is_selected_;
}
inline bool Unit::is_selected() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_selected)
  return _internal_is_selected();
}
inline void Unit::_internal_set_is_selected(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.is_selected_ = value;
}
inline void Unit::set_is_selected(bool value) {
  _internal_set_is_selected(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_selected)
}

// optional bool is_on_screen = 12;
inline bool Unit::_internal_has_is_on_screen() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Unit::has_is_on_screen() const {
  return _internal_has_is_on_screen();
}
inline void Unit::clear_is_on_screen() {
  _impl_.is_on_screen_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool Unit::_internal_is_on_screen() const {
  return _impl_.is_on_screen_;
}
inline bool Unit::is_on_screen() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_on_screen)
  return _internal_is_on_screen();
}
inline void Unit::_internal_set_is_on_screen(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.is_on_screen_ = value;
}
inline void Unit::set_is_on_screen(bool value) {
  _internal_set_is_on_screen(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_on_screen)
}

// optional bool is_blip = 13;
inline bool Unit::_internal_has_is_blip() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Unit::has_is_blip() const {
  return _internal_has_is_blip();
}
inline void Unit::clear_is_blip() {
  _impl_.is_blip_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool Unit::_internal_is_blip() const {
  return _impl_.is_blip_;
}
inline bool Unit::is_blip() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_blip)
  return _internal_is_blip();
}
inline void Unit::_internal_set_is_blip(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.is_blip_ = value;
}
inline void Unit::set_is_blip(bool value) {
  _internal_set_is_blip(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_blip)
}

// optional bool is_powered = 35;
inline bool Unit::_internal_has_is_powered() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Unit::has_is_powered() const {
  return _internal_has_is_powered();
}
inline void Unit::clear_is_powered() {
  _impl_.is_powered_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool Unit::_internal_is_powered() const {
  return _impl_.is_powered_;
}
inline bool Unit::is_powered() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_powered)
  return _internal_is_powered();
}
inline void Unit::_internal_set_is_powered(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.is_powered_ = value;
}
inline void Unit::set_is_powered(bool value) {
  _internal_set_is_powered(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_powered)
}

// optional bool is_active = 39;
inline bool Unit::_internal_has_is_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Unit::has_is_active() const {
  return _internal_has_is_active();
}
inline void Unit::clear_is_active() {
  _impl_.is_active_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool Unit::_internal_is_active() const {
  return _impl_.is_active_;
}
inline bool Unit::is_active() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_active)
  return _internal_is_active();
}
inline void Unit::_internal_set_is_active(bool value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.is_active_ = value;
}
inline void Unit::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_active)
}

// optional int32 attack_upgrade_level = 40;
inline bool Unit::_internal_has_attack_upgrade_level() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool Unit::has_attack_upgrade_level() const {
  return _internal_has_attack_upgrade_level();
}
inline void Unit::clear_attack_upgrade_level() {
  _impl_.attack_upgrade_level_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline int32_t Unit::_internal_attack_upgrade_level() const {
  return _impl_.attack_upgrade_level_;
}
inline int32_t Unit::attack_upgrade_level() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.attack_upgrade_level)
  return _internal_attack_upgrade_level();
}
inline void Unit::_internal_set_attack_upgrade_level(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.attack_upgrade_level_ = value;
}
inline void Unit::set_attack_upgrade_level(int32_t value) {
  _internal_set_attack_upgrade_level(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.attack_upgrade_level)
}

// optional int32 armor_upgrade_level = 41;
inline bool Unit::_internal_has_armor_upgrade_level() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool Unit::has_armor_upgrade_level() const {
  return _internal_has_armor_upgrade_level();
}
inline void Unit::clear_armor_upgrade_level() {
  _impl_.armor_upgrade_level_ = 0;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline int32_t Unit::_internal_armor_upgrade_level() const {
  return _impl_.armor_upgrade_level_;
}
inline int32_t Unit::armor_upgrade_level() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.armor_upgrade_level)
  return _internal_armor_upgrade_level();
}
inline void Unit::_internal_set_armor_upgrade_level(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.armor_upgrade_level_ = value;
}
inline void Unit::set_armor_upgrade_level(int32_t value) {
  _internal_set_armor_upgrade_level(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.armor_upgrade_level)
}

// optional int32 shield_upgrade_level = 42;
inline bool Unit::_internal_has_shield_upgrade_level() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool Unit::has_shield_upgrade_level() const {
  return _internal_has_shield_upgrade_level();
}
inline void Unit::clear_shield_upgrade_level() {
  _impl_.shield_upgrade_level_ = 0;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline int32_t Unit::_internal_shield_upgrade_level() const {
  return _impl_.shield_upgrade_level_;
}
inline int32_t Unit::shield_upgrade_level() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.shield_upgrade_level)
  return _internal_shield_upgrade_level();
}
inline void Unit::_internal_set_shield_upgrade_level(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.shield_upgrade_level_ = value;
}
inline void Unit::set_shield_upgrade_level(int32_t value) {
  _internal_set_shield_upgrade_level(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.shield_upgrade_level)
}

// optional float health = 14;
inline bool Unit::_internal_has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Unit::has_health() const {
  return _internal_has_health();
}
inline void Unit::clear_health() {
  _impl_.health_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float Unit::_internal_health() const {
  return _impl_.health_;
}
inline float Unit::health() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.health)
  return _internal_health();
}
inline void Unit::_internal_set_health(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.health_ = value;
}
inline void Unit::set_health(float value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.health)
}

// optional float health_max = 15;
inline bool Unit::_internal_has_health_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Unit::has_health_max() const {
  return _internal_has_health_max();
}
inline void Unit::clear_health_max() {
  _impl_.health_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float Unit::_internal_health_max() const {
  return _impl_.health_max_;
}
inline float Unit::health_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.health_max)
  return _internal_health_max();
}
inline void Unit::_internal_set_health_max(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.health_max_ = value;
}
inline void Unit::set_health_max(float value) {
  _internal_set_health_max(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.health_max)
}

// optional float shield = 16;
inline bool Unit::_internal_has_shield() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Unit::has_shield() const {
  return _internal_has_shield();
}
inline void Unit::clear_shield() {
  _impl_.shield_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float Unit::_internal_shield() const {
  return _impl_.shield_;
}
inline float Unit::shield() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.shield)
  return _internal_shield();
}
inline void Unit::_internal_set_shield(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.shield_ = value;
}
inline void Unit::set_shield(float value) {
  _internal_set_shield(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.shield)
}

// optional float shield_max = 36;
inline bool Unit::_internal_has_shield_max() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool Unit::has_shield_max() const {
  return _internal_has_shield_max();
}
inline void Unit::clear_shield_max() {
  _impl_.shield_max_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline float Unit::_internal_shield_max() const {
  return _impl_.shield_max_;
}
inline float Unit::shield_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.shield_max)
  return _internal_shield_max();
}
inline void Unit::_internal_set_shield_max(float value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.shield_max_ = value;
}
inline void Unit::set_shield_max(float value) {
  _internal_set_shield_max(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.shield_max)
}

// optional float energy = 17;
inline bool Unit::_internal_has_energy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Unit::has_energy() const {
  return _internal_has_energy();
}
inline void Unit::clear_energy() {
  _impl_.energy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float Unit::_internal_energy() const {
  return _impl_.energy_;
}
inline float Unit::energy() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.energy)
  return _internal_energy();
}
inline void Unit::_internal_set_energy(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.energy_ = value;
}
inline void Unit::set_energy(float value) {
  _internal_set_energy(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.energy)
}

// optional float energy_max = 37;
inline bool Unit::_internal_has_energy_max() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool Unit::has_energy_max() const {
  return _internal_has_energy_max();
}
inline void Unit::clear_energy_max() {
  _impl_.energy_max_ = 0;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline float Unit::_internal_energy_max() const {
  return _impl_.energy_max_;
}
inline float Unit::energy_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.energy_max)
  return _internal_energy_max();
}
inline void Unit::_internal_set_energy_max(float value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.energy_max_ = value;
}
inline void Unit::set_energy_max(float value) {
  _internal_set_energy_max(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.energy_max)
}

// optional int32 mineral_contents = 18;
inline bool Unit::_internal_has_mineral_contents() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Unit::has_mineral_contents() const {
  return _internal_has_mineral_contents();
}
inline void Unit::clear_mineral_contents() {
  _impl_.mineral_contents_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int32_t Unit::_internal_mineral_contents() const {
  return _impl_.mineral_contents_;
}
inline int32_t Unit::mineral_contents() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.mineral_contents)
  return _internal_mineral_contents();
}
inline void Unit::_internal_set_mineral_contents(int32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.mineral_contents_ = value;
}
inline void Unit::set_mineral_contents(int32_t value) {
  _internal_set_mineral_contents(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.mineral_contents)
}

// optional int32 vespene_contents = 19;
inline bool Unit::_internal_has_vespene_contents() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Unit::has_vespene_contents() const {
  return _internal_has_vespene_contents();
}
inline void Unit::clear_vespene_contents() {
  _impl_.vespene_contents_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline int32_t Unit::_internal_vespene_contents() const {
  return _impl_.vespene_contents_;
}
inline int32_t Unit::vespene_contents() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.vespene_contents)
  return _internal_vespene_contents();
}
inline void Unit::_internal_set_vespene_contents(int32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.vespene_contents_ = value;
}
inline void Unit::set_vespene_contents(int32_t value) {
  _internal_set_vespene_contents(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.vespene_contents)
}

// optional bool is_flying = 20;
inline bool Unit::_internal_has_is_flying() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Unit::has_is_flying() const {
  return _internal_has_is_flying();
}
inline void Unit::clear_is_flying() {
  _impl_.is_flying_ = false;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline bool Unit::_internal_is_flying() const {
  return _impl_.is_flying_;
}
inline bool Unit::is_flying() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_flying)
  return _internal_is_flying();
}
inline void Unit::_internal_set_is_flying(bool value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.is_flying_ = value;
}
inline void Unit::set_is_flying(bool value) {
  _internal_set_is_flying(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_flying)
}

// optional bool is_burrowed = 21;
inline bool Unit::_internal_has_is_burrowed() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Unit::has_is_burrowed() const {
  return _internal_has_is_burrowed();
}
inline void Unit::clear_is_burrowed() {
  _impl_.is_burrowed_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool Unit::_internal_is_burrowed() const {
  return _impl_.is_burrowed_;
}
inline bool Unit::is_burrowed() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_burrowed)
  return _internal_is_burrowed();
}
inline void Unit::_internal_set_is_burrowed(bool value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.is_burrowed_ = value;
}
inline void Unit::set_is_burrowed(bool value) {
  _internal_set_is_burrowed(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_burrowed)
}

// optional bool is_hallucination = 38;
inline bool Unit::_internal_has_is_hallucination() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool Unit::has_is_hallucination() const {
  return _internal_has_is_hallucination();
}
inline void Unit::clear_is_hallucination() {
  _impl_.is_hallucination_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool Unit::_internal_is_hallucination() const {
  return _impl_.is_hallucination_;
}
inline bool Unit::is_hallucination() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_hallucination)
  return _internal_is_hallucination();
}
inline void Unit::_internal_set_is_hallucination(bool value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.is_hallucination_ = value;
}
inline void Unit::set_is_hallucination(bool value) {
  _internal_set_is_hallucination(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_hallucination)
}

// repeated .SC2APIProtocol.UnitOrder orders = 22;
inline int Unit::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int Unit::orders_size() const {
  return _internal_orders_size();
}
inline void Unit::clear_orders() {
  _impl_.orders_.Clear();
}
inline ::SC2APIProtocol::UnitOrder* Unit::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Unit.orders)
  return _impl_.orders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitOrder >*
Unit::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Unit.orders)
  return &_impl_.orders_;
}
inline const ::SC2APIProtocol::UnitOrder& Unit::_internal_orders(int index) const {
  return _impl_.orders_.Get(index);
}
inline const ::SC2APIProtocol::UnitOrder& Unit::orders(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.orders)
  return _internal_orders(index);
}
inline ::SC2APIProtocol::UnitOrder* Unit::_internal_add_orders() {
  return _impl_.orders_.Add();
}
inline ::SC2APIProtocol::UnitOrder* Unit::add_orders() {
  ::SC2APIProtocol::UnitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Unit.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitOrder >&
Unit::orders() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Unit.orders)
  return _impl_.orders_;
}

// optional uint64 add_on_tag = 23;
inline bool Unit::_internal_has_add_on_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Unit::has_add_on_tag() const {
  return _internal_has_add_on_tag();
}
inline void Unit::clear_add_on_tag() {
  _impl_.add_on_tag_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline uint64_t Unit::_internal_add_on_tag() const {
  return _impl_.add_on_tag_;
}
inline uint64_t Unit::add_on_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.add_on_tag)
  return _internal_add_on_tag();
}
inline void Unit::_internal_set_add_on_tag(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.add_on_tag_ = value;
}
inline void Unit::set_add_on_tag(uint64_t value) {
  _internal_set_add_on_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.add_on_tag)
}

// repeated .SC2APIProtocol.PassengerUnit passengers = 24;
inline int Unit::_internal_passengers_size() const {
  return _impl_.passengers_.size();
}
inline int Unit::passengers_size() const {
  return _internal_passengers_size();
}
inline void Unit::clear_passengers() {
  _impl_.passengers_.Clear();
}
inline ::SC2APIProtocol::PassengerUnit* Unit::mutable_passengers(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Unit.passengers)
  return _impl_.passengers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit >*
Unit::mutable_passengers() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Unit.passengers)
  return &_impl_.passengers_;
}
inline const ::SC2APIProtocol::PassengerUnit& Unit::_internal_passengers(int index) const {
  return _impl_.passengers_.Get(index);
}
inline const ::SC2APIProtocol::PassengerUnit& Unit::passengers(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.passengers)
  return _internal_passengers(index);
}
inline ::SC2APIProtocol::PassengerUnit* Unit::_internal_add_passengers() {
  return _impl_.passengers_.Add();
}
inline ::SC2APIProtocol::PassengerUnit* Unit::add_passengers() {
  ::SC2APIProtocol::PassengerUnit* _add = _internal_add_passengers();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Unit.passengers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit >&
Unit::passengers() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Unit.passengers)
  return _impl_.passengers_;
}

// optional int32 cargo_space_taken = 25;
inline bool Unit::_internal_has_cargo_space_taken() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Unit::has_cargo_space_taken() const {
  return _internal_has_cargo_space_taken();
}
inline void Unit::clear_cargo_space_taken() {
  _impl_.cargo_space_taken_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline int32_t Unit::_internal_cargo_space_taken() const {
  return _impl_.cargo_space_taken_;
}
inline int32_t Unit::cargo_space_taken() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.cargo_space_taken)
  return _internal_cargo_space_taken();
}
inline void Unit::_internal_set_cargo_space_taken(int32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.cargo_space_taken_ = value;
}
inline void Unit::set_cargo_space_taken(int32_t value) {
  _internal_set_cargo_space_taken(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.cargo_space_taken)
}

// optional int32 cargo_space_max = 26;
inline bool Unit::_internal_has_cargo_space_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Unit::has_cargo_space_max() const {
  return _internal_has_cargo_space_max();
}
inline void Unit::clear_cargo_space_max() {
  _impl_.cargo_space_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline int32_t Unit::_internal_cargo_space_max() const {
  return _impl_.cargo_space_max_;
}
inline int32_t Unit::cargo_space_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.cargo_space_max)
  return _internal_cargo_space_max();
}
inline void Unit::_internal_set_cargo_space_max(int32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.cargo_space_max_ = value;
}
inline void Unit::set_cargo_space_max(int32_t value) {
  _internal_set_cargo_space_max(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.cargo_space_max)
}

// optional int32 assigned_harvesters = 28;
inline bool Unit::_internal_has_assigned_harvesters() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Unit::has_assigned_harvesters() const {
  return _internal_has_assigned_harvesters();
}
inline void Unit::clear_assigned_harvesters() {
  _impl_.assigned_harvesters_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int32_t Unit::_internal_assigned_harvesters() const {
  return _impl_.assigned_harvesters_;
}
inline int32_t Unit::assigned_harvesters() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.assigned_harvesters)
  return _internal_assigned_harvesters();
}
inline void Unit::_internal_set_assigned_harvesters(int32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.assigned_harvesters_ = value;
}
inline void Unit::set_assigned_harvesters(int32_t value) {
  _internal_set_assigned_harvesters(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.assigned_harvesters)
}

// optional int32 ideal_harvesters = 29;
inline bool Unit::_internal_has_ideal_harvesters() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Unit::has_ideal_harvesters() const {
  return _internal_has_ideal_harvesters();
}
inline void Unit::clear_ideal_harvesters() {
  _impl_.ideal_harvesters_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t Unit::_internal_ideal_harvesters() const {
  return _impl_.ideal_harvesters_;
}
inline int32_t Unit::ideal_harvesters() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.ideal_harvesters)
  return _internal_ideal_harvesters();
}
inline void Unit::_internal_set_ideal_harvesters(int32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.ideal_harvesters_ = value;
}
inline void Unit::set_ideal_harvesters(int32_t value) {
  _internal_set_ideal_harvesters(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.ideal_harvesters)
}

// optional float weapon_cooldown = 30;
inline bool Unit::_internal_has_weapon_cooldown() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool Unit::has_weapon_cooldown() const {
  return _internal_has_weapon_cooldown();
}
inline void Unit::clear_weapon_cooldown() {
  _impl_.weapon_cooldown_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline float Unit::_internal_weapon_cooldown() const {
  return _impl_.weapon_cooldown_;
}
inline float Unit::weapon_cooldown() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.weapon_cooldown)
  return _internal_weapon_cooldown();
}
inline void Unit::_internal_set_weapon_cooldown(float value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.weapon_cooldown_ = value;
}
inline void Unit::set_weapon_cooldown(float value) {
  _internal_set_weapon_cooldown(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.weapon_cooldown)
}

// optional uint64 engaged_target_tag = 34;
inline bool Unit::_internal_has_engaged_target_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool Unit::has_engaged_target_tag() const {
  return _internal_has_engaged_target_tag();
}
inline void Unit::clear_engaged_target_tag() {
  _impl_.engaged_target_tag_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline uint64_t Unit::_internal_engaged_target_tag() const {
  return _impl_.engaged_target_tag_;
}
inline uint64_t Unit::engaged_target_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.engaged_target_tag)
  return _internal_engaged_target_tag();
}
inline void Unit::_internal_set_engaged_target_tag(uint64_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.engaged_target_tag_ = value;
}
inline void Unit::set_engaged_target_tag(uint64_t value) {
  _internal_set_engaged_target_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.engaged_target_tag)
}

// optional int32 buff_duration_remain = 43;
inline bool Unit::_internal_has_buff_duration_remain() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool Unit::has_buff_duration_remain() const {
  return _internal_has_buff_duration_remain();
}
inline void Unit::clear_buff_duration_remain() {
  _impl_.buff_duration_remain_ = 0;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline int32_t Unit::_internal_buff_duration_remain() const {
  return _impl_.buff_duration_remain_;
}
inline int32_t Unit::buff_duration_remain() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.buff_duration_remain)
  return _internal_buff_duration_remain();
}
inline void Unit::_internal_set_buff_duration_remain(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.buff_duration_remain_ = value;
}
inline void Unit::set_buff_duration_remain(int32_t value) {
  _internal_set_buff_duration_remain(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.buff_duration_remain)
}

// optional int32 buff_duration_max = 44;
inline bool Unit::_internal_has_buff_duration_max() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool Unit::has_buff_duration_max() const {
  return _internal_has_buff_duration_max();
}
inline void Unit::clear_buff_duration_max() {
  _impl_.buff_duration_max_ = 0;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline int32_t Unit::_internal_buff_duration_max() const {
  return _impl_.buff_duration_max_;
}
inline int32_t Unit::buff_duration_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.buff_duration_max)
  return _internal_buff_duration_max();
}
inline void Unit::_internal_set_buff_duration_max(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.buff_duration_max_ = value;
}
inline void Unit::set_buff_duration_max(int32_t value) {
  _internal_set_buff_duration_max(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.buff_duration_max)
}

// repeated .SC2APIProtocol.RallyTarget rally_targets = 45;
inline int Unit::_internal_rally_targets_size() const {
  return _impl_.rally_targets_.size();
}
inline int Unit::rally_targets_size() const {
  return _internal_rally_targets_size();
}
inline void Unit::clear_rally_targets() {
  _impl_.rally_targets_.Clear();
}
inline ::SC2APIProtocol::RallyTarget* Unit::mutable_rally_targets(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Unit.rally_targets)
  return _impl_.rally_targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RallyTarget >*
Unit::mutable_rally_targets() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Unit.rally_targets)
  return &_impl_.rally_targets_;
}
inline const ::SC2APIProtocol::RallyTarget& Unit::_internal_rally_targets(int index) const {
  return _impl_.rally_targets_.Get(index);
}
inline const ::SC2APIProtocol::RallyTarget& Unit::rally_targets(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.rally_targets)
  return _internal_rally_targets(index);
}
inline ::SC2APIProtocol::RallyTarget* Unit::_internal_add_rally_targets() {
  return _impl_.rally_targets_.Add();
}
inline ::SC2APIProtocol::RallyTarget* Unit::add_rally_targets() {
  ::SC2APIProtocol::RallyTarget* _add = _internal_add_rally_targets();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Unit.rally_targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RallyTarget >&
Unit::rally_targets() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Unit.rally_targets)
  return _impl_.rally_targets_;
}

// -------------------------------------------------------------------

// MapState

// optional .SC2APIProtocol.ImageData visibility = 1;
inline bool MapState::_internal_has_visibility() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.visibility_ != nullptr);
  return value;
}
inline bool MapState::has_visibility() const {
  return _internal_has_visibility();
}
inline const ::SC2APIProtocol::ImageData& MapState::_internal_visibility() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.visibility_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& MapState::visibility() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.MapState.visibility)
  return _internal_visibility();
}
inline void MapState::unsafe_arena_set_allocated_visibility(
    ::SC2APIProtocol::ImageData* visibility) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  _impl_.visibility_ = visibility;
  if (visibility) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.MapState.visibility)
}
inline ::SC2APIProtocol::ImageData* MapState::release_visibility() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* MapState::unsafe_arena_release_visibility() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.MapState.visibility)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = _impl_.visibility_;
  _impl_.visibility_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* MapState::_internal_mutable_visibility() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.visibility_ = p;
  }
  return _impl_.visibility_;
}
inline ::SC2APIProtocol::ImageData* MapState::mutable_visibility() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_visibility();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.MapState.visibility)
  return _msg;
}
inline void MapState::set_allocated_visibility(::SC2APIProtocol::ImageData* visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visibility_);
  }
  if (visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visibility));
    if (message_arena != submessage_arena) {
      visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.visibility_ = visibility;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.MapState.visibility)
}

// optional .SC2APIProtocol.ImageData creep = 2;
inline bool MapState::_internal_has_creep() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creep_ != nullptr);
  return value;
}
inline bool MapState::has_creep() const {
  return _internal_has_creep();
}
inline const ::SC2APIProtocol::ImageData& MapState::_internal_creep() const {
  const ::SC2APIProtocol::ImageData* p = _impl_.creep_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::ImageData&>(
      ::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& MapState::creep() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.MapState.creep)
  return _internal_creep();
}
inline void MapState::unsafe_arena_set_allocated_creep(
    ::SC2APIProtocol::ImageData* creep) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creep_);
  }
  _impl_.creep_ = creep;
  if (creep) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.MapState.creep)
}
inline ::SC2APIProtocol::ImageData* MapState::release_creep() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.creep_;
  _impl_.creep_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::ImageData* MapState::unsafe_arena_release_creep() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.MapState.creep)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = _impl_.creep_;
  _impl_.creep_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* MapState::_internal_mutable_creep() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.creep_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaForAllocation());
    _impl_.creep_ = p;
  }
  return _impl_.creep_;
}
inline ::SC2APIProtocol::ImageData* MapState::mutable_creep() {
  ::SC2APIProtocol::ImageData* _msg = _internal_mutable_creep();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.MapState.creep)
  return _msg;
}
inline void MapState::set_allocated_creep(::SC2APIProtocol::ImageData* creep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creep_);
  }
  if (creep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creep));
    if (message_arena != submessage_arena) {
      creep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.MapState.creep)
}

// -------------------------------------------------------------------

// Event

// repeated uint64 dead_units = 1;
inline int Event::_internal_dead_units_size() const {
  return _impl_.dead_units_.size();
}
inline int Event::dead_units_size() const {
  return _internal_dead_units_size();
}
inline void Event::clear_dead_units() {
  _impl_.dead_units_.Clear();
}
inline uint64_t Event::_internal_dead_units(int index) const {
  return _impl_.dead_units_.Get(index);
}
inline uint64_t Event::dead_units(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Event.dead_units)
  return _internal_dead_units(index);
}
inline void Event::set_dead_units(int index, uint64_t value) {
  _impl_.dead_units_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Event.dead_units)
}
inline void Event::_internal_add_dead_units(uint64_t value) {
  _impl_.dead_units_.Add(value);
}
inline void Event::add_dead_units(uint64_t value) {
  _internal_add_dead_units(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Event.dead_units)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Event::_internal_dead_units() const {
  return _impl_.dead_units_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Event::dead_units() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Event.dead_units)
  return _internal_dead_units();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Event::_internal_mutable_dead_units() {
  return &_impl_.dead_units_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Event::mutable_dead_units() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Event.dead_units)
  return _internal_mutable_dead_units();
}

// -------------------------------------------------------------------

// Effect

// optional uint32 effect_id = 1;
inline bool Effect::_internal_has_effect_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Effect::has_effect_id() const {
  return _internal_has_effect_id();
}
inline void Effect::clear_effect_id() {
  _impl_.effect_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Effect::_internal_effect_id() const {
  return _impl_.effect_id_;
}
inline uint32_t Effect::effect_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Effect.effect_id)
  return _internal_effect_id();
}
inline void Effect::_internal_set_effect_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.effect_id_ = value;
}
inline void Effect::set_effect_id(uint32_t value) {
  _internal_set_effect_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Effect.effect_id)
}

// repeated .SC2APIProtocol.Point2D pos = 2;
inline int Effect::_internal_pos_size() const {
  return _impl_.pos_.size();
}
inline int Effect::pos_size() const {
  return _internal_pos_size();
}
inline ::SC2APIProtocol::Point2D* Effect::mutable_pos(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Effect.pos)
  return _impl_.pos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D >*
Effect::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Effect.pos)
  return &_impl_.pos_;
}
inline const ::SC2APIProtocol::Point2D& Effect::_internal_pos(int index) const {
  return _impl_.pos_.Get(index);
}
inline const ::SC2APIProtocol::Point2D& Effect::pos(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Effect.pos)
  return _internal_pos(index);
}
inline ::SC2APIProtocol::Point2D* Effect::_internal_add_pos() {
  return _impl_.pos_.Add();
}
inline ::SC2APIProtocol::Point2D* Effect::add_pos() {
  ::SC2APIProtocol::Point2D* _add = _internal_add_pos();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Effect.pos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Point2D >&
Effect::pos() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Effect.pos)
  return _impl_.pos_;
}

// optional .SC2APIProtocol.Alliance alliance = 3;
inline bool Effect::_internal_has_alliance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Effect::has_alliance() const {
  return _internal_has_alliance();
}
inline void Effect::clear_alliance() {
  _impl_.alliance_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SC2APIProtocol::Alliance Effect::_internal_alliance() const {
  return static_cast< ::SC2APIProtocol::Alliance >(_impl_.alliance_);
}
inline ::SC2APIProtocol::Alliance Effect::alliance() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Effect.alliance)
  return _internal_alliance();
}
inline void Effect::_internal_set_alliance(::SC2APIProtocol::Alliance value) {
  assert(::SC2APIProtocol::Alliance_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.alliance_ = value;
}
inline void Effect::set_alliance(::SC2APIProtocol::Alliance value) {
  _internal_set_alliance(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Effect.alliance)
}

// optional int32 owner = 4;
inline bool Effect::_internal_has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Effect::has_owner() const {
  return _internal_has_owner();
}
inline void Effect::clear_owner() {
  _impl_.owner_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Effect::_internal_owner() const {
  return _impl_.owner_;
}
inline int32_t Effect::owner() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Effect.owner)
  return _internal_owner();
}
inline void Effect::_internal_set_owner(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.owner_ = value;
}
inline void Effect::set_owner(int32_t value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Effect.owner)
}

// optional float radius = 5;
inline bool Effect::_internal_has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Effect::has_radius() const {
  return _internal_has_radius();
}
inline void Effect::clear_radius() {
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Effect::_internal_radius() const {
  return _impl_.radius_;
}
inline float Effect::radius() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Effect.radius)
  return _internal_radius();
}
inline void Effect::_internal_set_radius(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.radius_ = value;
}
inline void Effect::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Effect.radius)
}

// -------------------------------------------------------------------

// ActionRaw

// .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;
inline bool ActionRaw::_internal_has_unit_command() const {
  return action_case() == kUnitCommand;
}
inline bool ActionRaw::has_unit_command() const {
  return _internal_has_unit_command();
}
inline void ActionRaw::set_has_unit_command() {
  _impl_._oneof_case_[0] = kUnitCommand;
}
inline void ActionRaw::clear_unit_command() {
  if (_internal_has_unit_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.unit_command_;
    }
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionRawUnitCommand* ActionRaw::release_unit_command() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRaw.unit_command)
  if (_internal_has_unit_command()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawUnitCommand* temp = _impl_.action_.unit_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.unit_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionRawUnitCommand& ActionRaw::_internal_unit_command() const {
  return _internal_has_unit_command()
      ? *_impl_.action_.unit_command_
      : reinterpret_cast< ::SC2APIProtocol::ActionRawUnitCommand&>(::SC2APIProtocol::_ActionRawUnitCommand_default_instance_);
}
inline const ::SC2APIProtocol::ActionRawUnitCommand& ActionRaw::unit_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRaw.unit_command)
  return _internal_unit_command();
}
inline ::SC2APIProtocol::ActionRawUnitCommand* ActionRaw::unsafe_arena_release_unit_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionRaw.unit_command)
  if (_internal_has_unit_command()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawUnitCommand* temp = _impl_.action_.unit_command_;
    _impl_.action_.unit_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRaw::unsafe_arena_set_allocated_unit_command(::SC2APIProtocol::ActionRawUnitCommand* unit_command) {
  clear_action();
  if (unit_command) {
    set_has_unit_command();
    _impl_.action_.unit_command_ = unit_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionRaw.unit_command)
}
inline ::SC2APIProtocol::ActionRawUnitCommand* ActionRaw::_internal_mutable_unit_command() {
  if (!_internal_has_unit_command()) {
    clear_action();
    set_has_unit_command();
    _impl_.action_.unit_command_ = CreateMaybeMessage< ::SC2APIProtocol::ActionRawUnitCommand >(GetArenaForAllocation());
  }
  return _impl_.action_.unit_command_;
}
inline ::SC2APIProtocol::ActionRawUnitCommand* ActionRaw::mutable_unit_command() {
  ::SC2APIProtocol::ActionRawUnitCommand* _msg = _internal_mutable_unit_command();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRaw.unit_command)
  return _msg;
}

// .SC2APIProtocol.ActionRawCameraMove camera_move = 2;
inline bool ActionRaw::_internal_has_camera_move() const {
  return action_case() == kCameraMove;
}
inline bool ActionRaw::has_camera_move() const {
  return _internal_has_camera_move();
}
inline void ActionRaw::set_has_camera_move() {
  _impl_._oneof_case_[0] = kCameraMove;
}
inline void ActionRaw::clear_camera_move() {
  if (_internal_has_camera_move()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.camera_move_;
    }
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionRawCameraMove* ActionRaw::release_camera_move() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRaw.camera_move)
  if (_internal_has_camera_move()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawCameraMove* temp = _impl_.action_.camera_move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.camera_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionRawCameraMove& ActionRaw::_internal_camera_move() const {
  return _internal_has_camera_move()
      ? *_impl_.action_.camera_move_
      : reinterpret_cast< ::SC2APIProtocol::ActionRawCameraMove&>(::SC2APIProtocol::_ActionRawCameraMove_default_instance_);
}
inline const ::SC2APIProtocol::ActionRawCameraMove& ActionRaw::camera_move() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRaw.camera_move)
  return _internal_camera_move();
}
inline ::SC2APIProtocol::ActionRawCameraMove* ActionRaw::unsafe_arena_release_camera_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionRaw.camera_move)
  if (_internal_has_camera_move()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawCameraMove* temp = _impl_.action_.camera_move_;
    _impl_.action_.camera_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRaw::unsafe_arena_set_allocated_camera_move(::SC2APIProtocol::ActionRawCameraMove* camera_move) {
  clear_action();
  if (camera_move) {
    set_has_camera_move();
    _impl_.action_.camera_move_ = camera_move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionRaw.camera_move)
}
inline ::SC2APIProtocol::ActionRawCameraMove* ActionRaw::_internal_mutable_camera_move() {
  if (!_internal_has_camera_move()) {
    clear_action();
    set_has_camera_move();
    _impl_.action_.camera_move_ = CreateMaybeMessage< ::SC2APIProtocol::ActionRawCameraMove >(GetArenaForAllocation());
  }
  return _impl_.action_.camera_move_;
}
inline ::SC2APIProtocol::ActionRawCameraMove* ActionRaw::mutable_camera_move() {
  ::SC2APIProtocol::ActionRawCameraMove* _msg = _internal_mutable_camera_move();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRaw.camera_move)
  return _msg;
}

// .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
inline bool ActionRaw::_internal_has_toggle_autocast() const {
  return action_case() == kToggleAutocast;
}
inline bool ActionRaw::has_toggle_autocast() const {
  return _internal_has_toggle_autocast();
}
inline void ActionRaw::set_has_toggle_autocast() {
  _impl_._oneof_case_[0] = kToggleAutocast;
}
inline void ActionRaw::clear_toggle_autocast() {
  if (_internal_has_toggle_autocast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.toggle_autocast_;
    }
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionRawToggleAutocast* ActionRaw::release_toggle_autocast() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRaw.toggle_autocast)
  if (_internal_has_toggle_autocast()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawToggleAutocast* temp = _impl_.action_.toggle_autocast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.toggle_autocast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionRawToggleAutocast& ActionRaw::_internal_toggle_autocast() const {
  return _internal_has_toggle_autocast()
      ? *_impl_.action_.toggle_autocast_
      : reinterpret_cast< ::SC2APIProtocol::ActionRawToggleAutocast&>(::SC2APIProtocol::_ActionRawToggleAutocast_default_instance_);
}
inline const ::SC2APIProtocol::ActionRawToggleAutocast& ActionRaw::toggle_autocast() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRaw.toggle_autocast)
  return _internal_toggle_autocast();
}
inline ::SC2APIProtocol::ActionRawToggleAutocast* ActionRaw::unsafe_arena_release_toggle_autocast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionRaw.toggle_autocast)
  if (_internal_has_toggle_autocast()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawToggleAutocast* temp = _impl_.action_.toggle_autocast_;
    _impl_.action_.toggle_autocast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRaw::unsafe_arena_set_allocated_toggle_autocast(::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast) {
  clear_action();
  if (toggle_autocast) {
    set_has_toggle_autocast();
    _impl_.action_.toggle_autocast_ = toggle_autocast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionRaw.toggle_autocast)
}
inline ::SC2APIProtocol::ActionRawToggleAutocast* ActionRaw::_internal_mutable_toggle_autocast() {
  if (!_internal_has_toggle_autocast()) {
    clear_action();
    set_has_toggle_autocast();
    _impl_.action_.toggle_autocast_ = CreateMaybeMessage< ::SC2APIProtocol::ActionRawToggleAutocast >(GetArenaForAllocation());
  }
  return _impl_.action_.toggle_autocast_;
}
inline ::SC2APIProtocol::ActionRawToggleAutocast* ActionRaw::mutable_toggle_autocast() {
  ::SC2APIProtocol::ActionRawToggleAutocast* _msg = _internal_mutable_toggle_autocast();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRaw.toggle_autocast)
  return _msg;
}

inline bool ActionRaw::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionRaw::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionRaw::ActionCase ActionRaw::action_case() const {
  return ActionRaw::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionRawUnitCommand

// optional int32 ability_id = 1;
inline bool ActionRawUnitCommand::_internal_has_ability_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionRawUnitCommand::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void ActionRawUnitCommand::clear_ability_id() {
  _impl_.ability_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ActionRawUnitCommand::_internal_ability_id() const {
  return _impl_.ability_id_;
}
inline int32_t ActionRawUnitCommand::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.ability_id)
  return _internal_ability_id();
}
inline void ActionRawUnitCommand::_internal_set_ability_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ability_id_ = value;
}
inline void ActionRawUnitCommand::set_ability_id(int32_t value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawUnitCommand.ability_id)
}

// .SC2APIProtocol.Point2D target_world_space_pos = 2;
inline bool ActionRawUnitCommand::_internal_has_target_world_space_pos() const {
  return target_case() == kTargetWorldSpacePos;
}
inline bool ActionRawUnitCommand::has_target_world_space_pos() const {
  return _internal_has_target_world_space_pos();
}
inline void ActionRawUnitCommand::set_has_target_world_space_pos() {
  _impl_._oneof_case_[0] = kTargetWorldSpacePos;
}
inline ::SC2APIProtocol::Point2D* ActionRawUnitCommand::release_target_world_space_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
  if (_internal_has_target_world_space_pos()) {
    clear_has_target();
    ::SC2APIProtocol::Point2D* temp = _impl_.target_.target_world_space_pos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_.target_world_space_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::Point2D& ActionRawUnitCommand::_internal_target_world_space_pos() const {
  return _internal_has_target_world_space_pos()
      ? *_impl_.target_.target_world_space_pos_
      : reinterpret_cast< ::SC2APIProtocol::Point2D&>(::SC2APIProtocol::_Point2D_default_instance_);
}
inline const ::SC2APIProtocol::Point2D& ActionRawUnitCommand::target_world_space_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
  return _internal_target_world_space_pos();
}
inline ::SC2APIProtocol::Point2D* ActionRawUnitCommand::unsafe_arena_release_target_world_space_pos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
  if (_internal_has_target_world_space_pos()) {
    clear_has_target();
    ::SC2APIProtocol::Point2D* temp = _impl_.target_.target_world_space_pos_;
    _impl_.target_.target_world_space_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionRawUnitCommand::unsafe_arena_set_allocated_target_world_space_pos(::SC2APIProtocol::Point2D* target_world_space_pos) {
  clear_target();
  if (target_world_space_pos) {
    set_has_target_world_space_pos();
    _impl_.target_.target_world_space_pos_ = target_world_space_pos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
}
inline ::SC2APIProtocol::Point2D* ActionRawUnitCommand::_internal_mutable_target_world_space_pos() {
  if (!_internal_has_target_world_space_pos()) {
    clear_target();
    set_has_target_world_space_pos();
    _impl_.target_.target_world_space_pos_ = CreateMaybeMessage< ::SC2APIProtocol::Point2D >(GetArenaForAllocation());
  }
  return _impl_.target_.target_world_space_pos_;
}
inline ::SC2APIProtocol::Point2D* ActionRawUnitCommand::mutable_target_world_space_pos() {
  ::SC2APIProtocol::Point2D* _msg = _internal_mutable_target_world_space_pos();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
  return _msg;
}

// uint64 target_unit_tag = 3;
inline bool ActionRawUnitCommand::_internal_has_target_unit_tag() const {
  return target_case() == kTargetUnitTag;
}
inline bool ActionRawUnitCommand::has_target_unit_tag() const {
  return _internal_has_target_unit_tag();
}
inline void ActionRawUnitCommand::set_has_target_unit_tag() {
  _impl_._oneof_case_[0] = kTargetUnitTag;
}
inline void ActionRawUnitCommand::clear_target_unit_tag() {
  if (_internal_has_target_unit_tag()) {
    _impl_.target_.target_unit_tag_ = uint64_t{0u};
    clear_has_target();
  }
}
inline uint64_t ActionRawUnitCommand::_internal_target_unit_tag() const {
  if (_internal_has_target_unit_tag()) {
    return _impl_.target_.target_unit_tag_;
  }
  return uint64_t{0u};
}
inline void ActionRawUnitCommand::_internal_set_target_unit_tag(uint64_t value) {
  if (!_internal_has_target_unit_tag()) {
    clear_target();
    set_has_target_unit_tag();
  }
  _impl_.target_.target_unit_tag_ = value;
}
inline uint64_t ActionRawUnitCommand::target_unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.target_unit_tag)
  return _internal_target_unit_tag();
}
inline void ActionRawUnitCommand::set_target_unit_tag(uint64_t value) {
  _internal_set_target_unit_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawUnitCommand.target_unit_tag)
}

// repeated uint64 unit_tags = 4;
inline int ActionRawUnitCommand::_internal_unit_tags_size() const {
  return _impl_.unit_tags_.size();
}
inline int ActionRawUnitCommand::unit_tags_size() const {
  return _internal_unit_tags_size();
}
inline void ActionRawUnitCommand::clear_unit_tags() {
  _impl_.unit_tags_.Clear();
}
inline uint64_t ActionRawUnitCommand::_internal_unit_tags(int index) const {
  return _impl_.unit_tags_.Get(index);
}
inline uint64_t ActionRawUnitCommand::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
  return _internal_unit_tags(index);
}
inline void ActionRawUnitCommand::set_unit_tags(int index, uint64_t value) {
  _impl_.unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
}
inline void ActionRawUnitCommand::_internal_add_unit_tags(uint64_t value) {
  _impl_.unit_tags_.Add(value);
}
inline void ActionRawUnitCommand::add_unit_tags(uint64_t value) {
  _internal_add_unit_tags(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ActionRawUnitCommand::_internal_unit_tags() const {
  return _impl_.unit_tags_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ActionRawUnitCommand::unit_tags() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
  return _internal_unit_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ActionRawUnitCommand::_internal_mutable_unit_tags() {
  return &_impl_.unit_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ActionRawUnitCommand::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
  return _internal_mutable_unit_tags();
}

// optional bool queue_command = 5;
inline bool ActionRawUnitCommand::_internal_has_queue_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionRawUnitCommand::has_queue_command() const {
  return _internal_has_queue_command();
}
inline void ActionRawUnitCommand::clear_queue_command() {
  _impl_.queue_command_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ActionRawUnitCommand::_internal_queue_command() const {
  return _impl_.queue_command_;
}
inline bool ActionRawUnitCommand::queue_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.queue_command)
  return _internal_queue_command();
}
inline void ActionRawUnitCommand::_internal_set_queue_command(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.queue_command_ = value;
}
inline void ActionRawUnitCommand::set_queue_command(bool value) {
  _internal_set_queue_command(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawUnitCommand.queue_command)
}

inline bool ActionRawUnitCommand::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ActionRawUnitCommand::clear_has_target() {
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}
inline ActionRawUnitCommand::TargetCase ActionRawUnitCommand::target_case() const {
  return ActionRawUnitCommand::TargetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionRawCameraMove

// optional .SC2APIProtocol.Point center_world_space = 1;
inline bool ActionRawCameraMove::_internal_has_center_world_space() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_world_space_ != nullptr);
  return value;
}
inline bool ActionRawCameraMove::has_center_world_space() const {
  return _internal_has_center_world_space();
}
inline const ::SC2APIProtocol::Point& ActionRawCameraMove::_internal_center_world_space() const {
  const ::SC2APIProtocol::Point* p = _impl_.center_world_space_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& ActionRawCameraMove::center_world_space() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawCameraMove.center_world_space)
  return _internal_center_world_space();
}
inline void ActionRawCameraMove::unsafe_arena_set_allocated_center_world_space(
    ::SC2APIProtocol::Point* center_world_space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_world_space_);
  }
  _impl_.center_world_space_ = center_world_space;
  if (center_world_space) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.ActionRawCameraMove.center_world_space)
}
inline ::SC2APIProtocol::Point* ActionRawCameraMove::release_center_world_space() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.center_world_space_;
  _impl_.center_world_space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* ActionRawCameraMove::unsafe_arena_release_center_world_space() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRawCameraMove.center_world_space)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.center_world_space_;
  _impl_.center_world_space_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* ActionRawCameraMove::_internal_mutable_center_world_space() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_world_space_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.center_world_space_ = p;
  }
  return _impl_.center_world_space_;
}
inline ::SC2APIProtocol::Point* ActionRawCameraMove::mutable_center_world_space() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_center_world_space();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRawCameraMove.center_world_space)
  return _msg;
}
inline void ActionRawCameraMove::set_allocated_center_world_space(::SC2APIProtocol::Point* center_world_space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_world_space_);
  }
  if (center_world_space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_world_space));
    if (message_arena != submessage_arena) {
      center_world_space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_world_space, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.center_world_space_ = center_world_space;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRawCameraMove.center_world_space)
}

// -------------------------------------------------------------------

// ActionRawToggleAutocast

// optional int32 ability_id = 1;
inline bool ActionRawToggleAutocast::_internal_has_ability_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionRawToggleAutocast::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void ActionRawToggleAutocast::clear_ability_id() {
  _impl_.ability_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ActionRawToggleAutocast::_internal_ability_id() const {
  return _impl_.ability_id_;
}
inline int32_t ActionRawToggleAutocast::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawToggleAutocast.ability_id)
  return _internal_ability_id();
}
inline void ActionRawToggleAutocast::_internal_set_ability_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ability_id_ = value;
}
inline void ActionRawToggleAutocast::set_ability_id(int32_t value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawToggleAutocast.ability_id)
}

// repeated uint64 unit_tags = 2;
inline int ActionRawToggleAutocast::_internal_unit_tags_size() const {
  return _impl_.unit_tags_.size();
}
inline int ActionRawToggleAutocast::unit_tags_size() const {
  return _internal_unit_tags_size();
}
inline void ActionRawToggleAutocast::clear_unit_tags() {
  _impl_.unit_tags_.Clear();
}
inline uint64_t ActionRawToggleAutocast::_internal_unit_tags(int index) const {
  return _impl_.unit_tags_.Get(index);
}
inline uint64_t ActionRawToggleAutocast::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
  return _internal_unit_tags(index);
}
inline void ActionRawToggleAutocast::set_unit_tags(int index, uint64_t value) {
  _impl_.unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
}
inline void ActionRawToggleAutocast::_internal_add_unit_tags(uint64_t value) {
  _impl_.unit_tags_.Add(value);
}
inline void ActionRawToggleAutocast::add_unit_tags(uint64_t value) {
  _internal_add_unit_tags(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ActionRawToggleAutocast::_internal_unit_tags() const {
  return _impl_.unit_tags_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ActionRawToggleAutocast::unit_tags() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
  return _internal_unit_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ActionRawToggleAutocast::_internal_mutable_unit_tags() {
  return &_impl_.unit_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ActionRawToggleAutocast::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
  return _internal_mutable_unit_tags();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SC2APIProtocol::DisplayType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DisplayType>() {
  return ::SC2APIProtocol::DisplayType_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Alliance> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Alliance>() {
  return ::SC2APIProtocol::Alliance_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::CloakState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::CloakState>() {
  return ::SC2APIProtocol::CloakState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fraw_2eproto
