// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/debug.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdebug_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdebug_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fdebug_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_s2clientprotocol_2fdebug_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fdebug_2eproto;
namespace SC2APIProtocol {
class Color;
struct ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class DebugBox;
struct DebugBoxDefaultTypeInternal;
extern DebugBoxDefaultTypeInternal _DebugBox_default_instance_;
class DebugCommand;
struct DebugCommandDefaultTypeInternal;
extern DebugCommandDefaultTypeInternal _DebugCommand_default_instance_;
class DebugCreateUnit;
struct DebugCreateUnitDefaultTypeInternal;
extern DebugCreateUnitDefaultTypeInternal _DebugCreateUnit_default_instance_;
class DebugDraw;
struct DebugDrawDefaultTypeInternal;
extern DebugDrawDefaultTypeInternal _DebugDraw_default_instance_;
class DebugEndGame;
struct DebugEndGameDefaultTypeInternal;
extern DebugEndGameDefaultTypeInternal _DebugEndGame_default_instance_;
class DebugKillUnit;
struct DebugKillUnitDefaultTypeInternal;
extern DebugKillUnitDefaultTypeInternal _DebugKillUnit_default_instance_;
class DebugLine;
struct DebugLineDefaultTypeInternal;
extern DebugLineDefaultTypeInternal _DebugLine_default_instance_;
class DebugSetScore;
struct DebugSetScoreDefaultTypeInternal;
extern DebugSetScoreDefaultTypeInternal _DebugSetScore_default_instance_;
class DebugSetUnitValue;
struct DebugSetUnitValueDefaultTypeInternal;
extern DebugSetUnitValueDefaultTypeInternal _DebugSetUnitValue_default_instance_;
class DebugSphere;
struct DebugSphereDefaultTypeInternal;
extern DebugSphereDefaultTypeInternal _DebugSphere_default_instance_;
class DebugTestProcess;
struct DebugTestProcessDefaultTypeInternal;
extern DebugTestProcessDefaultTypeInternal _DebugTestProcess_default_instance_;
class DebugText;
struct DebugTextDefaultTypeInternal;
extern DebugTextDefaultTypeInternal _DebugText_default_instance_;
class Line;
struct LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> ::SC2APIProtocol::Color* Arena::CreateMaybeMessage<::SC2APIProtocol::Color>(Arena*);
template<> ::SC2APIProtocol::DebugBox* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugBox>(Arena*);
template<> ::SC2APIProtocol::DebugCommand* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugCommand>(Arena*);
template<> ::SC2APIProtocol::DebugCreateUnit* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugCreateUnit>(Arena*);
template<> ::SC2APIProtocol::DebugDraw* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugDraw>(Arena*);
template<> ::SC2APIProtocol::DebugEndGame* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugEndGame>(Arena*);
template<> ::SC2APIProtocol::DebugKillUnit* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugKillUnit>(Arena*);
template<> ::SC2APIProtocol::DebugLine* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugLine>(Arena*);
template<> ::SC2APIProtocol::DebugSetScore* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugSetScore>(Arena*);
template<> ::SC2APIProtocol::DebugSetUnitValue* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugSetUnitValue>(Arena*);
template<> ::SC2APIProtocol::DebugSphere* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugSphere>(Arena*);
template<> ::SC2APIProtocol::DebugTestProcess* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugTestProcess>(Arena*);
template<> ::SC2APIProtocol::DebugText* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugText>(Arena*);
template<> ::SC2APIProtocol::Line* Arena::CreateMaybeMessage<::SC2APIProtocol::Line>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SC2APIProtocol {

enum DebugTestProcess_Test : int {
  DebugTestProcess_Test_hang = 1,
  DebugTestProcess_Test_crash = 2,
  DebugTestProcess_Test_exit = 3
};
bool DebugTestProcess_Test_IsValid(int value);
constexpr DebugTestProcess_Test DebugTestProcess_Test_Test_MIN = DebugTestProcess_Test_hang;
constexpr DebugTestProcess_Test DebugTestProcess_Test_Test_MAX = DebugTestProcess_Test_exit;
constexpr int DebugTestProcess_Test_Test_ARRAYSIZE = DebugTestProcess_Test_Test_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugTestProcess_Test_descriptor();
template<typename T>
inline const std::string& DebugTestProcess_Test_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugTestProcess_Test>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugTestProcess_Test_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugTestProcess_Test_descriptor(), enum_t_value);
}
inline bool DebugTestProcess_Test_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DebugTestProcess_Test* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugTestProcess_Test>(
    DebugTestProcess_Test_descriptor(), name, value);
}
enum DebugEndGame_EndResult : int {
  DebugEndGame_EndResult_Surrender = 1,
  DebugEndGame_EndResult_DeclareVictory = 2
};
bool DebugEndGame_EndResult_IsValid(int value);
constexpr DebugEndGame_EndResult DebugEndGame_EndResult_EndResult_MIN = DebugEndGame_EndResult_Surrender;
constexpr DebugEndGame_EndResult DebugEndGame_EndResult_EndResult_MAX = DebugEndGame_EndResult_DeclareVictory;
constexpr int DebugEndGame_EndResult_EndResult_ARRAYSIZE = DebugEndGame_EndResult_EndResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugEndGame_EndResult_descriptor();
template<typename T>
inline const std::string& DebugEndGame_EndResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugEndGame_EndResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugEndGame_EndResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugEndGame_EndResult_descriptor(), enum_t_value);
}
inline bool DebugEndGame_EndResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DebugEndGame_EndResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugEndGame_EndResult>(
    DebugEndGame_EndResult_descriptor(), name, value);
}
enum DebugSetUnitValue_UnitValue : int {
  DebugSetUnitValue_UnitValue_Energy = 1,
  DebugSetUnitValue_UnitValue_Life = 2,
  DebugSetUnitValue_UnitValue_Shields = 3
};
bool DebugSetUnitValue_UnitValue_IsValid(int value);
constexpr DebugSetUnitValue_UnitValue DebugSetUnitValue_UnitValue_UnitValue_MIN = DebugSetUnitValue_UnitValue_Energy;
constexpr DebugSetUnitValue_UnitValue DebugSetUnitValue_UnitValue_UnitValue_MAX = DebugSetUnitValue_UnitValue_Shields;
constexpr int DebugSetUnitValue_UnitValue_UnitValue_ARRAYSIZE = DebugSetUnitValue_UnitValue_UnitValue_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugSetUnitValue_UnitValue_descriptor();
template<typename T>
inline const std::string& DebugSetUnitValue_UnitValue_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugSetUnitValue_UnitValue>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugSetUnitValue_UnitValue_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugSetUnitValue_UnitValue_descriptor(), enum_t_value);
}
inline bool DebugSetUnitValue_UnitValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DebugSetUnitValue_UnitValue* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugSetUnitValue_UnitValue>(
    DebugSetUnitValue_UnitValue_descriptor(), name, value);
}
enum DebugGameState : int {
  show_map = 1,
  control_enemy = 2,
  food = 3,
  free = 4,
  all_resources = 5,
  god = 6,
  minerals = 7,
  gas = 8,
  cooldown = 9,
  tech_tree = 10,
  upgrade = 11,
  fast_build = 12
};
bool DebugGameState_IsValid(int value);
constexpr DebugGameState DebugGameState_MIN = show_map;
constexpr DebugGameState DebugGameState_MAX = fast_build;
constexpr int DebugGameState_ARRAYSIZE = DebugGameState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugGameState_descriptor();
template<typename T>
inline const std::string& DebugGameState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugGameState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugGameState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugGameState_descriptor(), enum_t_value);
}
inline bool DebugGameState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DebugGameState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugGameState>(
    DebugGameState_descriptor(), name, value);
}
// ===================================================================

class DebugCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugCommand) */ {
 public:
  inline DebugCommand() : DebugCommand(nullptr) {}
  ~DebugCommand() override;
  explicit PROTOBUF_CONSTEXPR DebugCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugCommand(const DebugCommand& from);
  DebugCommand(DebugCommand&& from) noexcept
    : DebugCommand() {
    *this = ::std::move(from);
  }

  inline DebugCommand& operator=(const DebugCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugCommand& operator=(DebugCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kDraw = 1,
    kGameState = 2,
    kCreateUnit = 3,
    kKillUnit = 4,
    kTestProcess = 5,
    kScore = 6,
    kEndGame = 7,
    kUnitValue = 8,
    COMMAND_NOT_SET = 0,
  };

  static inline const DebugCommand* internal_default_instance() {
    return reinterpret_cast<const DebugCommand*>(
               &_DebugCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DebugCommand& a, DebugCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugCommand& from) {
    DebugCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugCommand";
  }
  protected:
  explicit DebugCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawFieldNumber = 1,
    kGameStateFieldNumber = 2,
    kCreateUnitFieldNumber = 3,
    kKillUnitFieldNumber = 4,
    kTestProcessFieldNumber = 5,
    kScoreFieldNumber = 6,
    kEndGameFieldNumber = 7,
    kUnitValueFieldNumber = 8,
  };
  // .SC2APIProtocol.DebugDraw draw = 1;
  bool has_draw() const;
  private:
  bool _internal_has_draw() const;
  public:
  void clear_draw();
  const ::SC2APIProtocol::DebugDraw& draw() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::DebugDraw* release_draw();
  ::SC2APIProtocol::DebugDraw* mutable_draw();
  void set_allocated_draw(::SC2APIProtocol::DebugDraw* draw);
  private:
  const ::SC2APIProtocol::DebugDraw& _internal_draw() const;
  ::SC2APIProtocol::DebugDraw* _internal_mutable_draw();
  public:
  void unsafe_arena_set_allocated_draw(
      ::SC2APIProtocol::DebugDraw* draw);
  ::SC2APIProtocol::DebugDraw* unsafe_arena_release_draw();

  // .SC2APIProtocol.DebugGameState game_state = 2;
  bool has_game_state() const;
  private:
  bool _internal_has_game_state() const;
  public:
  void clear_game_state();
  ::SC2APIProtocol::DebugGameState game_state() const;
  void set_game_state(::SC2APIProtocol::DebugGameState value);
  private:
  ::SC2APIProtocol::DebugGameState _internal_game_state() const;
  void _internal_set_game_state(::SC2APIProtocol::DebugGameState value);
  public:

  // .SC2APIProtocol.DebugCreateUnit create_unit = 3;
  bool has_create_unit() const;
  private:
  bool _internal_has_create_unit() const;
  public:
  void clear_create_unit();
  const ::SC2APIProtocol::DebugCreateUnit& create_unit() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::DebugCreateUnit* release_create_unit();
  ::SC2APIProtocol::DebugCreateUnit* mutable_create_unit();
  void set_allocated_create_unit(::SC2APIProtocol::DebugCreateUnit* create_unit);
  private:
  const ::SC2APIProtocol::DebugCreateUnit& _internal_create_unit() const;
  ::SC2APIProtocol::DebugCreateUnit* _internal_mutable_create_unit();
  public:
  void unsafe_arena_set_allocated_create_unit(
      ::SC2APIProtocol::DebugCreateUnit* create_unit);
  ::SC2APIProtocol::DebugCreateUnit* unsafe_arena_release_create_unit();

  // .SC2APIProtocol.DebugKillUnit kill_unit = 4;
  bool has_kill_unit() const;
  private:
  bool _internal_has_kill_unit() const;
  public:
  void clear_kill_unit();
  const ::SC2APIProtocol::DebugKillUnit& kill_unit() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::DebugKillUnit* release_kill_unit();
  ::SC2APIProtocol::DebugKillUnit* mutable_kill_unit();
  void set_allocated_kill_unit(::SC2APIProtocol::DebugKillUnit* kill_unit);
  private:
  const ::SC2APIProtocol::DebugKillUnit& _internal_kill_unit() const;
  ::SC2APIProtocol::DebugKillUnit* _internal_mutable_kill_unit();
  public:
  void unsafe_arena_set_allocated_kill_unit(
      ::SC2APIProtocol::DebugKillUnit* kill_unit);
  ::SC2APIProtocol::DebugKillUnit* unsafe_arena_release_kill_unit();

  // .SC2APIProtocol.DebugTestProcess test_process = 5;
  bool has_test_process() const;
  private:
  bool _internal_has_test_process() const;
  public:
  void clear_test_process();
  const ::SC2APIProtocol::DebugTestProcess& test_process() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::DebugTestProcess* release_test_process();
  ::SC2APIProtocol::DebugTestProcess* mutable_test_process();
  void set_allocated_test_process(::SC2APIProtocol::DebugTestProcess* test_process);
  private:
  const ::SC2APIProtocol::DebugTestProcess& _internal_test_process() const;
  ::SC2APIProtocol::DebugTestProcess* _internal_mutable_test_process();
  public:
  void unsafe_arena_set_allocated_test_process(
      ::SC2APIProtocol::DebugTestProcess* test_process);
  ::SC2APIProtocol::DebugTestProcess* unsafe_arena_release_test_process();

  // .SC2APIProtocol.DebugSetScore score = 6;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  const ::SC2APIProtocol::DebugSetScore& score() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::DebugSetScore* release_score();
  ::SC2APIProtocol::DebugSetScore* mutable_score();
  void set_allocated_score(::SC2APIProtocol::DebugSetScore* score);
  private:
  const ::SC2APIProtocol::DebugSetScore& _internal_score() const;
  ::SC2APIProtocol::DebugSetScore* _internal_mutable_score();
  public:
  void unsafe_arena_set_allocated_score(
      ::SC2APIProtocol::DebugSetScore* score);
  ::SC2APIProtocol::DebugSetScore* unsafe_arena_release_score();

  // .SC2APIProtocol.DebugEndGame end_game = 7;
  bool has_end_game() const;
  private:
  bool _internal_has_end_game() const;
  public:
  void clear_end_game();
  const ::SC2APIProtocol::DebugEndGame& end_game() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::DebugEndGame* release_end_game();
  ::SC2APIProtocol::DebugEndGame* mutable_end_game();
  void set_allocated_end_game(::SC2APIProtocol::DebugEndGame* end_game);
  private:
  const ::SC2APIProtocol::DebugEndGame& _internal_end_game() const;
  ::SC2APIProtocol::DebugEndGame* _internal_mutable_end_game();
  public:
  void unsafe_arena_set_allocated_end_game(
      ::SC2APIProtocol::DebugEndGame* end_game);
  ::SC2APIProtocol::DebugEndGame* unsafe_arena_release_end_game();

  // .SC2APIProtocol.DebugSetUnitValue unit_value = 8;
  bool has_unit_value() const;
  private:
  bool _internal_has_unit_value() const;
  public:
  void clear_unit_value();
  const ::SC2APIProtocol::DebugSetUnitValue& unit_value() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::DebugSetUnitValue* release_unit_value();
  ::SC2APIProtocol::DebugSetUnitValue* mutable_unit_value();
  void set_allocated_unit_value(::SC2APIProtocol::DebugSetUnitValue* unit_value);
  private:
  const ::SC2APIProtocol::DebugSetUnitValue& _internal_unit_value() const;
  ::SC2APIProtocol::DebugSetUnitValue* _internal_mutable_unit_value();
  public:
  void unsafe_arena_set_allocated_unit_value(
      ::SC2APIProtocol::DebugSetUnitValue* unit_value);
  ::SC2APIProtocol::DebugSetUnitValue* unsafe_arena_release_unit_value();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugCommand)
 private:
  class _Internal;
  void set_has_draw();
  void set_has_game_state();
  void set_has_create_unit();
  void set_has_kill_unit();
  void set_has_test_process();
  void set_has_score();
  void set_has_end_game();
  void set_has_unit_value();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SC2APIProtocol::DebugDraw* draw_;
      int game_state_;
      ::SC2APIProtocol::DebugCreateUnit* create_unit_;
      ::SC2APIProtocol::DebugKillUnit* kill_unit_;
      ::SC2APIProtocol::DebugTestProcess* test_process_;
      ::SC2APIProtocol::DebugSetScore* score_;
      ::SC2APIProtocol::DebugEndGame* end_game_;
      ::SC2APIProtocol::DebugSetUnitValue* unit_value_;
    } command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugDraw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugDraw) */ {
 public:
  inline DebugDraw() : DebugDraw(nullptr) {}
  ~DebugDraw() override;
  explicit PROTOBUF_CONSTEXPR DebugDraw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugDraw(const DebugDraw& from);
  DebugDraw(DebugDraw&& from) noexcept
    : DebugDraw() {
    *this = ::std::move(from);
  }

  inline DebugDraw& operator=(const DebugDraw& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugDraw& operator=(DebugDraw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugDraw& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugDraw* internal_default_instance() {
    return reinterpret_cast<const DebugDraw*>(
               &_DebugDraw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DebugDraw& a, DebugDraw& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugDraw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugDraw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugDraw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugDraw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugDraw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugDraw& from) {
    DebugDraw::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugDraw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugDraw";
  }
  protected:
  explicit DebugDraw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kLinesFieldNumber = 2,
    kBoxesFieldNumber = 3,
    kSpheresFieldNumber = 4,
  };
  // repeated .SC2APIProtocol.DebugText text = 1;
  int text_size() const;
  private:
  int _internal_text_size() const;
  public:
  void clear_text();
  ::SC2APIProtocol::DebugText* mutable_text(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText >*
      mutable_text();
  private:
  const ::SC2APIProtocol::DebugText& _internal_text(int index) const;
  ::SC2APIProtocol::DebugText* _internal_add_text();
  public:
  const ::SC2APIProtocol::DebugText& text(int index) const;
  ::SC2APIProtocol::DebugText* add_text();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText >&
      text() const;

  // repeated .SC2APIProtocol.DebugLine lines = 2;
  int lines_size() const;
  private:
  int _internal_lines_size() const;
  public:
  void clear_lines();
  ::SC2APIProtocol::DebugLine* mutable_lines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine >*
      mutable_lines();
  private:
  const ::SC2APIProtocol::DebugLine& _internal_lines(int index) const;
  ::SC2APIProtocol::DebugLine* _internal_add_lines();
  public:
  const ::SC2APIProtocol::DebugLine& lines(int index) const;
  ::SC2APIProtocol::DebugLine* add_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine >&
      lines() const;

  // repeated .SC2APIProtocol.DebugBox boxes = 3;
  int boxes_size() const;
  private:
  int _internal_boxes_size() const;
  public:
  void clear_boxes();
  ::SC2APIProtocol::DebugBox* mutable_boxes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox >*
      mutable_boxes();
  private:
  const ::SC2APIProtocol::DebugBox& _internal_boxes(int index) const;
  ::SC2APIProtocol::DebugBox* _internal_add_boxes();
  public:
  const ::SC2APIProtocol::DebugBox& boxes(int index) const;
  ::SC2APIProtocol::DebugBox* add_boxes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox >&
      boxes() const;

  // repeated .SC2APIProtocol.DebugSphere spheres = 4;
  int spheres_size() const;
  private:
  int _internal_spheres_size() const;
  public:
  void clear_spheres();
  ::SC2APIProtocol::DebugSphere* mutable_spheres(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere >*
      mutable_spheres();
  private:
  const ::SC2APIProtocol::DebugSphere& _internal_spheres(int index) const;
  ::SC2APIProtocol::DebugSphere* _internal_add_spheres();
  public:
  const ::SC2APIProtocol::DebugSphere& spheres(int index) const;
  ::SC2APIProtocol::DebugSphere* add_spheres();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere >&
      spheres() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugDraw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText > text_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine > lines_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox > boxes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere > spheres_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class Line final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Line) */ {
 public:
  inline Line() : Line(nullptr) {}
  ~Line() override;
  explicit PROTOBUF_CONSTEXPR Line(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Line(const Line& from);
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line& operator=(Line&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Line& default_instance() {
    return *internal_default_instance();
  }
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }
  inline void Swap(Line* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Line* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Line* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Line& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Line& from) {
    Line::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Line";
  }
  protected:
  explicit Line(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kP0FieldNumber = 1,
    kP1FieldNumber = 2,
  };
  // optional .SC2APIProtocol.Point p0 = 1;
  bool has_p0() const;
  private:
  bool _internal_has_p0() const;
  public:
  void clear_p0();
  const ::SC2APIProtocol::Point& p0() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_p0();
  ::SC2APIProtocol::Point* mutable_p0();
  void set_allocated_p0(::SC2APIProtocol::Point* p0);
  private:
  const ::SC2APIProtocol::Point& _internal_p0() const;
  ::SC2APIProtocol::Point* _internal_mutable_p0();
  public:
  void unsafe_arena_set_allocated_p0(
      ::SC2APIProtocol::Point* p0);
  ::SC2APIProtocol::Point* unsafe_arena_release_p0();

  // optional .SC2APIProtocol.Point p1 = 2;
  bool has_p1() const;
  private:
  bool _internal_has_p1() const;
  public:
  void clear_p1();
  const ::SC2APIProtocol::Point& p1() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_p1();
  ::SC2APIProtocol::Point* mutable_p1();
  void set_allocated_p1(::SC2APIProtocol::Point* p1);
  private:
  const ::SC2APIProtocol::Point& _internal_p1() const;
  ::SC2APIProtocol::Point* _internal_mutable_p1();
  public:
  void unsafe_arena_set_allocated_p1(
      ::SC2APIProtocol::Point* p1);
  ::SC2APIProtocol::Point* unsafe_arena_release_p1();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Line)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Point* p0_;
    ::SC2APIProtocol::Point* p1_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class Color final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  ~Color() override;
  explicit PROTOBUF_CONSTEXPR Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Color& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Color& from) {
    Color::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
  };
  // optional uint32 r = 1;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  uint32_t r() const;
  void set_r(uint32_t value);
  private:
  uint32_t _internal_r() const;
  void _internal_set_r(uint32_t value);
  public:

  // optional uint32 g = 2;
  bool has_g() const;
  private:
  bool _internal_has_g() const;
  public:
  void clear_g();
  uint32_t g() const;
  void set_g(uint32_t value);
  private:
  uint32_t _internal_g() const;
  void _internal_set_g(uint32_t value);
  public:

  // optional uint32 b = 3;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  uint32_t b() const;
  void set_b(uint32_t value);
  private:
  uint32_t _internal_b() const;
  void _internal_set_b(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t r_;
    uint32_t g_;
    uint32_t b_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugText final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugText) */ {
 public:
  inline DebugText() : DebugText(nullptr) {}
  ~DebugText() override;
  explicit PROTOBUF_CONSTEXPR DebugText(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugText(const DebugText& from);
  DebugText(DebugText&& from) noexcept
    : DebugText() {
    *this = ::std::move(from);
  }

  inline DebugText& operator=(const DebugText& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugText& operator=(DebugText&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugText& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugText* internal_default_instance() {
    return reinterpret_cast<const DebugText*>(
               &_DebugText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DebugText& a, DebugText& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugText* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugText>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugText& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugText& from) {
    DebugText::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugText* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugText";
  }
  protected:
  explicit DebugText(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kColorFieldNumber = 1,
    kVirtualPosFieldNumber = 3,
    kWorldPosFieldNumber = 4,
    kSizeFieldNumber = 5,
  };
  // optional string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional .SC2APIProtocol.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::SC2APIProtocol::Color& color() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Color* release_color();
  ::SC2APIProtocol::Color* mutable_color();
  void set_allocated_color(::SC2APIProtocol::Color* color);
  private:
  const ::SC2APIProtocol::Color& _internal_color() const;
  ::SC2APIProtocol::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::SC2APIProtocol::Color* color);
  ::SC2APIProtocol::Color* unsafe_arena_release_color();

  // optional .SC2APIProtocol.Point virtual_pos = 3;
  bool has_virtual_pos() const;
  private:
  bool _internal_has_virtual_pos() const;
  public:
  void clear_virtual_pos();
  const ::SC2APIProtocol::Point& virtual_pos() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_virtual_pos();
  ::SC2APIProtocol::Point* mutable_virtual_pos();
  void set_allocated_virtual_pos(::SC2APIProtocol::Point* virtual_pos);
  private:
  const ::SC2APIProtocol::Point& _internal_virtual_pos() const;
  ::SC2APIProtocol::Point* _internal_mutable_virtual_pos();
  public:
  void unsafe_arena_set_allocated_virtual_pos(
      ::SC2APIProtocol::Point* virtual_pos);
  ::SC2APIProtocol::Point* unsafe_arena_release_virtual_pos();

  // optional .SC2APIProtocol.Point world_pos = 4;
  bool has_world_pos() const;
  private:
  bool _internal_has_world_pos() const;
  public:
  void clear_world_pos();
  const ::SC2APIProtocol::Point& world_pos() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_world_pos();
  ::SC2APIProtocol::Point* mutable_world_pos();
  void set_allocated_world_pos(::SC2APIProtocol::Point* world_pos);
  private:
  const ::SC2APIProtocol::Point& _internal_world_pos() const;
  ::SC2APIProtocol::Point* _internal_mutable_world_pos();
  public:
  void unsafe_arena_set_allocated_world_pos(
      ::SC2APIProtocol::Point* world_pos);
  ::SC2APIProtocol::Point* unsafe_arena_release_world_pos();

  // optional uint32 size = 5;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::SC2APIProtocol::Color* color_;
    ::SC2APIProtocol::Point* virtual_pos_;
    ::SC2APIProtocol::Point* world_pos_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugLine) */ {
 public:
  inline DebugLine() : DebugLine(nullptr) {}
  ~DebugLine() override;
  explicit PROTOBUF_CONSTEXPR DebugLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugLine(const DebugLine& from);
  DebugLine(DebugLine&& from) noexcept
    : DebugLine() {
    *this = ::std::move(from);
  }

  inline DebugLine& operator=(const DebugLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugLine& operator=(DebugLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugLine* internal_default_instance() {
    return reinterpret_cast<const DebugLine*>(
               &_DebugLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DebugLine& a, DebugLine& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugLine& from) {
    DebugLine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugLine";
  }
  protected:
  explicit DebugLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kLineFieldNumber = 2,
  };
  // optional .SC2APIProtocol.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::SC2APIProtocol::Color& color() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Color* release_color();
  ::SC2APIProtocol::Color* mutable_color();
  void set_allocated_color(::SC2APIProtocol::Color* color);
  private:
  const ::SC2APIProtocol::Color& _internal_color() const;
  ::SC2APIProtocol::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::SC2APIProtocol::Color* color);
  ::SC2APIProtocol::Color* unsafe_arena_release_color();

  // optional .SC2APIProtocol.Line line = 2;
  bool has_line() const;
  private:
  bool _internal_has_line() const;
  public:
  void clear_line();
  const ::SC2APIProtocol::Line& line() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Line* release_line();
  ::SC2APIProtocol::Line* mutable_line();
  void set_allocated_line(::SC2APIProtocol::Line* line);
  private:
  const ::SC2APIProtocol::Line& _internal_line() const;
  ::SC2APIProtocol::Line* _internal_mutable_line();
  public:
  void unsafe_arena_set_allocated_line(
      ::SC2APIProtocol::Line* line);
  ::SC2APIProtocol::Line* unsafe_arena_release_line();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Color* color_;
    ::SC2APIProtocol::Line* line_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugBox) */ {
 public:
  inline DebugBox() : DebugBox(nullptr) {}
  ~DebugBox() override;
  explicit PROTOBUF_CONSTEXPR DebugBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugBox(const DebugBox& from);
  DebugBox(DebugBox&& from) noexcept
    : DebugBox() {
    *this = ::std::move(from);
  }

  inline DebugBox& operator=(const DebugBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugBox& operator=(DebugBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugBox* internal_default_instance() {
    return reinterpret_cast<const DebugBox*>(
               &_DebugBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DebugBox& a, DebugBox& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugBox& from) {
    DebugBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugBox";
  }
  protected:
  explicit DebugBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  // optional .SC2APIProtocol.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::SC2APIProtocol::Color& color() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Color* release_color();
  ::SC2APIProtocol::Color* mutable_color();
  void set_allocated_color(::SC2APIProtocol::Color* color);
  private:
  const ::SC2APIProtocol::Color& _internal_color() const;
  ::SC2APIProtocol::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::SC2APIProtocol::Color* color);
  ::SC2APIProtocol::Color* unsafe_arena_release_color();

  // optional .SC2APIProtocol.Point min = 2;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::SC2APIProtocol::Point& min() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_min();
  ::SC2APIProtocol::Point* mutable_min();
  void set_allocated_min(::SC2APIProtocol::Point* min);
  private:
  const ::SC2APIProtocol::Point& _internal_min() const;
  ::SC2APIProtocol::Point* _internal_mutable_min();
  public:
  void unsafe_arena_set_allocated_min(
      ::SC2APIProtocol::Point* min);
  ::SC2APIProtocol::Point* unsafe_arena_release_min();

  // optional .SC2APIProtocol.Point max = 3;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::SC2APIProtocol::Point& max() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_max();
  ::SC2APIProtocol::Point* mutable_max();
  void set_allocated_max(::SC2APIProtocol::Point* max);
  private:
  const ::SC2APIProtocol::Point& _internal_max() const;
  ::SC2APIProtocol::Point* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::SC2APIProtocol::Point* max);
  ::SC2APIProtocol::Point* unsafe_arena_release_max();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Color* color_;
    ::SC2APIProtocol::Point* min_;
    ::SC2APIProtocol::Point* max_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugSphere final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugSphere) */ {
 public:
  inline DebugSphere() : DebugSphere(nullptr) {}
  ~DebugSphere() override;
  explicit PROTOBUF_CONSTEXPR DebugSphere(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugSphere(const DebugSphere& from);
  DebugSphere(DebugSphere&& from) noexcept
    : DebugSphere() {
    *this = ::std::move(from);
  }

  inline DebugSphere& operator=(const DebugSphere& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugSphere& operator=(DebugSphere&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugSphere& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugSphere* internal_default_instance() {
    return reinterpret_cast<const DebugSphere*>(
               &_DebugSphere_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DebugSphere& a, DebugSphere& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugSphere* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugSphere* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugSphere* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugSphere>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugSphere& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugSphere& from) {
    DebugSphere::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSphere* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugSphere";
  }
  protected:
  explicit DebugSphere(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kPFieldNumber = 2,
    kRFieldNumber = 3,
  };
  // optional .SC2APIProtocol.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::SC2APIProtocol::Color& color() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Color* release_color();
  ::SC2APIProtocol::Color* mutable_color();
  void set_allocated_color(::SC2APIProtocol::Color* color);
  private:
  const ::SC2APIProtocol::Color& _internal_color() const;
  ::SC2APIProtocol::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::SC2APIProtocol::Color* color);
  ::SC2APIProtocol::Color* unsafe_arena_release_color();

  // optional .SC2APIProtocol.Point p = 2;
  bool has_p() const;
  private:
  bool _internal_has_p() const;
  public:
  void clear_p();
  const ::SC2APIProtocol::Point& p() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point* release_p();
  ::SC2APIProtocol::Point* mutable_p();
  void set_allocated_p(::SC2APIProtocol::Point* p);
  private:
  const ::SC2APIProtocol::Point& _internal_p() const;
  ::SC2APIProtocol::Point* _internal_mutable_p();
  public:
  void unsafe_arena_set_allocated_p(
      ::SC2APIProtocol::Point* p);
  ::SC2APIProtocol::Point* unsafe_arena_release_p();

  // optional float r = 3;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugSphere)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Color* color_;
    ::SC2APIProtocol::Point* p_;
    float r_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugCreateUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugCreateUnit) */ {
 public:
  inline DebugCreateUnit() : DebugCreateUnit(nullptr) {}
  ~DebugCreateUnit() override;
  explicit PROTOBUF_CONSTEXPR DebugCreateUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugCreateUnit(const DebugCreateUnit& from);
  DebugCreateUnit(DebugCreateUnit&& from) noexcept
    : DebugCreateUnit() {
    *this = ::std::move(from);
  }

  inline DebugCreateUnit& operator=(const DebugCreateUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugCreateUnit& operator=(DebugCreateUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugCreateUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugCreateUnit* internal_default_instance() {
    return reinterpret_cast<const DebugCreateUnit*>(
               &_DebugCreateUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DebugCreateUnit& a, DebugCreateUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugCreateUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugCreateUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugCreateUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugCreateUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugCreateUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugCreateUnit& from) {
    DebugCreateUnit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugCreateUnit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugCreateUnit";
  }
  protected:
  explicit DebugCreateUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 3,
    kUnitTypeFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kQuantityFieldNumber = 4,
  };
  // optional .SC2APIProtocol.Point2D pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::SC2APIProtocol::Point2D& pos() const;
  PROTOBUF_NODISCARD ::SC2APIProtocol::Point2D* release_pos();
  ::SC2APIProtocol::Point2D* mutable_pos();
  void set_allocated_pos(::SC2APIProtocol::Point2D* pos);
  private:
  const ::SC2APIProtocol::Point2D& _internal_pos() const;
  ::SC2APIProtocol::Point2D* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::SC2APIProtocol::Point2D* pos);
  ::SC2APIProtocol::Point2D* unsafe_arena_release_pos();

  // optional uint32 unit_type = 1;
  bool has_unit_type() const;
  private:
  bool _internal_has_unit_type() const;
  public:
  void clear_unit_type();
  uint32_t unit_type() const;
  void set_unit_type(uint32_t value);
  private:
  uint32_t _internal_unit_type() const;
  void _internal_set_unit_type(uint32_t value);
  public:

  // optional int32 owner = 2;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  int32_t owner() const;
  void set_owner(int32_t value);
  private:
  int32_t _internal_owner() const;
  void _internal_set_owner(int32_t value);
  public:

  // optional uint32 quantity = 4;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  uint32_t quantity() const;
  void set_quantity(uint32_t value);
  private:
  uint32_t _internal_quantity() const;
  void _internal_set_quantity(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugCreateUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SC2APIProtocol::Point2D* pos_;
    uint32_t unit_type_;
    int32_t owner_;
    uint32_t quantity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugKillUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugKillUnit) */ {
 public:
  inline DebugKillUnit() : DebugKillUnit(nullptr) {}
  ~DebugKillUnit() override;
  explicit PROTOBUF_CONSTEXPR DebugKillUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugKillUnit(const DebugKillUnit& from);
  DebugKillUnit(DebugKillUnit&& from) noexcept
    : DebugKillUnit() {
    *this = ::std::move(from);
  }

  inline DebugKillUnit& operator=(const DebugKillUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugKillUnit& operator=(DebugKillUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugKillUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugKillUnit* internal_default_instance() {
    return reinterpret_cast<const DebugKillUnit*>(
               &_DebugKillUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DebugKillUnit& a, DebugKillUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugKillUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugKillUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugKillUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugKillUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugKillUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugKillUnit& from) {
    DebugKillUnit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugKillUnit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugKillUnit";
  }
  protected:
  explicit DebugKillUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // repeated uint64 tag = 1;
  int tag_size() const;
  private:
  int _internal_tag_size() const;
  public:
  void clear_tag();
  private:
  uint64_t _internal_tag(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_tag() const;
  void _internal_add_tag(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_tag();
  public:
  uint64_t tag(int index) const;
  void set_tag(int index, uint64_t value);
  void add_tag(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      tag() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_tag();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugKillUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > tag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugTestProcess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugTestProcess) */ {
 public:
  inline DebugTestProcess() : DebugTestProcess(nullptr) {}
  ~DebugTestProcess() override;
  explicit PROTOBUF_CONSTEXPR DebugTestProcess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugTestProcess(const DebugTestProcess& from);
  DebugTestProcess(DebugTestProcess&& from) noexcept
    : DebugTestProcess() {
    *this = ::std::move(from);
  }

  inline DebugTestProcess& operator=(const DebugTestProcess& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugTestProcess& operator=(DebugTestProcess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugTestProcess& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugTestProcess* internal_default_instance() {
    return reinterpret_cast<const DebugTestProcess*>(
               &_DebugTestProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DebugTestProcess& a, DebugTestProcess& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugTestProcess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugTestProcess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugTestProcess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugTestProcess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugTestProcess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugTestProcess& from) {
    DebugTestProcess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugTestProcess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugTestProcess";
  }
  protected:
  explicit DebugTestProcess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DebugTestProcess_Test Test;
  static constexpr Test hang =
    DebugTestProcess_Test_hang;
  static constexpr Test crash =
    DebugTestProcess_Test_crash;
  static constexpr Test exit =
    DebugTestProcess_Test_exit;
  static inline bool Test_IsValid(int value) {
    return DebugTestProcess_Test_IsValid(value);
  }
  static constexpr Test Test_MIN =
    DebugTestProcess_Test_Test_MIN;
  static constexpr Test Test_MAX =
    DebugTestProcess_Test_Test_MAX;
  static constexpr int Test_ARRAYSIZE =
    DebugTestProcess_Test_Test_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Test_descriptor() {
    return DebugTestProcess_Test_descriptor();
  }
  template<typename T>
  static inline const std::string& Test_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Test>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Test_Name.");
    return DebugTestProcess_Test_Name(enum_t_value);
  }
  static inline bool Test_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Test* value) {
    return DebugTestProcess_Test_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDelayMsFieldNumber = 2,
    kTestFieldNumber = 1,
  };
  // optional int32 delay_ms = 2;
  bool has_delay_ms() const;
  private:
  bool _internal_has_delay_ms() const;
  public:
  void clear_delay_ms();
  int32_t delay_ms() const;
  void set_delay_ms(int32_t value);
  private:
  int32_t _internal_delay_ms() const;
  void _internal_set_delay_ms(int32_t value);
  public:

  // optional .SC2APIProtocol.DebugTestProcess.Test test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  ::SC2APIProtocol::DebugTestProcess_Test test() const;
  void set_test(::SC2APIProtocol::DebugTestProcess_Test value);
  private:
  ::SC2APIProtocol::DebugTestProcess_Test _internal_test() const;
  void _internal_set_test(::SC2APIProtocol::DebugTestProcess_Test value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugTestProcess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t delay_ms_;
    int test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugSetScore final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugSetScore) */ {
 public:
  inline DebugSetScore() : DebugSetScore(nullptr) {}
  ~DebugSetScore() override;
  explicit PROTOBUF_CONSTEXPR DebugSetScore(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugSetScore(const DebugSetScore& from);
  DebugSetScore(DebugSetScore&& from) noexcept
    : DebugSetScore() {
    *this = ::std::move(from);
  }

  inline DebugSetScore& operator=(const DebugSetScore& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugSetScore& operator=(DebugSetScore&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugSetScore& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugSetScore* internal_default_instance() {
    return reinterpret_cast<const DebugSetScore*>(
               &_DebugSetScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DebugSetScore& a, DebugSetScore& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugSetScore* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugSetScore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugSetScore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugSetScore>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugSetScore& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugSetScore& from) {
    DebugSetScore::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSetScore* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugSetScore";
  }
  protected:
  explicit DebugSetScore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScoreFieldNumber = 1,
  };
  // optional float score = 1;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugSetScore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float score_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugEndGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugEndGame) */ {
 public:
  inline DebugEndGame() : DebugEndGame(nullptr) {}
  ~DebugEndGame() override;
  explicit PROTOBUF_CONSTEXPR DebugEndGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugEndGame(const DebugEndGame& from);
  DebugEndGame(DebugEndGame&& from) noexcept
    : DebugEndGame() {
    *this = ::std::move(from);
  }

  inline DebugEndGame& operator=(const DebugEndGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugEndGame& operator=(DebugEndGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugEndGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugEndGame* internal_default_instance() {
    return reinterpret_cast<const DebugEndGame*>(
               &_DebugEndGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DebugEndGame& a, DebugEndGame& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugEndGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugEndGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugEndGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugEndGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugEndGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugEndGame& from) {
    DebugEndGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugEndGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugEndGame";
  }
  protected:
  explicit DebugEndGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DebugEndGame_EndResult EndResult;
  static constexpr EndResult Surrender =
    DebugEndGame_EndResult_Surrender;
  static constexpr EndResult DeclareVictory =
    DebugEndGame_EndResult_DeclareVictory;
  static inline bool EndResult_IsValid(int value) {
    return DebugEndGame_EndResult_IsValid(value);
  }
  static constexpr EndResult EndResult_MIN =
    DebugEndGame_EndResult_EndResult_MIN;
  static constexpr EndResult EndResult_MAX =
    DebugEndGame_EndResult_EndResult_MAX;
  static constexpr int EndResult_ARRAYSIZE =
    DebugEndGame_EndResult_EndResult_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EndResult_descriptor() {
    return DebugEndGame_EndResult_descriptor();
  }
  template<typename T>
  static inline const std::string& EndResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EndResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EndResult_Name.");
    return DebugEndGame_EndResult_Name(enum_t_value);
  }
  static inline bool EndResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EndResult* value) {
    return DebugEndGame_EndResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEndResultFieldNumber = 1,
  };
  // optional .SC2APIProtocol.DebugEndGame.EndResult end_result = 1;
  bool has_end_result() const;
  private:
  bool _internal_has_end_result() const;
  public:
  void clear_end_result();
  ::SC2APIProtocol::DebugEndGame_EndResult end_result() const;
  void set_end_result(::SC2APIProtocol::DebugEndGame_EndResult value);
  private:
  ::SC2APIProtocol::DebugEndGame_EndResult _internal_end_result() const;
  void _internal_set_end_result(::SC2APIProtocol::DebugEndGame_EndResult value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugEndGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int end_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugSetUnitValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugSetUnitValue) */ {
 public:
  inline DebugSetUnitValue() : DebugSetUnitValue(nullptr) {}
  ~DebugSetUnitValue() override;
  explicit PROTOBUF_CONSTEXPR DebugSetUnitValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugSetUnitValue(const DebugSetUnitValue& from);
  DebugSetUnitValue(DebugSetUnitValue&& from) noexcept
    : DebugSetUnitValue() {
    *this = ::std::move(from);
  }

  inline DebugSetUnitValue& operator=(const DebugSetUnitValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugSetUnitValue& operator=(DebugSetUnitValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugSetUnitValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugSetUnitValue* internal_default_instance() {
    return reinterpret_cast<const DebugSetUnitValue*>(
               &_DebugSetUnitValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DebugSetUnitValue& a, DebugSetUnitValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugSetUnitValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugSetUnitValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugSetUnitValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugSetUnitValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugSetUnitValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugSetUnitValue& from) {
    DebugSetUnitValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSetUnitValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugSetUnitValue";
  }
  protected:
  explicit DebugSetUnitValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DebugSetUnitValue_UnitValue UnitValue;
  static constexpr UnitValue Energy =
    DebugSetUnitValue_UnitValue_Energy;
  static constexpr UnitValue Life =
    DebugSetUnitValue_UnitValue_Life;
  static constexpr UnitValue Shields =
    DebugSetUnitValue_UnitValue_Shields;
  static inline bool UnitValue_IsValid(int value) {
    return DebugSetUnitValue_UnitValue_IsValid(value);
  }
  static constexpr UnitValue UnitValue_MIN =
    DebugSetUnitValue_UnitValue_UnitValue_MIN;
  static constexpr UnitValue UnitValue_MAX =
    DebugSetUnitValue_UnitValue_UnitValue_MAX;
  static constexpr int UnitValue_ARRAYSIZE =
    DebugSetUnitValue_UnitValue_UnitValue_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UnitValue_descriptor() {
    return DebugSetUnitValue_UnitValue_descriptor();
  }
  template<typename T>
  static inline const std::string& UnitValue_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UnitValue>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UnitValue_Name.");
    return DebugSetUnitValue_UnitValue_Name(enum_t_value);
  }
  static inline bool UnitValue_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UnitValue* value) {
    return DebugSetUnitValue_UnitValue_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUnitTagFieldNumber = 3,
    kValueFieldNumber = 2,
    kUnitValueFieldNumber = 1,
  };
  // optional uint64 unit_tag = 3;
  bool has_unit_tag() const;
  private:
  bool _internal_has_unit_tag() const;
  public:
  void clear_unit_tag();
  uint64_t unit_tag() const;
  void set_unit_tag(uint64_t value);
  private:
  uint64_t _internal_unit_tag() const;
  void _internal_set_unit_tag(uint64_t value);
  public:

  // optional float value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // optional .SC2APIProtocol.DebugSetUnitValue.UnitValue unit_value = 1;
  bool has_unit_value() const;
  private:
  bool _internal_has_unit_value() const;
  public:
  void clear_unit_value();
  ::SC2APIProtocol::DebugSetUnitValue_UnitValue unit_value() const;
  void set_unit_value(::SC2APIProtocol::DebugSetUnitValue_UnitValue value);
  private:
  ::SC2APIProtocol::DebugSetUnitValue_UnitValue _internal_unit_value() const;
  void _internal_set_unit_value(::SC2APIProtocol::DebugSetUnitValue_UnitValue value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugSetUnitValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t unit_tag_;
    float value_;
    int unit_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DebugCommand

// .SC2APIProtocol.DebugDraw draw = 1;
inline bool DebugCommand::_internal_has_draw() const {
  return command_case() == kDraw;
}
inline bool DebugCommand::has_draw() const {
  return _internal_has_draw();
}
inline void DebugCommand::set_has_draw() {
  _impl_._oneof_case_[0] = kDraw;
}
inline void DebugCommand::clear_draw() {
  if (_internal_has_draw()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.draw_;
    }
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugDraw* DebugCommand::release_draw() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.draw)
  if (_internal_has_draw()) {
    clear_has_command();
    ::SC2APIProtocol::DebugDraw* temp = _impl_.command_.draw_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.draw_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugDraw& DebugCommand::_internal_draw() const {
  return _internal_has_draw()
      ? *_impl_.command_.draw_
      : reinterpret_cast< ::SC2APIProtocol::DebugDraw&>(::SC2APIProtocol::_DebugDraw_default_instance_);
}
inline const ::SC2APIProtocol::DebugDraw& DebugCommand::draw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.draw)
  return _internal_draw();
}
inline ::SC2APIProtocol::DebugDraw* DebugCommand::unsafe_arena_release_draw() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.DebugCommand.draw)
  if (_internal_has_draw()) {
    clear_has_command();
    ::SC2APIProtocol::DebugDraw* temp = _impl_.command_.draw_;
    _impl_.command_.draw_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugCommand::unsafe_arena_set_allocated_draw(::SC2APIProtocol::DebugDraw* draw) {
  clear_command();
  if (draw) {
    set_has_draw();
    _impl_.command_.draw_ = draw;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugCommand.draw)
}
inline ::SC2APIProtocol::DebugDraw* DebugCommand::_internal_mutable_draw() {
  if (!_internal_has_draw()) {
    clear_command();
    set_has_draw();
    _impl_.command_.draw_ = CreateMaybeMessage< ::SC2APIProtocol::DebugDraw >(GetArenaForAllocation());
  }
  return _impl_.command_.draw_;
}
inline ::SC2APIProtocol::DebugDraw* DebugCommand::mutable_draw() {
  ::SC2APIProtocol::DebugDraw* _msg = _internal_mutable_draw();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.draw)
  return _msg;
}

// .SC2APIProtocol.DebugGameState game_state = 2;
inline bool DebugCommand::_internal_has_game_state() const {
  return command_case() == kGameState;
}
inline bool DebugCommand::has_game_state() const {
  return _internal_has_game_state();
}
inline void DebugCommand::set_has_game_state() {
  _impl_._oneof_case_[0] = kGameState;
}
inline void DebugCommand::clear_game_state() {
  if (_internal_has_game_state()) {
    _impl_.command_.game_state_ = 1;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugGameState DebugCommand::_internal_game_state() const {
  if (_internal_has_game_state()) {
    return static_cast< ::SC2APIProtocol::DebugGameState >(_impl_.command_.game_state_);
  }
  return static_cast< ::SC2APIProtocol::DebugGameState >(1);
}
inline ::SC2APIProtocol::DebugGameState DebugCommand::game_state() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.game_state)
  return _internal_game_state();
}
inline void DebugCommand::_internal_set_game_state(::SC2APIProtocol::DebugGameState value) {
  assert(::SC2APIProtocol::DebugGameState_IsValid(value));
  if (!_internal_has_game_state()) {
    clear_command();
    set_has_game_state();
  }
  _impl_.command_.game_state_ = value;
}
inline void DebugCommand::set_game_state(::SC2APIProtocol::DebugGameState value) {
  _internal_set_game_state(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugCommand.game_state)
}

// .SC2APIProtocol.DebugCreateUnit create_unit = 3;
inline bool DebugCommand::_internal_has_create_unit() const {
  return command_case() == kCreateUnit;
}
inline bool DebugCommand::has_create_unit() const {
  return _internal_has_create_unit();
}
inline void DebugCommand::set_has_create_unit() {
  _impl_._oneof_case_[0] = kCreateUnit;
}
inline void DebugCommand::clear_create_unit() {
  if (_internal_has_create_unit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.create_unit_;
    }
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugCreateUnit* DebugCommand::release_create_unit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.create_unit)
  if (_internal_has_create_unit()) {
    clear_has_command();
    ::SC2APIProtocol::DebugCreateUnit* temp = _impl_.command_.create_unit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.create_unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugCreateUnit& DebugCommand::_internal_create_unit() const {
  return _internal_has_create_unit()
      ? *_impl_.command_.create_unit_
      : reinterpret_cast< ::SC2APIProtocol::DebugCreateUnit&>(::SC2APIProtocol::_DebugCreateUnit_default_instance_);
}
inline const ::SC2APIProtocol::DebugCreateUnit& DebugCommand::create_unit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.create_unit)
  return _internal_create_unit();
}
inline ::SC2APIProtocol::DebugCreateUnit* DebugCommand::unsafe_arena_release_create_unit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.DebugCommand.create_unit)
  if (_internal_has_create_unit()) {
    clear_has_command();
    ::SC2APIProtocol::DebugCreateUnit* temp = _impl_.command_.create_unit_;
    _impl_.command_.create_unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugCommand::unsafe_arena_set_allocated_create_unit(::SC2APIProtocol::DebugCreateUnit* create_unit) {
  clear_command();
  if (create_unit) {
    set_has_create_unit();
    _impl_.command_.create_unit_ = create_unit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugCommand.create_unit)
}
inline ::SC2APIProtocol::DebugCreateUnit* DebugCommand::_internal_mutable_create_unit() {
  if (!_internal_has_create_unit()) {
    clear_command();
    set_has_create_unit();
    _impl_.command_.create_unit_ = CreateMaybeMessage< ::SC2APIProtocol::DebugCreateUnit >(GetArenaForAllocation());
  }
  return _impl_.command_.create_unit_;
}
inline ::SC2APIProtocol::DebugCreateUnit* DebugCommand::mutable_create_unit() {
  ::SC2APIProtocol::DebugCreateUnit* _msg = _internal_mutable_create_unit();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.create_unit)
  return _msg;
}

// .SC2APIProtocol.DebugKillUnit kill_unit = 4;
inline bool DebugCommand::_internal_has_kill_unit() const {
  return command_case() == kKillUnit;
}
inline bool DebugCommand::has_kill_unit() const {
  return _internal_has_kill_unit();
}
inline void DebugCommand::set_has_kill_unit() {
  _impl_._oneof_case_[0] = kKillUnit;
}
inline void DebugCommand::clear_kill_unit() {
  if (_internal_has_kill_unit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.kill_unit_;
    }
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugKillUnit* DebugCommand::release_kill_unit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.kill_unit)
  if (_internal_has_kill_unit()) {
    clear_has_command();
    ::SC2APIProtocol::DebugKillUnit* temp = _impl_.command_.kill_unit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.kill_unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugKillUnit& DebugCommand::_internal_kill_unit() const {
  return _internal_has_kill_unit()
      ? *_impl_.command_.kill_unit_
      : reinterpret_cast< ::SC2APIProtocol::DebugKillUnit&>(::SC2APIProtocol::_DebugKillUnit_default_instance_);
}
inline const ::SC2APIProtocol::DebugKillUnit& DebugCommand::kill_unit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.kill_unit)
  return _internal_kill_unit();
}
inline ::SC2APIProtocol::DebugKillUnit* DebugCommand::unsafe_arena_release_kill_unit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.DebugCommand.kill_unit)
  if (_internal_has_kill_unit()) {
    clear_has_command();
    ::SC2APIProtocol::DebugKillUnit* temp = _impl_.command_.kill_unit_;
    _impl_.command_.kill_unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugCommand::unsafe_arena_set_allocated_kill_unit(::SC2APIProtocol::DebugKillUnit* kill_unit) {
  clear_command();
  if (kill_unit) {
    set_has_kill_unit();
    _impl_.command_.kill_unit_ = kill_unit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugCommand.kill_unit)
}
inline ::SC2APIProtocol::DebugKillUnit* DebugCommand::_internal_mutable_kill_unit() {
  if (!_internal_has_kill_unit()) {
    clear_command();
    set_has_kill_unit();
    _impl_.command_.kill_unit_ = CreateMaybeMessage< ::SC2APIProtocol::DebugKillUnit >(GetArenaForAllocation());
  }
  return _impl_.command_.kill_unit_;
}
inline ::SC2APIProtocol::DebugKillUnit* DebugCommand::mutable_kill_unit() {
  ::SC2APIProtocol::DebugKillUnit* _msg = _internal_mutable_kill_unit();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.kill_unit)
  return _msg;
}

// .SC2APIProtocol.DebugTestProcess test_process = 5;
inline bool DebugCommand::_internal_has_test_process() const {
  return command_case() == kTestProcess;
}
inline bool DebugCommand::has_test_process() const {
  return _internal_has_test_process();
}
inline void DebugCommand::set_has_test_process() {
  _impl_._oneof_case_[0] = kTestProcess;
}
inline void DebugCommand::clear_test_process() {
  if (_internal_has_test_process()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.test_process_;
    }
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugTestProcess* DebugCommand::release_test_process() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.test_process)
  if (_internal_has_test_process()) {
    clear_has_command();
    ::SC2APIProtocol::DebugTestProcess* temp = _impl_.command_.test_process_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.test_process_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugTestProcess& DebugCommand::_internal_test_process() const {
  return _internal_has_test_process()
      ? *_impl_.command_.test_process_
      : reinterpret_cast< ::SC2APIProtocol::DebugTestProcess&>(::SC2APIProtocol::_DebugTestProcess_default_instance_);
}
inline const ::SC2APIProtocol::DebugTestProcess& DebugCommand::test_process() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.test_process)
  return _internal_test_process();
}
inline ::SC2APIProtocol::DebugTestProcess* DebugCommand::unsafe_arena_release_test_process() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.DebugCommand.test_process)
  if (_internal_has_test_process()) {
    clear_has_command();
    ::SC2APIProtocol::DebugTestProcess* temp = _impl_.command_.test_process_;
    _impl_.command_.test_process_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugCommand::unsafe_arena_set_allocated_test_process(::SC2APIProtocol::DebugTestProcess* test_process) {
  clear_command();
  if (test_process) {
    set_has_test_process();
    _impl_.command_.test_process_ = test_process;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugCommand.test_process)
}
inline ::SC2APIProtocol::DebugTestProcess* DebugCommand::_internal_mutable_test_process() {
  if (!_internal_has_test_process()) {
    clear_command();
    set_has_test_process();
    _impl_.command_.test_process_ = CreateMaybeMessage< ::SC2APIProtocol::DebugTestProcess >(GetArenaForAllocation());
  }
  return _impl_.command_.test_process_;
}
inline ::SC2APIProtocol::DebugTestProcess* DebugCommand::mutable_test_process() {
  ::SC2APIProtocol::DebugTestProcess* _msg = _internal_mutable_test_process();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.test_process)
  return _msg;
}

// .SC2APIProtocol.DebugSetScore score = 6;
inline bool DebugCommand::_internal_has_score() const {
  return command_case() == kScore;
}
inline bool DebugCommand::has_score() const {
  return _internal_has_score();
}
inline void DebugCommand::set_has_score() {
  _impl_._oneof_case_[0] = kScore;
}
inline void DebugCommand::clear_score() {
  if (_internal_has_score()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.score_;
    }
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugSetScore* DebugCommand::release_score() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.score)
  if (_internal_has_score()) {
    clear_has_command();
    ::SC2APIProtocol::DebugSetScore* temp = _impl_.command_.score_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.score_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugSetScore& DebugCommand::_internal_score() const {
  return _internal_has_score()
      ? *_impl_.command_.score_
      : reinterpret_cast< ::SC2APIProtocol::DebugSetScore&>(::SC2APIProtocol::_DebugSetScore_default_instance_);
}
inline const ::SC2APIProtocol::DebugSetScore& DebugCommand::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.score)
  return _internal_score();
}
inline ::SC2APIProtocol::DebugSetScore* DebugCommand::unsafe_arena_release_score() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.DebugCommand.score)
  if (_internal_has_score()) {
    clear_has_command();
    ::SC2APIProtocol::DebugSetScore* temp = _impl_.command_.score_;
    _impl_.command_.score_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugCommand::unsafe_arena_set_allocated_score(::SC2APIProtocol::DebugSetScore* score) {
  clear_command();
  if (score) {
    set_has_score();
    _impl_.command_.score_ = score;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugCommand.score)
}
inline ::SC2APIProtocol::DebugSetScore* DebugCommand::_internal_mutable_score() {
  if (!_internal_has_score()) {
    clear_command();
    set_has_score();
    _impl_.command_.score_ = CreateMaybeMessage< ::SC2APIProtocol::DebugSetScore >(GetArenaForAllocation());
  }
  return _impl_.command_.score_;
}
inline ::SC2APIProtocol::DebugSetScore* DebugCommand::mutable_score() {
  ::SC2APIProtocol::DebugSetScore* _msg = _internal_mutable_score();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.score)
  return _msg;
}

// .SC2APIProtocol.DebugEndGame end_game = 7;
inline bool DebugCommand::_internal_has_end_game() const {
  return command_case() == kEndGame;
}
inline bool DebugCommand::has_end_game() const {
  return _internal_has_end_game();
}
inline void DebugCommand::set_has_end_game() {
  _impl_._oneof_case_[0] = kEndGame;
}
inline void DebugCommand::clear_end_game() {
  if (_internal_has_end_game()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.end_game_;
    }
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugEndGame* DebugCommand::release_end_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.end_game)
  if (_internal_has_end_game()) {
    clear_has_command();
    ::SC2APIProtocol::DebugEndGame* temp = _impl_.command_.end_game_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.end_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugEndGame& DebugCommand::_internal_end_game() const {
  return _internal_has_end_game()
      ? *_impl_.command_.end_game_
      : reinterpret_cast< ::SC2APIProtocol::DebugEndGame&>(::SC2APIProtocol::_DebugEndGame_default_instance_);
}
inline const ::SC2APIProtocol::DebugEndGame& DebugCommand::end_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.end_game)
  return _internal_end_game();
}
inline ::SC2APIProtocol::DebugEndGame* DebugCommand::unsafe_arena_release_end_game() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.DebugCommand.end_game)
  if (_internal_has_end_game()) {
    clear_has_command();
    ::SC2APIProtocol::DebugEndGame* temp = _impl_.command_.end_game_;
    _impl_.command_.end_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugCommand::unsafe_arena_set_allocated_end_game(::SC2APIProtocol::DebugEndGame* end_game) {
  clear_command();
  if (end_game) {
    set_has_end_game();
    _impl_.command_.end_game_ = end_game;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugCommand.end_game)
}
inline ::SC2APIProtocol::DebugEndGame* DebugCommand::_internal_mutable_end_game() {
  if (!_internal_has_end_game()) {
    clear_command();
    set_has_end_game();
    _impl_.command_.end_game_ = CreateMaybeMessage< ::SC2APIProtocol::DebugEndGame >(GetArenaForAllocation());
  }
  return _impl_.command_.end_game_;
}
inline ::SC2APIProtocol::DebugEndGame* DebugCommand::mutable_end_game() {
  ::SC2APIProtocol::DebugEndGame* _msg = _internal_mutable_end_game();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.end_game)
  return _msg;
}

// .SC2APIProtocol.DebugSetUnitValue unit_value = 8;
inline bool DebugCommand::_internal_has_unit_value() const {
  return command_case() == kUnitValue;
}
inline bool DebugCommand::has_unit_value() const {
  return _internal_has_unit_value();
}
inline void DebugCommand::set_has_unit_value() {
  _impl_._oneof_case_[0] = kUnitValue;
}
inline void DebugCommand::clear_unit_value() {
  if (_internal_has_unit_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.unit_value_;
    }
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugSetUnitValue* DebugCommand::release_unit_value() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.unit_value)
  if (_internal_has_unit_value()) {
    clear_has_command();
    ::SC2APIProtocol::DebugSetUnitValue* temp = _impl_.command_.unit_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.unit_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugSetUnitValue& DebugCommand::_internal_unit_value() const {
  return _internal_has_unit_value()
      ? *_impl_.command_.unit_value_
      : reinterpret_cast< ::SC2APIProtocol::DebugSetUnitValue&>(::SC2APIProtocol::_DebugSetUnitValue_default_instance_);
}
inline const ::SC2APIProtocol::DebugSetUnitValue& DebugCommand::unit_value() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.unit_value)
  return _internal_unit_value();
}
inline ::SC2APIProtocol::DebugSetUnitValue* DebugCommand::unsafe_arena_release_unit_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SC2APIProtocol.DebugCommand.unit_value)
  if (_internal_has_unit_value()) {
    clear_has_command();
    ::SC2APIProtocol::DebugSetUnitValue* temp = _impl_.command_.unit_value_;
    _impl_.command_.unit_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugCommand::unsafe_arena_set_allocated_unit_value(::SC2APIProtocol::DebugSetUnitValue* unit_value) {
  clear_command();
  if (unit_value) {
    set_has_unit_value();
    _impl_.command_.unit_value_ = unit_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugCommand.unit_value)
}
inline ::SC2APIProtocol::DebugSetUnitValue* DebugCommand::_internal_mutable_unit_value() {
  if (!_internal_has_unit_value()) {
    clear_command();
    set_has_unit_value();
    _impl_.command_.unit_value_ = CreateMaybeMessage< ::SC2APIProtocol::DebugSetUnitValue >(GetArenaForAllocation());
  }
  return _impl_.command_.unit_value_;
}
inline ::SC2APIProtocol::DebugSetUnitValue* DebugCommand::mutable_unit_value() {
  ::SC2APIProtocol::DebugSetUnitValue* _msg = _internal_mutable_unit_value();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.unit_value)
  return _msg;
}

inline bool DebugCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void DebugCommand::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline DebugCommand::CommandCase DebugCommand::command_case() const {
  return DebugCommand::CommandCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DebugDraw

// repeated .SC2APIProtocol.DebugText text = 1;
inline int DebugDraw::_internal_text_size() const {
  return _impl_.text_.size();
}
inline int DebugDraw::text_size() const {
  return _internal_text_size();
}
inline void DebugDraw::clear_text() {
  _impl_.text_.Clear();
}
inline ::SC2APIProtocol::DebugText* DebugDraw::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugDraw.text)
  return _impl_.text_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText >*
DebugDraw::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugDraw.text)
  return &_impl_.text_;
}
inline const ::SC2APIProtocol::DebugText& DebugDraw::_internal_text(int index) const {
  return _impl_.text_.Get(index);
}
inline const ::SC2APIProtocol::DebugText& DebugDraw::text(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugDraw.text)
  return _internal_text(index);
}
inline ::SC2APIProtocol::DebugText* DebugDraw::_internal_add_text() {
  return _impl_.text_.Add();
}
inline ::SC2APIProtocol::DebugText* DebugDraw::add_text() {
  ::SC2APIProtocol::DebugText* _add = _internal_add_text();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugDraw.text)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText >&
DebugDraw::text() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugDraw.text)
  return _impl_.text_;
}

// repeated .SC2APIProtocol.DebugLine lines = 2;
inline int DebugDraw::_internal_lines_size() const {
  return _impl_.lines_.size();
}
inline int DebugDraw::lines_size() const {
  return _internal_lines_size();
}
inline void DebugDraw::clear_lines() {
  _impl_.lines_.Clear();
}
inline ::SC2APIProtocol::DebugLine* DebugDraw::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugDraw.lines)
  return _impl_.lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine >*
DebugDraw::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugDraw.lines)
  return &_impl_.lines_;
}
inline const ::SC2APIProtocol::DebugLine& DebugDraw::_internal_lines(int index) const {
  return _impl_.lines_.Get(index);
}
inline const ::SC2APIProtocol::DebugLine& DebugDraw::lines(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugDraw.lines)
  return _internal_lines(index);
}
inline ::SC2APIProtocol::DebugLine* DebugDraw::_internal_add_lines() {
  return _impl_.lines_.Add();
}
inline ::SC2APIProtocol::DebugLine* DebugDraw::add_lines() {
  ::SC2APIProtocol::DebugLine* _add = _internal_add_lines();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugDraw.lines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine >&
DebugDraw::lines() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugDraw.lines)
  return _impl_.lines_;
}

// repeated .SC2APIProtocol.DebugBox boxes = 3;
inline int DebugDraw::_internal_boxes_size() const {
  return _impl_.boxes_.size();
}
inline int DebugDraw::boxes_size() const {
  return _internal_boxes_size();
}
inline void DebugDraw::clear_boxes() {
  _impl_.boxes_.Clear();
}
inline ::SC2APIProtocol::DebugBox* DebugDraw::mutable_boxes(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugDraw.boxes)
  return _impl_.boxes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox >*
DebugDraw::mutable_boxes() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugDraw.boxes)
  return &_impl_.boxes_;
}
inline const ::SC2APIProtocol::DebugBox& DebugDraw::_internal_boxes(int index) const {
  return _impl_.boxes_.Get(index);
}
inline const ::SC2APIProtocol::DebugBox& DebugDraw::boxes(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugDraw.boxes)
  return _internal_boxes(index);
}
inline ::SC2APIProtocol::DebugBox* DebugDraw::_internal_add_boxes() {
  return _impl_.boxes_.Add();
}
inline ::SC2APIProtocol::DebugBox* DebugDraw::add_boxes() {
  ::SC2APIProtocol::DebugBox* _add = _internal_add_boxes();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugDraw.boxes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox >&
DebugDraw::boxes() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugDraw.boxes)
  return _impl_.boxes_;
}

// repeated .SC2APIProtocol.DebugSphere spheres = 4;
inline int DebugDraw::_internal_spheres_size() const {
  return _impl_.spheres_.size();
}
inline int DebugDraw::spheres_size() const {
  return _internal_spheres_size();
}
inline void DebugDraw::clear_spheres() {
  _impl_.spheres_.Clear();
}
inline ::SC2APIProtocol::DebugSphere* DebugDraw::mutable_spheres(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugDraw.spheres)
  return _impl_.spheres_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere >*
DebugDraw::mutable_spheres() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugDraw.spheres)
  return &_impl_.spheres_;
}
inline const ::SC2APIProtocol::DebugSphere& DebugDraw::_internal_spheres(int index) const {
  return _impl_.spheres_.Get(index);
}
inline const ::SC2APIProtocol::DebugSphere& DebugDraw::spheres(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugDraw.spheres)
  return _internal_spheres(index);
}
inline ::SC2APIProtocol::DebugSphere* DebugDraw::_internal_add_spheres() {
  return _impl_.spheres_.Add();
}
inline ::SC2APIProtocol::DebugSphere* DebugDraw::add_spheres() {
  ::SC2APIProtocol::DebugSphere* _add = _internal_add_spheres();
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugDraw.spheres)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere >&
DebugDraw::spheres() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugDraw.spheres)
  return _impl_.spheres_;
}

// -------------------------------------------------------------------

// Line

// optional .SC2APIProtocol.Point p0 = 1;
inline bool Line::_internal_has_p0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.p0_ != nullptr);
  return value;
}
inline bool Line::has_p0() const {
  return _internal_has_p0();
}
inline const ::SC2APIProtocol::Point& Line::_internal_p0() const {
  const ::SC2APIProtocol::Point* p = _impl_.p0_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& Line::p0() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Line.p0)
  return _internal_p0();
}
inline void Line::unsafe_arena_set_allocated_p0(
    ::SC2APIProtocol::Point* p0) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p0_);
  }
  _impl_.p0_ = p0;
  if (p0) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.Line.p0)
}
inline ::SC2APIProtocol::Point* Line::release_p0() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.p0_;
  _impl_.p0_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* Line::unsafe_arena_release_p0() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Line.p0)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = _impl_.p0_;
  _impl_.p0_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* Line::_internal_mutable_p0() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.p0_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.p0_ = p;
  }
  return _impl_.p0_;
}
inline ::SC2APIProtocol::Point* Line::mutable_p0() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_p0();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Line.p0)
  return _msg;
}
inline void Line::set_allocated_p0(::SC2APIProtocol::Point* p0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p0_);
  }
  if (p0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p0));
    if (message_arena != submessage_arena) {
      p0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p0, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.p0_ = p0;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Line.p0)
}

// optional .SC2APIProtocol.Point p1 = 2;
inline bool Line::_internal_has_p1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.p1_ != nullptr);
  return value;
}
inline bool Line::has_p1() const {
  return _internal_has_p1();
}
inline const ::SC2APIProtocol::Point& Line::_internal_p1() const {
  const ::SC2APIProtocol::Point* p = _impl_.p1_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& Line::p1() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Line.p1)
  return _internal_p1();
}
inline void Line::unsafe_arena_set_allocated_p1(
    ::SC2APIProtocol::Point* p1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p1_);
  }
  _impl_.p1_ = p1;
  if (p1) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.Line.p1)
}
inline ::SC2APIProtocol::Point* Line::release_p1() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = _impl_.p1_;
  _impl_.p1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* Line::unsafe_arena_release_p1() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Line.p1)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = _impl_.p1_;
  _impl_.p1_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* Line::_internal_mutable_p1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.p1_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.p1_ = p;
  }
  return _impl_.p1_;
}
inline ::SC2APIProtocol::Point* Line::mutable_p1() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_p1();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Line.p1)
  return _msg;
}
inline void Line::set_allocated_p1(::SC2APIProtocol::Point* p1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p1_);
  }
  if (p1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p1));
    if (message_arena != submessage_arena) {
      p1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.p1_ = p1;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Line.p1)
}

// -------------------------------------------------------------------

// Color

// optional uint32 r = 1;
inline bool Color::_internal_has_r() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Color::has_r() const {
  return _internal_has_r();
}
inline void Color::clear_r() {
  _impl_.r_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Color::_internal_r() const {
  return _impl_.r_;
}
inline uint32_t Color::r() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.r_ = value;
}
inline void Color::set_r(uint32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Color.r)
}

// optional uint32 g = 2;
inline bool Color::_internal_has_g() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Color::has_g() const {
  return _internal_has_g();
}
inline void Color::clear_g() {
  _impl_.g_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Color::_internal_g() const {
  return _impl_.g_;
}
inline uint32_t Color::g() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.g_ = value;
}
inline void Color::set_g(uint32_t value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Color.g)
}

// optional uint32 b = 3;
inline bool Color::_internal_has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Color::has_b() const {
  return _internal_has_b();
}
inline void Color::clear_b() {
  _impl_.b_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Color::_internal_b() const {
  return _impl_.b_;
}
inline uint32_t Color::b() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.b_ = value;
}
inline void Color::set_b(uint32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Color.b)
}

// -------------------------------------------------------------------

// DebugText

// optional .SC2APIProtocol.Color color = 1;
inline bool DebugText::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool DebugText::has_color() const {
  return _internal_has_color();
}
inline void DebugText::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::Color& DebugText::_internal_color() const {
  const ::SC2APIProtocol::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Color&>(
      ::SC2APIProtocol::_Color_default_instance_);
}
inline const ::SC2APIProtocol::Color& DebugText::color() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.color)
  return _internal_color();
}
inline void DebugText::unsafe_arena_set_allocated_color(
    ::SC2APIProtocol::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugText.color)
}
inline ::SC2APIProtocol::Color* DebugText::release_color() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Color* DebugText::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugText.color)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Color* DebugText::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::SC2APIProtocol::Color* DebugText::mutable_color() {
  ::SC2APIProtocol::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugText.color)
  return _msg;
}
inline void DebugText::set_allocated_color(::SC2APIProtocol::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugText.color)
}

// optional string text = 2;
inline bool DebugText::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugText::has_text() const {
  return _internal_has_text();
}
inline void DebugText::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DebugText::text() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DebugText::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugText.text)
}
inline std::string* DebugText::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugText.text)
  return _s;
}
inline const std::string& DebugText::_internal_text() const {
  return _impl_.text_.Get();
}
inline void DebugText::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugText::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* DebugText::release_text() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugText.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DebugText::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugText.text)
}

// optional .SC2APIProtocol.Point virtual_pos = 3;
inline bool DebugText::_internal_has_virtual_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.virtual_pos_ != nullptr);
  return value;
}
inline bool DebugText::has_virtual_pos() const {
  return _internal_has_virtual_pos();
}
inline const ::SC2APIProtocol::Point& DebugText::_internal_virtual_pos() const {
  const ::SC2APIProtocol::Point* p = _impl_.virtual_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugText::virtual_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.virtual_pos)
  return _internal_virtual_pos();
}
inline void DebugText::unsafe_arena_set_allocated_virtual_pos(
    ::SC2APIProtocol::Point* virtual_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.virtual_pos_);
  }
  _impl_.virtual_pos_ = virtual_pos;
  if (virtual_pos) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugText.virtual_pos)
}
inline ::SC2APIProtocol::Point* DebugText::release_virtual_pos() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::Point* temp = _impl_.virtual_pos_;
  _impl_.virtual_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* DebugText::unsafe_arena_release_virtual_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugText.virtual_pos)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::Point* temp = _impl_.virtual_pos_;
  _impl_.virtual_pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugText::_internal_mutable_virtual_pos() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.virtual_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.virtual_pos_ = p;
  }
  return _impl_.virtual_pos_;
}
inline ::SC2APIProtocol::Point* DebugText::mutable_virtual_pos() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_virtual_pos();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugText.virtual_pos)
  return _msg;
}
inline void DebugText::set_allocated_virtual_pos(::SC2APIProtocol::Point* virtual_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.virtual_pos_);
  }
  if (virtual_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtual_pos));
    if (message_arena != submessage_arena) {
      virtual_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.virtual_pos_ = virtual_pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugText.virtual_pos)
}

// optional .SC2APIProtocol.Point world_pos = 4;
inline bool DebugText::_internal_has_world_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.world_pos_ != nullptr);
  return value;
}
inline bool DebugText::has_world_pos() const {
  return _internal_has_world_pos();
}
inline const ::SC2APIProtocol::Point& DebugText::_internal_world_pos() const {
  const ::SC2APIProtocol::Point* p = _impl_.world_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugText::world_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.world_pos)
  return _internal_world_pos();
}
inline void DebugText::unsafe_arena_set_allocated_world_pos(
    ::SC2APIProtocol::Point* world_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.world_pos_);
  }
  _impl_.world_pos_ = world_pos;
  if (world_pos) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugText.world_pos)
}
inline ::SC2APIProtocol::Point* DebugText::release_world_pos() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::Point* temp = _impl_.world_pos_;
  _impl_.world_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* DebugText::unsafe_arena_release_world_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugText.world_pos)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::Point* temp = _impl_.world_pos_;
  _impl_.world_pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugText::_internal_mutable_world_pos() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.world_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.world_pos_ = p;
  }
  return _impl_.world_pos_;
}
inline ::SC2APIProtocol::Point* DebugText::mutable_world_pos() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_world_pos();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugText.world_pos)
  return _msg;
}
inline void DebugText::set_allocated_world_pos(::SC2APIProtocol::Point* world_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.world_pos_);
  }
  if (world_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_pos));
    if (message_arena != submessage_arena) {
      world_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.world_pos_ = world_pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugText.world_pos)
}

// optional uint32 size = 5;
inline bool DebugText::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DebugText::has_size() const {
  return _internal_has_size();
}
inline void DebugText::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t DebugText::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t DebugText::size() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.size)
  return _internal_size();
}
inline void DebugText::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.size_ = value;
}
inline void DebugText::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugText.size)
}

// -------------------------------------------------------------------

// DebugLine

// optional .SC2APIProtocol.Color color = 1;
inline bool DebugLine::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool DebugLine::has_color() const {
  return _internal_has_color();
}
inline void DebugLine::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Color& DebugLine::_internal_color() const {
  const ::SC2APIProtocol::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Color&>(
      ::SC2APIProtocol::_Color_default_instance_);
}
inline const ::SC2APIProtocol::Color& DebugLine::color() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugLine.color)
  return _internal_color();
}
inline void DebugLine::unsafe_arena_set_allocated_color(
    ::SC2APIProtocol::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugLine.color)
}
inline ::SC2APIProtocol::Color* DebugLine::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Color* DebugLine::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugLine.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Color* DebugLine::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::SC2APIProtocol::Color* DebugLine::mutable_color() {
  ::SC2APIProtocol::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugLine.color)
  return _msg;
}
inline void DebugLine::set_allocated_color(::SC2APIProtocol::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugLine.color)
}

// optional .SC2APIProtocol.Line line = 2;
inline bool DebugLine::_internal_has_line() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.line_ != nullptr);
  return value;
}
inline bool DebugLine::has_line() const {
  return _internal_has_line();
}
inline void DebugLine::clear_line() {
  if (_impl_.line_ != nullptr) _impl_.line_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::Line& DebugLine::_internal_line() const {
  const ::SC2APIProtocol::Line* p = _impl_.line_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Line&>(
      ::SC2APIProtocol::_Line_default_instance_);
}
inline const ::SC2APIProtocol::Line& DebugLine::line() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugLine.line)
  return _internal_line();
}
inline void DebugLine::unsafe_arena_set_allocated_line(
    ::SC2APIProtocol::Line* line) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.line_);
  }
  _impl_.line_ = line;
  if (line) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugLine.line)
}
inline ::SC2APIProtocol::Line* DebugLine::release_line() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Line* temp = _impl_.line_;
  _impl_.line_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Line* DebugLine::unsafe_arena_release_line() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugLine.line)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Line* temp = _impl_.line_;
  _impl_.line_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Line* DebugLine::_internal_mutable_line() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.line_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Line>(GetArenaForAllocation());
    _impl_.line_ = p;
  }
  return _impl_.line_;
}
inline ::SC2APIProtocol::Line* DebugLine::mutable_line() {
  ::SC2APIProtocol::Line* _msg = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugLine.line)
  return _msg;
}
inline void DebugLine::set_allocated_line(::SC2APIProtocol::Line* line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.line_;
  }
  if (line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(line);
    if (message_arena != submessage_arena) {
      line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, line, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.line_ = line;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugLine.line)
}

// -------------------------------------------------------------------

// DebugBox

// optional .SC2APIProtocol.Color color = 1;
inline bool DebugBox::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool DebugBox::has_color() const {
  return _internal_has_color();
}
inline void DebugBox::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Color& DebugBox::_internal_color() const {
  const ::SC2APIProtocol::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Color&>(
      ::SC2APIProtocol::_Color_default_instance_);
}
inline const ::SC2APIProtocol::Color& DebugBox::color() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugBox.color)
  return _internal_color();
}
inline void DebugBox::unsafe_arena_set_allocated_color(
    ::SC2APIProtocol::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugBox.color)
}
inline ::SC2APIProtocol::Color* DebugBox::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Color* DebugBox::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugBox.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Color* DebugBox::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::SC2APIProtocol::Color* DebugBox::mutable_color() {
  ::SC2APIProtocol::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugBox.color)
  return _msg;
}
inline void DebugBox::set_allocated_color(::SC2APIProtocol::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugBox.color)
}

// optional .SC2APIProtocol.Point min = 2;
inline bool DebugBox::_internal_has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_ != nullptr);
  return value;
}
inline bool DebugBox::has_min() const {
  return _internal_has_min();
}
inline const ::SC2APIProtocol::Point& DebugBox::_internal_min() const {
  const ::SC2APIProtocol::Point* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugBox::min() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugBox.min)
  return _internal_min();
}
inline void DebugBox::unsafe_arena_set_allocated_min(
    ::SC2APIProtocol::Point* min) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = min;
  if (min) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugBox.min)
}
inline ::SC2APIProtocol::Point* DebugBox::release_min() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = _impl_.min_;
  _impl_.min_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* DebugBox::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugBox.min)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugBox::_internal_mutable_min() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.min_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.min_ = p;
  }
  return _impl_.min_;
}
inline ::SC2APIProtocol::Point* DebugBox::mutable_min() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugBox.min)
  return _msg;
}
inline void DebugBox::set_allocated_min(::SC2APIProtocol::Point* min) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  if (min) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min));
    if (message_arena != submessage_arena) {
      min = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.min_ = min;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugBox.min)
}

// optional .SC2APIProtocol.Point max = 3;
inline bool DebugBox::_internal_has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_ != nullptr);
  return value;
}
inline bool DebugBox::has_max() const {
  return _internal_has_max();
}
inline const ::SC2APIProtocol::Point& DebugBox::_internal_max() const {
  const ::SC2APIProtocol::Point* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugBox::max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugBox.max)
  return _internal_max();
}
inline void DebugBox::unsafe_arena_set_allocated_max(
    ::SC2APIProtocol::Point* max) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = max;
  if (max) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugBox.max)
}
inline ::SC2APIProtocol::Point* DebugBox::release_max() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::Point* temp = _impl_.max_;
  _impl_.max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* DebugBox::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugBox.max)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::Point* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugBox::_internal_mutable_max() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.max_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.max_ = p;
  }
  return _impl_.max_;
}
inline ::SC2APIProtocol::Point* DebugBox::mutable_max() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugBox.max)
  return _msg;
}
inline void DebugBox::set_allocated_max(::SC2APIProtocol::Point* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max));
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.max_ = max;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugBox.max)
}

// -------------------------------------------------------------------

// DebugSphere

// optional .SC2APIProtocol.Color color = 1;
inline bool DebugSphere::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool DebugSphere::has_color() const {
  return _internal_has_color();
}
inline void DebugSphere::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Color& DebugSphere::_internal_color() const {
  const ::SC2APIProtocol::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Color&>(
      ::SC2APIProtocol::_Color_default_instance_);
}
inline const ::SC2APIProtocol::Color& DebugSphere::color() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSphere.color)
  return _internal_color();
}
inline void DebugSphere::unsafe_arena_set_allocated_color(
    ::SC2APIProtocol::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugSphere.color)
}
inline ::SC2APIProtocol::Color* DebugSphere::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Color* DebugSphere::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugSphere.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Color* DebugSphere::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::SC2APIProtocol::Color* DebugSphere::mutable_color() {
  ::SC2APIProtocol::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugSphere.color)
  return _msg;
}
inline void DebugSphere::set_allocated_color(::SC2APIProtocol::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugSphere.color)
}

// optional .SC2APIProtocol.Point p = 2;
inline bool DebugSphere::_internal_has_p() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.p_ != nullptr);
  return value;
}
inline bool DebugSphere::has_p() const {
  return _internal_has_p();
}
inline const ::SC2APIProtocol::Point& DebugSphere::_internal_p() const {
  const ::SC2APIProtocol::Point* p = _impl_.p_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point&>(
      ::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugSphere::p() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSphere.p)
  return _internal_p();
}
inline void DebugSphere::unsafe_arena_set_allocated_p(
    ::SC2APIProtocol::Point* p) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p_);
  }
  _impl_.p_ = p;
  if (p) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugSphere.p)
}
inline ::SC2APIProtocol::Point* DebugSphere::release_p() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = _impl_.p_;
  _impl_.p_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point* DebugSphere::unsafe_arena_release_p() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugSphere.p)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = _impl_.p_;
  _impl_.p_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugSphere::_internal_mutable_p() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.p_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaForAllocation());
    _impl_.p_ = p;
  }
  return _impl_.p_;
}
inline ::SC2APIProtocol::Point* DebugSphere::mutable_p() {
  ::SC2APIProtocol::Point* _msg = _internal_mutable_p();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugSphere.p)
  return _msg;
}
inline void DebugSphere::set_allocated_p(::SC2APIProtocol::Point* p) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p_);
  }
  if (p) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p));
    if (message_arena != submessage_arena) {
      p = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.p_ = p;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugSphere.p)
}

// optional float r = 3;
inline bool DebugSphere::_internal_has_r() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DebugSphere::has_r() const {
  return _internal_has_r();
}
inline void DebugSphere::clear_r() {
  _impl_.r_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float DebugSphere::_internal_r() const {
  return _impl_.r_;
}
inline float DebugSphere::r() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSphere.r)
  return _internal_r();
}
inline void DebugSphere::_internal_set_r(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.r_ = value;
}
inline void DebugSphere::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSphere.r)
}

// -------------------------------------------------------------------

// DebugCreateUnit

// optional uint32 unit_type = 1;
inline bool DebugCreateUnit::_internal_has_unit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DebugCreateUnit::has_unit_type() const {
  return _internal_has_unit_type();
}
inline void DebugCreateUnit::clear_unit_type() {
  _impl_.unit_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DebugCreateUnit::_internal_unit_type() const {
  return _impl_.unit_type_;
}
inline uint32_t DebugCreateUnit::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCreateUnit.unit_type)
  return _internal_unit_type();
}
inline void DebugCreateUnit::_internal_set_unit_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.unit_type_ = value;
}
inline void DebugCreateUnit::set_unit_type(uint32_t value) {
  _internal_set_unit_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugCreateUnit.unit_type)
}

// optional int32 owner = 2;
inline bool DebugCreateUnit::_internal_has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DebugCreateUnit::has_owner() const {
  return _internal_has_owner();
}
inline void DebugCreateUnit::clear_owner() {
  _impl_.owner_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DebugCreateUnit::_internal_owner() const {
  return _impl_.owner_;
}
inline int32_t DebugCreateUnit::owner() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCreateUnit.owner)
  return _internal_owner();
}
inline void DebugCreateUnit::_internal_set_owner(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owner_ = value;
}
inline void DebugCreateUnit::set_owner(int32_t value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugCreateUnit.owner)
}

// optional .SC2APIProtocol.Point2D pos = 3;
inline bool DebugCreateUnit::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline bool DebugCreateUnit::has_pos() const {
  return _internal_has_pos();
}
inline const ::SC2APIProtocol::Point2D& DebugCreateUnit::_internal_pos() const {
  const ::SC2APIProtocol::Point2D* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::SC2APIProtocol::Point2D&>(
      ::SC2APIProtocol::_Point2D_default_instance_);
}
inline const ::SC2APIProtocol::Point2D& DebugCreateUnit::pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCreateUnit.pos)
  return _internal_pos();
}
inline void DebugCreateUnit::unsafe_arena_set_allocated_pos(
    ::SC2APIProtocol::Point2D* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SC2APIProtocol.DebugCreateUnit.pos)
}
inline ::SC2APIProtocol::Point2D* DebugCreateUnit::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point2D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SC2APIProtocol::Point2D* DebugCreateUnit::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCreateUnit.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point2D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point2D* DebugCreateUnit::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point2D>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::SC2APIProtocol::Point2D* DebugCreateUnit::mutable_pos() {
  ::SC2APIProtocol::Point2D* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCreateUnit.pos)
  return _msg;
}
inline void DebugCreateUnit::set_allocated_pos(::SC2APIProtocol::Point2D* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos));
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugCreateUnit.pos)
}

// optional uint32 quantity = 4;
inline bool DebugCreateUnit::_internal_has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DebugCreateUnit::has_quantity() const {
  return _internal_has_quantity();
}
inline void DebugCreateUnit::clear_quantity() {
  _impl_.quantity_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t DebugCreateUnit::_internal_quantity() const {
  return _impl_.quantity_;
}
inline uint32_t DebugCreateUnit::quantity() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCreateUnit.quantity)
  return _internal_quantity();
}
inline void DebugCreateUnit::_internal_set_quantity(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.quantity_ = value;
}
inline void DebugCreateUnit::set_quantity(uint32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugCreateUnit.quantity)
}

// -------------------------------------------------------------------

// DebugKillUnit

// repeated uint64 tag = 1;
inline int DebugKillUnit::_internal_tag_size() const {
  return _impl_.tag_.size();
}
inline int DebugKillUnit::tag_size() const {
  return _internal_tag_size();
}
inline void DebugKillUnit::clear_tag() {
  _impl_.tag_.Clear();
}
inline uint64_t DebugKillUnit::_internal_tag(int index) const {
  return _impl_.tag_.Get(index);
}
inline uint64_t DebugKillUnit::tag(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugKillUnit.tag)
  return _internal_tag(index);
}
inline void DebugKillUnit::set_tag(int index, uint64_t value) {
  _impl_.tag_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugKillUnit.tag)
}
inline void DebugKillUnit::_internal_add_tag(uint64_t value) {
  _impl_.tag_.Add(value);
}
inline void DebugKillUnit::add_tag(uint64_t value) {
  _internal_add_tag(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugKillUnit.tag)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
DebugKillUnit::_internal_tag() const {
  return _impl_.tag_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
DebugKillUnit::tag() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugKillUnit.tag)
  return _internal_tag();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
DebugKillUnit::_internal_mutable_tag() {
  return &_impl_.tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
DebugKillUnit::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugKillUnit.tag)
  return _internal_mutable_tag();
}

// -------------------------------------------------------------------

// DebugTestProcess

// optional .SC2APIProtocol.DebugTestProcess.Test test = 1;
inline bool DebugTestProcess::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DebugTestProcess::has_test() const {
  return _internal_has_test();
}
inline void DebugTestProcess::clear_test() {
  _impl_.test_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::DebugTestProcess_Test DebugTestProcess::_internal_test() const {
  return static_cast< ::SC2APIProtocol::DebugTestProcess_Test >(_impl_.test_);
}
inline ::SC2APIProtocol::DebugTestProcess_Test DebugTestProcess::test() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugTestProcess.test)
  return _internal_test();
}
inline void DebugTestProcess::_internal_set_test(::SC2APIProtocol::DebugTestProcess_Test value) {
  assert(::SC2APIProtocol::DebugTestProcess_Test_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.test_ = value;
}
inline void DebugTestProcess::set_test(::SC2APIProtocol::DebugTestProcess_Test value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugTestProcess.test)
}

// optional int32 delay_ms = 2;
inline bool DebugTestProcess::_internal_has_delay_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugTestProcess::has_delay_ms() const {
  return _internal_has_delay_ms();
}
inline void DebugTestProcess::clear_delay_ms() {
  _impl_.delay_ms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t DebugTestProcess::_internal_delay_ms() const {
  return _impl_.delay_ms_;
}
inline int32_t DebugTestProcess::delay_ms() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugTestProcess.delay_ms)
  return _internal_delay_ms();
}
inline void DebugTestProcess::_internal_set_delay_ms(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.delay_ms_ = value;
}
inline void DebugTestProcess::set_delay_ms(int32_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugTestProcess.delay_ms)
}

// -------------------------------------------------------------------

// DebugSetScore

// optional float score = 1;
inline bool DebugSetScore::_internal_has_score() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugSetScore::has_score() const {
  return _internal_has_score();
}
inline void DebugSetScore::clear_score() {
  _impl_.score_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float DebugSetScore::_internal_score() const {
  return _impl_.score_;
}
inline float DebugSetScore::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSetScore.score)
  return _internal_score();
}
inline void DebugSetScore::_internal_set_score(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.score_ = value;
}
inline void DebugSetScore::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSetScore.score)
}

// -------------------------------------------------------------------

// DebugEndGame

// optional .SC2APIProtocol.DebugEndGame.EndResult end_result = 1;
inline bool DebugEndGame::_internal_has_end_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugEndGame::has_end_result() const {
  return _internal_has_end_result();
}
inline void DebugEndGame::clear_end_result() {
  _impl_.end_result_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SC2APIProtocol::DebugEndGame_EndResult DebugEndGame::_internal_end_result() const {
  return static_cast< ::SC2APIProtocol::DebugEndGame_EndResult >(_impl_.end_result_);
}
inline ::SC2APIProtocol::DebugEndGame_EndResult DebugEndGame::end_result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugEndGame.end_result)
  return _internal_end_result();
}
inline void DebugEndGame::_internal_set_end_result(::SC2APIProtocol::DebugEndGame_EndResult value) {
  assert(::SC2APIProtocol::DebugEndGame_EndResult_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.end_result_ = value;
}
inline void DebugEndGame::set_end_result(::SC2APIProtocol::DebugEndGame_EndResult value) {
  _internal_set_end_result(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugEndGame.end_result)
}

// -------------------------------------------------------------------

// DebugSetUnitValue

// optional .SC2APIProtocol.DebugSetUnitValue.UnitValue unit_value = 1;
inline bool DebugSetUnitValue::_internal_has_unit_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DebugSetUnitValue::has_unit_value() const {
  return _internal_has_unit_value();
}
inline void DebugSetUnitValue::clear_unit_value() {
  _impl_.unit_value_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SC2APIProtocol::DebugSetUnitValue_UnitValue DebugSetUnitValue::_internal_unit_value() const {
  return static_cast< ::SC2APIProtocol::DebugSetUnitValue_UnitValue >(_impl_.unit_value_);
}
inline ::SC2APIProtocol::DebugSetUnitValue_UnitValue DebugSetUnitValue::unit_value() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSetUnitValue.unit_value)
  return _internal_unit_value();
}
inline void DebugSetUnitValue::_internal_set_unit_value(::SC2APIProtocol::DebugSetUnitValue_UnitValue value) {
  assert(::SC2APIProtocol::DebugSetUnitValue_UnitValue_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.unit_value_ = value;
}
inline void DebugSetUnitValue::set_unit_value(::SC2APIProtocol::DebugSetUnitValue_UnitValue value) {
  _internal_set_unit_value(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSetUnitValue.unit_value)
}

// optional float value = 2;
inline bool DebugSetUnitValue::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DebugSetUnitValue::has_value() const {
  return _internal_has_value();
}
inline void DebugSetUnitValue::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float DebugSetUnitValue::_internal_value() const {
  return _impl_.value_;
}
inline float DebugSetUnitValue::value() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSetUnitValue.value)
  return _internal_value();
}
inline void DebugSetUnitValue::_internal_set_value(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}
inline void DebugSetUnitValue::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSetUnitValue.value)
}

// optional uint64 unit_tag = 3;
inline bool DebugSetUnitValue::_internal_has_unit_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugSetUnitValue::has_unit_tag() const {
  return _internal_has_unit_tag();
}
inline void DebugSetUnitValue::clear_unit_tag() {
  _impl_.unit_tag_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t DebugSetUnitValue::_internal_unit_tag() const {
  return _impl_.unit_tag_;
}
inline uint64_t DebugSetUnitValue::unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSetUnitValue.unit_tag)
  return _internal_unit_tag();
}
inline void DebugSetUnitValue::_internal_set_unit_tag(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unit_tag_ = value;
}
inline void DebugSetUnitValue::set_unit_tag(uint64_t value) {
  _internal_set_unit_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSetUnitValue.unit_tag)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SC2APIProtocol::DebugTestProcess_Test> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DebugTestProcess_Test>() {
  return ::SC2APIProtocol::DebugTestProcess_Test_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::DebugEndGame_EndResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DebugEndGame_EndResult>() {
  return ::SC2APIProtocol::DebugEndGame_EndResult_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::DebugSetUnitValue_UnitValue> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DebugSetUnitValue_UnitValue>() {
  return ::SC2APIProtocol::DebugSetUnitValue_UnitValue_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::DebugGameState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DebugGameState>() {
  return ::SC2APIProtocol::DebugGameState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdebug_2eproto
