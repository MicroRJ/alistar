// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/raw.proto

#include "s2clientprotocol/raw.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace SC2APIProtocol {
PROTOBUF_CONSTEXPR StartRaw::StartRaw(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_locations_)*/{}
  , /*decltype(_impl_.map_size_)*/nullptr
  , /*decltype(_impl_.pathing_grid_)*/nullptr
  , /*decltype(_impl_.terrain_height_)*/nullptr
  , /*decltype(_impl_.placement_grid_)*/nullptr
  , /*decltype(_impl_.playable_area_)*/nullptr} {}
struct StartRawDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartRawDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartRawDefaultTypeInternal() {}
  union {
    StartRaw _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartRawDefaultTypeInternal _StartRaw_default_instance_;
PROTOBUF_CONSTEXPR ObservationRaw::ObservationRaw(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.units_)*/{}
  , /*decltype(_impl_.effects_)*/{}
  , /*decltype(_impl_.radar_)*/{}
  , /*decltype(_impl_.player_)*/nullptr
  , /*decltype(_impl_.map_state_)*/nullptr
  , /*decltype(_impl_.event_)*/nullptr} {}
struct ObservationRawDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObservationRawDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObservationRawDefaultTypeInternal() {}
  union {
    ObservationRaw _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObservationRawDefaultTypeInternal _ObservationRaw_default_instance_;
PROTOBUF_CONSTEXPR RadarRing::RadarRing(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.radius_)*/0} {}
struct RadarRingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RadarRingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RadarRingDefaultTypeInternal() {}
  union {
    RadarRing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RadarRingDefaultTypeInternal _RadarRing_default_instance_;
PROTOBUF_CONSTEXPR PowerSource::PowerSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.tag_)*/uint64_t{0u}
  , /*decltype(_impl_.radius_)*/0} {}
struct PowerSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PowerSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PowerSourceDefaultTypeInternal() {}
  union {
    PowerSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PowerSourceDefaultTypeInternal _PowerSource_default_instance_;
PROTOBUF_CONSTEXPR PlayerRaw::PlayerRaw(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.power_sources_)*/{}
  , /*decltype(_impl_.upgrade_ids_)*/{}
  , /*decltype(_impl_.camera_)*/nullptr} {}
struct PlayerRawDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerRawDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerRawDefaultTypeInternal() {}
  union {
    PlayerRaw _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerRawDefaultTypeInternal _PlayerRaw_default_instance_;
PROTOBUF_CONSTEXPR UnitOrder::UnitOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ability_id_)*/0u
  , /*decltype(_impl_.progress_)*/0
  , /*decltype(_impl_.target_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct UnitOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnitOrderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnitOrderDefaultTypeInternal() {}
  union {
    UnitOrder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnitOrderDefaultTypeInternal _UnitOrder_default_instance_;
PROTOBUF_CONSTEXPR PassengerUnit::PassengerUnit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/uint64_t{0u}
  , /*decltype(_impl_.health_)*/0
  , /*decltype(_impl_.health_max_)*/0
  , /*decltype(_impl_.shield_)*/0
  , /*decltype(_impl_.energy_)*/0
  , /*decltype(_impl_.unit_type_)*/0u
  , /*decltype(_impl_.shield_max_)*/0
  , /*decltype(_impl_.energy_max_)*/0} {}
struct PassengerUnitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PassengerUnitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PassengerUnitDefaultTypeInternal() {}
  union {
    PassengerUnit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PassengerUnitDefaultTypeInternal _PassengerUnit_default_instance_;
PROTOBUF_CONSTEXPR RallyTarget::RallyTarget(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.tag_)*/uint64_t{0u}} {}
struct RallyTargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RallyTargetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RallyTargetDefaultTypeInternal() {}
  union {
    RallyTarget _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RallyTargetDefaultTypeInternal _RallyTarget_default_instance_;
PROTOBUF_CONSTEXPR Unit::Unit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.orders_)*/{}
  , /*decltype(_impl_.passengers_)*/{}
  , /*decltype(_impl_.buff_ids_)*/{}
  , /*decltype(_impl_.rally_targets_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.tag_)*/uint64_t{0u}
  , /*decltype(_impl_.unit_type_)*/0u
  , /*decltype(_impl_.owner_)*/0
  , /*decltype(_impl_.facing_)*/0
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.build_progress_)*/0
  , /*decltype(_impl_.cloak_)*/0
  , /*decltype(_impl_.health_)*/0
  , /*decltype(_impl_.health_max_)*/0
  , /*decltype(_impl_.shield_)*/0
  , /*decltype(_impl_.energy_)*/0
  , /*decltype(_impl_.is_selected_)*/false
  , /*decltype(_impl_.is_on_screen_)*/false
  , /*decltype(_impl_.is_blip_)*/false
  , /*decltype(_impl_.is_powered_)*/false
  , /*decltype(_impl_.mineral_contents_)*/0
  , /*decltype(_impl_.vespene_contents_)*/0
  , /*decltype(_impl_.cargo_space_taken_)*/0
  , /*decltype(_impl_.add_on_tag_)*/uint64_t{0u}
  , /*decltype(_impl_.cargo_space_max_)*/0
  , /*decltype(_impl_.assigned_harvesters_)*/0
  , /*decltype(_impl_.ideal_harvesters_)*/0
  , /*decltype(_impl_.is_active_)*/false
  , /*decltype(_impl_.is_flying_)*/false
  , /*decltype(_impl_.is_burrowed_)*/false
  , /*decltype(_impl_.is_hallucination_)*/false
  , /*decltype(_impl_.weapon_cooldown_)*/0
  , /*decltype(_impl_.detect_range_)*/0
  , /*decltype(_impl_.engaged_target_tag_)*/uint64_t{0u}
  , /*decltype(_impl_.radar_range_)*/0
  , /*decltype(_impl_.shield_max_)*/0
  , /*decltype(_impl_.energy_max_)*/0
  , /*decltype(_impl_.attack_upgrade_level_)*/0
  , /*decltype(_impl_.armor_upgrade_level_)*/0
  , /*decltype(_impl_.shield_upgrade_level_)*/0
  , /*decltype(_impl_.buff_duration_remain_)*/0
  , /*decltype(_impl_.buff_duration_max_)*/0
  , /*decltype(_impl_.display_type_)*/1
  , /*decltype(_impl_.alliance_)*/1} {}
struct UnitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnitDefaultTypeInternal() {}
  union {
    Unit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnitDefaultTypeInternal _Unit_default_instance_;
PROTOBUF_CONSTEXPR MapState::MapState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.visibility_)*/nullptr
  , /*decltype(_impl_.creep_)*/nullptr} {}
struct MapStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapStateDefaultTypeInternal() {}
  union {
    MapState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapStateDefaultTypeInternal _MapState_default_instance_;
PROTOBUF_CONSTEXPR Event::Event(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dead_units_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventDefaultTypeInternal() {}
  union {
    Event _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventDefaultTypeInternal _Event_default_instance_;
PROTOBUF_CONSTEXPR Effect::Effect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/{}
  , /*decltype(_impl_.effect_id_)*/0u
  , /*decltype(_impl_.owner_)*/0
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.alliance_)*/1} {}
struct EffectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EffectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EffectDefaultTypeInternal() {}
  union {
    Effect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EffectDefaultTypeInternal _Effect_default_instance_;
PROTOBUF_CONSTEXPR ActionRaw::ActionRaw(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.action_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ActionRawDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionRawDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionRawDefaultTypeInternal() {}
  union {
    ActionRaw _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionRawDefaultTypeInternal _ActionRaw_default_instance_;
PROTOBUF_CONSTEXPR ActionRawUnitCommand::ActionRawUnitCommand(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unit_tags_)*/{}
  , /*decltype(_impl_.ability_id_)*/0
  , /*decltype(_impl_.queue_command_)*/false
  , /*decltype(_impl_.target_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ActionRawUnitCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionRawUnitCommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionRawUnitCommandDefaultTypeInternal() {}
  union {
    ActionRawUnitCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionRawUnitCommandDefaultTypeInternal _ActionRawUnitCommand_default_instance_;
PROTOBUF_CONSTEXPR ActionRawCameraMove::ActionRawCameraMove(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.center_world_space_)*/nullptr} {}
struct ActionRawCameraMoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionRawCameraMoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionRawCameraMoveDefaultTypeInternal() {}
  union {
    ActionRawCameraMove _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionRawCameraMoveDefaultTypeInternal _ActionRawCameraMove_default_instance_;
PROTOBUF_CONSTEXPR ActionRawToggleAutocast::ActionRawToggleAutocast(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unit_tags_)*/{}
  , /*decltype(_impl_.ability_id_)*/0} {}
struct ActionRawToggleAutocastDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionRawToggleAutocastDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionRawToggleAutocastDefaultTypeInternal() {}
  union {
    ActionRawToggleAutocast _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionRawToggleAutocastDefaultTypeInternal _ActionRawToggleAutocast_default_instance_;
}  // namespace SC2APIProtocol
static ::_pb::Metadata file_level_metadata_s2clientprotocol_2fraw_2eproto[16];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_s2clientprotocol_2fraw_2eproto = nullptr;

const uint32_t TableStruct_s2clientprotocol_2fraw_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _impl_.map_size_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _impl_.pathing_grid_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _impl_.terrain_height_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _impl_.placement_grid_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _impl_.playable_area_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _impl_.start_locations_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _impl_.player_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _impl_.units_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _impl_.map_state_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _impl_.event_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _impl_.effects_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _impl_.radar_),
  0,
  ~0u,
  1,
  2,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RadarRing, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RadarRing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RadarRing, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RadarRing, _impl_.radius_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, _impl_.tag_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, _impl_.power_sources_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, _impl_.camera_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, _impl_.upgrade_ids_),
  ~0u,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _impl_.ability_id_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _impl_.progress_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _impl_.target_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_.tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_.health_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_.health_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_.shield_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_.shield_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_.energy_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_.energy_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _impl_.unit_type_),
  0,
  1,
  2,
  3,
  6,
  4,
  7,
  5,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RallyTarget, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RallyTarget, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RallyTarget, _impl_.point_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RallyTarget, _impl_.tag_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.display_type_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.alliance_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.unit_type_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.owner_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.facing_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.build_progress_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.cloak_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.buff_ids_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.detect_range_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.radar_range_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.is_selected_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.is_on_screen_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.is_blip_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.is_powered_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.is_active_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.attack_upgrade_level_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.armor_upgrade_level_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.shield_upgrade_level_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.health_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.health_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.shield_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.shield_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.energy_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.energy_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.mineral_contents_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.vespene_contents_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.is_flying_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.is_burrowed_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.is_hallucination_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.orders_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.add_on_tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.passengers_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.cargo_space_taken_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.cargo_space_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.assigned_harvesters_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.ideal_harvesters_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.weapon_cooldown_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.engaged_target_tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.buff_duration_remain_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.buff_duration_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _impl_.rally_targets_),
  38,
  39,
  1,
  2,
  3,
  0,
  4,
  5,
  6,
  7,
  ~0u,
  28,
  30,
  12,
  13,
  14,
  15,
  23,
  33,
  34,
  35,
  8,
  9,
  10,
  31,
  11,
  32,
  16,
  17,
  24,
  25,
  26,
  ~0u,
  19,
  ~0u,
  18,
  20,
  21,
  22,
  27,
  29,
  36,
  37,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::MapState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::MapState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::MapState, _impl_.visibility_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::MapState, _impl_.creep_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Event, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Event, _impl_.dead_units_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _impl_.effect_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _impl_.alliance_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _impl_.owner_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _impl_.radius_),
  0,
  ~0u,
  3,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRaw, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRaw, _impl_.action_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _impl_.ability_id_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _impl_.unit_tags_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _impl_.queue_command_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _impl_.target_),
  0,
  ~0u,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawCameraMove, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawCameraMove, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawCameraMove, _impl_.center_world_space_),
  0,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawToggleAutocast, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawToggleAutocast, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawToggleAutocast, _impl_.ability_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawToggleAutocast, _impl_.unit_tags_),
  0,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::SC2APIProtocol::StartRaw)},
  { 18, 30, -1, sizeof(::SC2APIProtocol::ObservationRaw)},
  { 36, 44, -1, sizeof(::SC2APIProtocol::RadarRing)},
  { 46, 55, -1, sizeof(::SC2APIProtocol::PowerSource)},
  { 58, 67, -1, sizeof(::SC2APIProtocol::PlayerRaw)},
  { 70, 81, -1, sizeof(::SC2APIProtocol::UnitOrder)},
  { 85, 99, -1, sizeof(::SC2APIProtocol::PassengerUnit)},
  { 107, 115, -1, sizeof(::SC2APIProtocol::RallyTarget)},
  { 117, 167, -1, sizeof(::SC2APIProtocol::Unit)},
  { 211, 219, -1, sizeof(::SC2APIProtocol::MapState)},
  { 221, -1, -1, sizeof(::SC2APIProtocol::Event)},
  { 228, 239, -1, sizeof(::SC2APIProtocol::Effect)},
  { 244, -1, -1, sizeof(::SC2APIProtocol::ActionRaw)},
  { 254, 266, -1, sizeof(::SC2APIProtocol::ActionRawUnitCommand)},
  { 271, 278, -1, sizeof(::SC2APIProtocol::ActionRawCameraMove)},
  { 279, 287, -1, sizeof(::SC2APIProtocol::ActionRawToggleAutocast)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::SC2APIProtocol::_StartRaw_default_instance_._instance,
  &::SC2APIProtocol::_ObservationRaw_default_instance_._instance,
  &::SC2APIProtocol::_RadarRing_default_instance_._instance,
  &::SC2APIProtocol::_PowerSource_default_instance_._instance,
  &::SC2APIProtocol::_PlayerRaw_default_instance_._instance,
  &::SC2APIProtocol::_UnitOrder_default_instance_._instance,
  &::SC2APIProtocol::_PassengerUnit_default_instance_._instance,
  &::SC2APIProtocol::_RallyTarget_default_instance_._instance,
  &::SC2APIProtocol::_Unit_default_instance_._instance,
  &::SC2APIProtocol::_MapState_default_instance_._instance,
  &::SC2APIProtocol::_Event_default_instance_._instance,
  &::SC2APIProtocol::_Effect_default_instance_._instance,
  &::SC2APIProtocol::_ActionRaw_default_instance_._instance,
  &::SC2APIProtocol::_ActionRawUnitCommand_default_instance_._instance,
  &::SC2APIProtocol::_ActionRawCameraMove_default_instance_._instance,
  &::SC2APIProtocol::_ActionRawToggleAutocast_default_instance_._instance,
};

const char descriptor_table_protodef_s2clientprotocol_2fraw_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\032s2clientprotocol/raw.proto\022\016SC2APIProt"
  "ocol\032\035s2clientprotocol/common.proto\"\261\002\n\010"
  "StartRaw\022)\n\010map_size\030\001 \001(\0132\027.SC2APIProto"
  "col.Size2DI\022/\n\014pathing_grid\030\002 \001(\0132\031.SC2A"
  "PIProtocol.ImageData\0221\n\016terrain_height\030\003"
  " \001(\0132\031.SC2APIProtocol.ImageData\0221\n\016place"
  "ment_grid\030\004 \001(\0132\031.SC2APIProtocol.ImageDa"
  "ta\0221\n\rplayable_area\030\005 \001(\0132\032.SC2APIProtoc"
  "ol.RectangleI\0220\n\017start_locations\030\006 \003(\0132\027"
  ".SC2APIProtocol.Point2D\"\206\002\n\016ObservationR"
  "aw\022)\n\006player\030\001 \001(\0132\031.SC2APIProtocol.Play"
  "erRaw\022#\n\005units\030\002 \003(\0132\024.SC2APIProtocol.Un"
  "it\022+\n\tmap_state\030\003 \001(\0132\030.SC2APIProtocol.M"
  "apState\022$\n\005event\030\004 \001(\0132\025.SC2APIProtocol."
  "Event\022\'\n\007effects\030\005 \003(\0132\026.SC2APIProtocol."
  "Effect\022(\n\005radar\030\006 \003(\0132\031.SC2APIProtocol.R"
  "adarRing\"\?\n\tRadarRing\022\"\n\003pos\030\001 \001(\0132\025.SC2"
  "APIProtocol.Point\022\016\n\006radius\030\002 \001(\002\"N\n\013Pow"
  "erSource\022\"\n\003pos\030\001 \001(\0132\025.SC2APIProtocol.P"
  "oint\022\016\n\006radius\030\002 \001(\002\022\013\n\003tag\030\003 \001(\004\"{\n\tPla"
  "yerRaw\0222\n\rpower_sources\030\001 \003(\0132\033.SC2APIPr"
  "otocol.PowerSource\022%\n\006camera\030\002 \001(\0132\025.SC2"
  "APIProtocol.Point\022\023\n\013upgrade_ids\030\003 \003(\r\"\217"
  "\001\n\tUnitOrder\022\022\n\nability_id\030\001 \001(\r\0227\n\026targ"
  "et_world_space_pos\030\002 \001(\0132\025.SC2APIProtoco"
  "l.PointH\000\022\031\n\017target_unit_tag\030\003 \001(\004H\000\022\020\n\010"
  "progress\030\004 \001(\002B\010\n\006target\"\233\001\n\rPassengerUn"
  "it\022\013\n\003tag\030\001 \001(\004\022\016\n\006health\030\002 \001(\002\022\022\n\nhealt"
  "h_max\030\003 \001(\002\022\016\n\006shield\030\004 \001(\002\022\022\n\nshield_ma"
  "x\030\007 \001(\002\022\016\n\006energy\030\005 \001(\002\022\022\n\nenergy_max\030\010 "
  "\001(\002\022\021\n\tunit_type\030\006 \001(\r\"@\n\013RallyTarget\022$\n"
  "\005point\030\001 \001(\0132\025.SC2APIProtocol.Point\022\013\n\003t"
  "ag\030\002 \001(\004\"\365\010\n\004Unit\0221\n\014display_type\030\001 \001(\0162"
  "\033.SC2APIProtocol.DisplayType\022*\n\010alliance"
  "\030\002 \001(\0162\030.SC2APIProtocol.Alliance\022\013\n\003tag\030"
  "\003 \001(\004\022\021\n\tunit_type\030\004 \001(\r\022\r\n\005owner\030\005 \001(\005\022"
  "\"\n\003pos\030\006 \001(\0132\025.SC2APIProtocol.Point\022\016\n\006f"
  "acing\030\007 \001(\002\022\016\n\006radius\030\010 \001(\002\022\026\n\016build_pro"
  "gress\030\t \001(\002\022)\n\005cloak\030\n \001(\0162\032.SC2APIProto"
  "col.CloakState\022\020\n\010buff_ids\030\033 \003(\r\022\024\n\014dete"
  "ct_range\030\037 \001(\002\022\023\n\013radar_range\030  \001(\002\022\023\n\013i"
  "s_selected\030\013 \001(\010\022\024\n\014is_on_screen\030\014 \001(\010\022\017"
  "\n\007is_blip\030\r \001(\010\022\022\n\nis_powered\030# \001(\010\022\021\n\ti"
  "s_active\030\' \001(\010\022\034\n\024attack_upgrade_level\030("
  " \001(\005\022\033\n\023armor_upgrade_level\030) \001(\005\022\034\n\024shi"
  "eld_upgrade_level\030* \001(\005\022\016\n\006health\030\016 \001(\002\022"
  "\022\n\nhealth_max\030\017 \001(\002\022\016\n\006shield\030\020 \001(\002\022\022\n\ns"
  "hield_max\030$ \001(\002\022\016\n\006energy\030\021 \001(\002\022\022\n\nenerg"
  "y_max\030% \001(\002\022\030\n\020mineral_contents\030\022 \001(\005\022\030\n"
  "\020vespene_contents\030\023 \001(\005\022\021\n\tis_flying\030\024 \001"
  "(\010\022\023\n\013is_burrowed\030\025 \001(\010\022\030\n\020is_hallucinat"
  "ion\030& \001(\010\022)\n\006orders\030\026 \003(\0132\031.SC2APIProtoc"
  "ol.UnitOrder\022\022\n\nadd_on_tag\030\027 \001(\004\0221\n\npass"
  "engers\030\030 \003(\0132\035.SC2APIProtocol.PassengerU"
  "nit\022\031\n\021cargo_space_taken\030\031 \001(\005\022\027\n\017cargo_"
  "space_max\030\032 \001(\005\022\033\n\023assigned_harvesters\030\034"
  " \001(\005\022\030\n\020ideal_harvesters\030\035 \001(\005\022\027\n\017weapon"
  "_cooldown\030\036 \001(\002\022\032\n\022engaged_target_tag\030\" "
  "\001(\004\022\034\n\024buff_duration_remain\030+ \001(\005\022\031\n\021buf"
  "f_duration_max\030, \001(\005\0222\n\rrally_targets\030- "
  "\003(\0132\033.SC2APIProtocol.RallyTarget\"c\n\010MapS"
  "tate\022-\n\nvisibility\030\001 \001(\0132\031.SC2APIProtoco"
  "l.ImageData\022(\n\005creep\030\002 \001(\0132\031.SC2APIProto"
  "col.ImageData\"\033\n\005Event\022\022\n\ndead_units\030\001 \003"
  "(\004\"\214\001\n\006Effect\022\021\n\teffect_id\030\001 \001(\r\022$\n\003pos\030"
  "\002 \003(\0132\027.SC2APIProtocol.Point2D\022*\n\010allian"
  "ce\030\003 \001(\0162\030.SC2APIProtocol.Alliance\022\r\n\005ow"
  "ner\030\004 \001(\005\022\016\n\006radius\030\005 \001(\002\"\323\001\n\tActionRaw\022"
  "<\n\014unit_command\030\001 \001(\0132$.SC2APIProtocol.A"
  "ctionRawUnitCommandH\000\022:\n\013camera_move\030\002 \001"
  "(\0132#.SC2APIProtocol.ActionRawCameraMoveH"
  "\000\022B\n\017toggle_autocast\030\003 \001(\0132\'.SC2APIProto"
  "col.ActionRawToggleAutocastH\000B\010\n\006action\""
  "\264\001\n\024ActionRawUnitCommand\022\022\n\nability_id\030\001"
  " \001(\005\0229\n\026target_world_space_pos\030\002 \001(\0132\027.S"
  "C2APIProtocol.Point2DH\000\022\031\n\017target_unit_t"
  "ag\030\003 \001(\004H\000\022\021\n\tunit_tags\030\004 \003(\004\022\025\n\rqueue_c"
  "ommand\030\005 \001(\010B\010\n\006target\"H\n\023ActionRawCamer"
  "aMove\0221\n\022center_world_space\030\001 \001(\0132\025.SC2A"
  "PIProtocol.Point\"@\n\027ActionRawToggleAutoc"
  "ast\022\022\n\nability_id\030\001 \001(\005\022\021\n\tunit_tags\030\002 \003"
  "(\004*E\n\013DisplayType\022\013\n\007Visible\020\001\022\014\n\010Snapsh"
  "ot\020\002\022\n\n\006Hidden\020\003\022\017\n\013Placeholder\020\004*6\n\010All"
  "iance\022\010\n\004Self\020\001\022\010\n\004Ally\020\002\022\013\n\007Neutral\020\003\022\t"
  "\n\005Enemy\020\004*e\n\nCloakState\022\022\n\016CloakedUnknow"
  "n\020\000\022\013\n\007Cloaked\020\001\022\023\n\017CloakedDetected\020\002\022\016\n"
  "\nNotCloaked\020\003\022\021\n\rCloakedAllied\020\004"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_s2clientprotocol_2fraw_2eproto_deps[1] = {
  &::descriptor_table_s2clientprotocol_2fcommon_2eproto,
};
static ::_pbi::once_flag descriptor_table_s2clientprotocol_2fraw_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_s2clientprotocol_2fraw_2eproto = {
    false, false, 3472, descriptor_table_protodef_s2clientprotocol_2fraw_2eproto,
    "s2clientprotocol/raw.proto",
    &descriptor_table_s2clientprotocol_2fraw_2eproto_once, descriptor_table_s2clientprotocol_2fraw_2eproto_deps, 1, 16,
    schemas, file_default_instances, TableStruct_s2clientprotocol_2fraw_2eproto::offsets,
    file_level_metadata_s2clientprotocol_2fraw_2eproto, file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto,
    file_level_service_descriptors_s2clientprotocol_2fraw_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_s2clientprotocol_2fraw_2eproto_getter() {
  return &descriptor_table_s2clientprotocol_2fraw_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_s2clientprotocol_2fraw_2eproto(&descriptor_table_s2clientprotocol_2fraw_2eproto);
namespace SC2APIProtocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DisplayType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fraw_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto[0];
}
bool DisplayType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alliance_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fraw_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto[1];
}
bool Alliance_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CloakState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fraw_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto[2];
}
bool CloakState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class StartRaw::_Internal {
 public:
  using HasBits = decltype(std::declval<StartRaw>()._impl_._has_bits_);
  static const ::SC2APIProtocol::Size2DI& map_size(const StartRaw* msg);
  static void set_has_map_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::ImageData& pathing_grid(const StartRaw* msg);
  static void set_has_pathing_grid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SC2APIProtocol::ImageData& terrain_height(const StartRaw* msg);
  static void set_has_terrain_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::SC2APIProtocol::ImageData& placement_grid(const StartRaw* msg);
  static void set_has_placement_grid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::SC2APIProtocol::RectangleI& playable_area(const StartRaw* msg);
  static void set_has_playable_area(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::SC2APIProtocol::Size2DI&
StartRaw::_Internal::map_size(const StartRaw* msg) {
  return *msg->_impl_.map_size_;
}
const ::SC2APIProtocol::ImageData&
StartRaw::_Internal::pathing_grid(const StartRaw* msg) {
  return *msg->_impl_.pathing_grid_;
}
const ::SC2APIProtocol::ImageData&
StartRaw::_Internal::terrain_height(const StartRaw* msg) {
  return *msg->_impl_.terrain_height_;
}
const ::SC2APIProtocol::ImageData&
StartRaw::_Internal::placement_grid(const StartRaw* msg) {
  return *msg->_impl_.placement_grid_;
}
const ::SC2APIProtocol::RectangleI&
StartRaw::_Internal::playable_area(const StartRaw* msg) {
  return *msg->_impl_.playable_area_;
}
void StartRaw::clear_map_size() {
  if (_impl_.map_size_ != nullptr) _impl_.map_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void StartRaw::clear_pathing_grid() {
  if (_impl_.pathing_grid_ != nullptr) _impl_.pathing_grid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void StartRaw::clear_terrain_height() {
  if (_impl_.terrain_height_ != nullptr) _impl_.terrain_height_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void StartRaw::clear_placement_grid() {
  if (_impl_.placement_grid_ != nullptr) _impl_.placement_grid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void StartRaw::clear_playable_area() {
  if (_impl_.playable_area_ != nullptr) _impl_.playable_area_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void StartRaw::clear_start_locations() {
  _impl_.start_locations_.Clear();
}
StartRaw::StartRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.StartRaw)
}
StartRaw::StartRaw(const StartRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StartRaw* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_locations_){from._impl_.start_locations_}
    , decltype(_impl_.map_size_){nullptr}
    , decltype(_impl_.pathing_grid_){nullptr}
    , decltype(_impl_.terrain_height_){nullptr}
    , decltype(_impl_.placement_grid_){nullptr}
    , decltype(_impl_.playable_area_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_map_size()) {
    _this->_impl_.map_size_ = new ::SC2APIProtocol::Size2DI(*from._impl_.map_size_);
  }
  if (from._internal_has_pathing_grid()) {
    _this->_impl_.pathing_grid_ = new ::SC2APIProtocol::ImageData(*from._impl_.pathing_grid_);
  }
  if (from._internal_has_terrain_height()) {
    _this->_impl_.terrain_height_ = new ::SC2APIProtocol::ImageData(*from._impl_.terrain_height_);
  }
  if (from._internal_has_placement_grid()) {
    _this->_impl_.placement_grid_ = new ::SC2APIProtocol::ImageData(*from._impl_.placement_grid_);
  }
  if (from._internal_has_playable_area()) {
    _this->_impl_.playable_area_ = new ::SC2APIProtocol::RectangleI(*from._impl_.playable_area_);
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.StartRaw)
}

inline void StartRaw::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_locations_){arena}
    , decltype(_impl_.map_size_){nullptr}
    , decltype(_impl_.pathing_grid_){nullptr}
    , decltype(_impl_.terrain_height_){nullptr}
    , decltype(_impl_.placement_grid_){nullptr}
    , decltype(_impl_.playable_area_){nullptr}
  };
}

StartRaw::~StartRaw() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.StartRaw)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StartRaw::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.start_locations_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.map_size_;
  if (this != internal_default_instance()) delete _impl_.pathing_grid_;
  if (this != internal_default_instance()) delete _impl_.terrain_height_;
  if (this != internal_default_instance()) delete _impl_.placement_grid_;
  if (this != internal_default_instance()) delete _impl_.playable_area_;
}

void StartRaw::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StartRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.StartRaw)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.start_locations_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.map_size_ != nullptr);
      _impl_.map_size_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pathing_grid_ != nullptr);
      _impl_.pathing_grid_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.terrain_height_ != nullptr);
      _impl_.terrain_height_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.placement_grid_ != nullptr);
      _impl_.placement_grid_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.playable_area_ != nullptr);
      _impl_.playable_area_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StartRaw::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Size2DI map_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ImageData pathing_grid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pathing_grid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ImageData terrain_height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_terrain_height(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ImageData placement_grid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_placement_grid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.RectangleI playable_area = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_playable_area(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Point2D start_locations = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_start_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartRaw::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.StartRaw)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.Size2DI map_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::map_size(this),
        _Internal::map_size(this).GetCachedSize(), target, stream);
  }

  // optional .SC2APIProtocol.ImageData pathing_grid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pathing_grid(this),
        _Internal::pathing_grid(this).GetCachedSize(), target, stream);
  }

  // optional .SC2APIProtocol.ImageData terrain_height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::terrain_height(this),
        _Internal::terrain_height(this).GetCachedSize(), target, stream);
  }

  // optional .SC2APIProtocol.ImageData placement_grid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::placement_grid(this),
        _Internal::placement_grid(this).GetCachedSize(), target, stream);
  }

  // optional .SC2APIProtocol.RectangleI playable_area = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::playable_area(this),
        _Internal::playable_area(this).GetCachedSize(), target, stream);
  }

  // repeated .SC2APIProtocol.Point2D start_locations = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_start_locations_size()); i < n; i++) {
    const auto& repfield = this->_internal_start_locations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.StartRaw)
  return target;
}

size_t StartRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.StartRaw)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.Point2D start_locations = 6;
  total_size += 1UL * this->_internal_start_locations_size();
  for (const auto& msg : this->_impl_.start_locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .SC2APIProtocol.Size2DI map_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.map_size_);
    }

    // optional .SC2APIProtocol.ImageData pathing_grid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pathing_grid_);
    }

    // optional .SC2APIProtocol.ImageData terrain_height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.terrain_height_);
    }

    // optional .SC2APIProtocol.ImageData placement_grid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.placement_grid_);
    }

    // optional .SC2APIProtocol.RectangleI playable_area = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.playable_area_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StartRaw::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StartRaw::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StartRaw::GetClassData() const { return &_class_data_; }


void StartRaw::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StartRaw*>(&to_msg);
  auto& from = static_cast<const StartRaw&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.StartRaw)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.start_locations_.MergeFrom(from._impl_.start_locations_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_map_size()->::SC2APIProtocol::Size2DI::MergeFrom(
          from._internal_map_size());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pathing_grid()->::SC2APIProtocol::ImageData::MergeFrom(
          from._internal_pathing_grid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_terrain_height()->::SC2APIProtocol::ImageData::MergeFrom(
          from._internal_terrain_height());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_placement_grid()->::SC2APIProtocol::ImageData::MergeFrom(
          from._internal_placement_grid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_playable_area()->::SC2APIProtocol::RectangleI::MergeFrom(
          from._internal_playable_area());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StartRaw::CopyFrom(const StartRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.StartRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartRaw::IsInitialized() const {
  return true;
}

void StartRaw::InternalSwap(StartRaw* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.start_locations_.InternalSwap(&other->_impl_.start_locations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartRaw, _impl_.playable_area_)
      + sizeof(StartRaw::_impl_.playable_area_)
      - PROTOBUF_FIELD_OFFSET(StartRaw, _impl_.map_size_)>(
          reinterpret_cast<char*>(&_impl_.map_size_),
          reinterpret_cast<char*>(&other->_impl_.map_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StartRaw::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[0]);
}

// ===================================================================

class ObservationRaw::_Internal {
 public:
  using HasBits = decltype(std::declval<ObservationRaw>()._impl_._has_bits_);
  static const ::SC2APIProtocol::PlayerRaw& player(const ObservationRaw* msg);
  static void set_has_player(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::MapState& map_state(const ObservationRaw* msg);
  static void set_has_map_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SC2APIProtocol::Event& event(const ObservationRaw* msg);
  static void set_has_event(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::SC2APIProtocol::PlayerRaw&
ObservationRaw::_Internal::player(const ObservationRaw* msg) {
  return *msg->_impl_.player_;
}
const ::SC2APIProtocol::MapState&
ObservationRaw::_Internal::map_state(const ObservationRaw* msg) {
  return *msg->_impl_.map_state_;
}
const ::SC2APIProtocol::Event&
ObservationRaw::_Internal::event(const ObservationRaw* msg) {
  return *msg->_impl_.event_;
}
ObservationRaw::ObservationRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.ObservationRaw)
}
ObservationRaw::ObservationRaw(const ObservationRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObservationRaw* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.units_){from._impl_.units_}
    , decltype(_impl_.effects_){from._impl_.effects_}
    , decltype(_impl_.radar_){from._impl_.radar_}
    , decltype(_impl_.player_){nullptr}
    , decltype(_impl_.map_state_){nullptr}
    , decltype(_impl_.event_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_player()) {
    _this->_impl_.player_ = new ::SC2APIProtocol::PlayerRaw(*from._impl_.player_);
  }
  if (from._internal_has_map_state()) {
    _this->_impl_.map_state_ = new ::SC2APIProtocol::MapState(*from._impl_.map_state_);
  }
  if (from._internal_has_event()) {
    _this->_impl_.event_ = new ::SC2APIProtocol::Event(*from._impl_.event_);
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ObservationRaw)
}

inline void ObservationRaw::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.units_){arena}
    , decltype(_impl_.effects_){arena}
    , decltype(_impl_.radar_){arena}
    , decltype(_impl_.player_){nullptr}
    , decltype(_impl_.map_state_){nullptr}
    , decltype(_impl_.event_){nullptr}
  };
}

ObservationRaw::~ObservationRaw() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ObservationRaw)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObservationRaw::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.units_.~RepeatedPtrField();
  _impl_.effects_.~RepeatedPtrField();
  _impl_.radar_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.player_;
  if (this != internal_default_instance()) delete _impl_.map_state_;
  if (this != internal_default_instance()) delete _impl_.event_;
}

void ObservationRaw::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObservationRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ObservationRaw)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.units_.Clear();
  _impl_.effects_.Clear();
  _impl_.radar_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.player_ != nullptr);
      _impl_.player_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.map_state_ != nullptr);
      _impl_.map_state_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.event_ != nullptr);
      _impl_.event_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObservationRaw::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.PlayerRaw player = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Unit units = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_units(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.MapState map_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Event event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Effect effects = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_effects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.RadarRing radar = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_radar(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObservationRaw::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ObservationRaw)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.PlayerRaw player = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player(this),
        _Internal::player(this).GetCachedSize(), target, stream);
  }

  // repeated .SC2APIProtocol.Unit units = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_units_size()); i < n; i++) {
    const auto& repfield = this->_internal_units(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .SC2APIProtocol.MapState map_state = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::map_state(this),
        _Internal::map_state(this).GetCachedSize(), target, stream);
  }

  // optional .SC2APIProtocol.Event event = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::event(this),
        _Internal::event(this).GetCachedSize(), target, stream);
  }

  // repeated .SC2APIProtocol.Effect effects = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_effects_size()); i < n; i++) {
    const auto& repfield = this->_internal_effects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .SC2APIProtocol.RadarRing radar = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_radar_size()); i < n; i++) {
    const auto& repfield = this->_internal_radar(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ObservationRaw)
  return target;
}

size_t ObservationRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ObservationRaw)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.Unit units = 2;
  total_size += 1UL * this->_internal_units_size();
  for (const auto& msg : this->_impl_.units_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SC2APIProtocol.Effect effects = 5;
  total_size += 1UL * this->_internal_effects_size();
  for (const auto& msg : this->_impl_.effects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SC2APIProtocol.RadarRing radar = 6;
  total_size += 1UL * this->_internal_radar_size();
  for (const auto& msg : this->_impl_.radar_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .SC2APIProtocol.PlayerRaw player = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_);
    }

    // optional .SC2APIProtocol.MapState map_state = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.map_state_);
    }

    // optional .SC2APIProtocol.Event event = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.event_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObservationRaw::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObservationRaw::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObservationRaw::GetClassData() const { return &_class_data_; }


void ObservationRaw::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObservationRaw*>(&to_msg);
  auto& from = static_cast<const ObservationRaw&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ObservationRaw)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.units_.MergeFrom(from._impl_.units_);
  _this->_impl_.effects_.MergeFrom(from._impl_.effects_);
  _this->_impl_.radar_.MergeFrom(from._impl_.radar_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_player()->::SC2APIProtocol::PlayerRaw::MergeFrom(
          from._internal_player());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_map_state()->::SC2APIProtocol::MapState::MergeFrom(
          from._internal_map_state());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_event()->::SC2APIProtocol::Event::MergeFrom(
          from._internal_event());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObservationRaw::CopyFrom(const ObservationRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ObservationRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObservationRaw::IsInitialized() const {
  return true;
}

void ObservationRaw::InternalSwap(ObservationRaw* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.units_.InternalSwap(&other->_impl_.units_);
  _impl_.effects_.InternalSwap(&other->_impl_.effects_);
  _impl_.radar_.InternalSwap(&other->_impl_.radar_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObservationRaw, _impl_.event_)
      + sizeof(ObservationRaw::_impl_.event_)
      - PROTOBUF_FIELD_OFFSET(ObservationRaw, _impl_.player_)>(
          reinterpret_cast<char*>(&_impl_.player_),
          reinterpret_cast<char*>(&other->_impl_.player_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObservationRaw::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[1]);
}

// ===================================================================

class RadarRing::_Internal {
 public:
  using HasBits = decltype(std::declval<RadarRing>()._impl_._has_bits_);
  static const ::SC2APIProtocol::Point& pos(const RadarRing* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point&
RadarRing::_Internal::pos(const RadarRing* msg) {
  return *msg->_impl_.pos_;
}
void RadarRing::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RadarRing::RadarRing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.RadarRing)
}
RadarRing::RadarRing(const RadarRing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RadarRing* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.radius_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::SC2APIProtocol::Point(*from._impl_.pos_);
  }
  _this->_impl_.radius_ = from._impl_.radius_;
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.RadarRing)
}

inline void RadarRing::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.radius_){0}
  };
}

RadarRing::~RadarRing() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.RadarRing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RadarRing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
}

void RadarRing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RadarRing::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.RadarRing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pos_ != nullptr);
    _impl_.pos_->Clear();
  }
  _impl_.radius_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadarRing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Point pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RadarRing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.RadarRing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.Point pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional float radius = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.RadarRing)
  return target;
}

size_t RadarRing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.RadarRing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SC2APIProtocol.Point pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional float radius = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RadarRing::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RadarRing::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RadarRing::GetClassData() const { return &_class_data_; }


void RadarRing::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RadarRing*>(&to_msg);
  auto& from = static_cast<const RadarRing&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.RadarRing)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::SC2APIProtocol::Point::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RadarRing::CopyFrom(const RadarRing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.RadarRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadarRing::IsInitialized() const {
  return true;
}

void RadarRing::InternalSwap(RadarRing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RadarRing, _impl_.radius_)
      + sizeof(RadarRing::_impl_.radius_)
      - PROTOBUF_FIELD_OFFSET(RadarRing, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RadarRing::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[2]);
}

// ===================================================================

class PowerSource::_Internal {
 public:
  using HasBits = decltype(std::declval<PowerSource>()._impl_._has_bits_);
  static const ::SC2APIProtocol::Point& pos(const PowerSource* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point&
PowerSource::_Internal::pos(const PowerSource* msg) {
  return *msg->_impl_.pos_;
}
void PowerSource::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PowerSource::PowerSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.PowerSource)
}
PowerSource::PowerSource(const PowerSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PowerSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.radius_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::SC2APIProtocol::Point(*from._impl_.pos_);
  }
  ::memcpy(&_impl_.tag_, &from._impl_.tag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.radius_) -
    reinterpret_cast<char*>(&_impl_.tag_)) + sizeof(_impl_.radius_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.PowerSource)
}

inline void PowerSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.tag_){uint64_t{0u}}
    , decltype(_impl_.radius_){0}
  };
}

PowerSource::~PowerSource() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.PowerSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PowerSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
}

void PowerSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PowerSource::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.PowerSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pos_ != nullptr);
    _impl_.pos_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.tag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.radius_) -
        reinterpret_cast<char*>(&_impl_.tag_)) + sizeof(_impl_.radius_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PowerSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Point pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tag(&has_bits);
          _impl_.tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PowerSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.PowerSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.Point pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional float radius = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_radius(), target);
  }

  // optional uint64 tag = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.PowerSource)
  return target;
}

size_t PowerSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.PowerSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .SC2APIProtocol.Point pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional uint64 tag = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tag());
    }

    // optional float radius = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PowerSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PowerSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PowerSource::GetClassData() const { return &_class_data_; }


void PowerSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PowerSource*>(&to_msg);
  auto& from = static_cast<const PowerSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.PowerSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::SC2APIProtocol::Point::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tag_ = from._impl_.tag_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PowerSource::CopyFrom(const PowerSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.PowerSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PowerSource::IsInitialized() const {
  return true;
}

void PowerSource::InternalSwap(PowerSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PowerSource, _impl_.radius_)
      + sizeof(PowerSource::_impl_.radius_)
      - PROTOBUF_FIELD_OFFSET(PowerSource, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PowerSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[3]);
}

// ===================================================================

class PlayerRaw::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerRaw>()._impl_._has_bits_);
  static const ::SC2APIProtocol::Point& camera(const PlayerRaw* msg);
  static void set_has_camera(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SC2APIProtocol::Point&
PlayerRaw::_Internal::camera(const PlayerRaw* msg) {
  return *msg->_impl_.camera_;
}
void PlayerRaw::clear_camera() {
  if (_impl_.camera_ != nullptr) _impl_.camera_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PlayerRaw::PlayerRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.PlayerRaw)
}
PlayerRaw::PlayerRaw(const PlayerRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerRaw* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.power_sources_){from._impl_.power_sources_}
    , decltype(_impl_.upgrade_ids_){from._impl_.upgrade_ids_}
    , decltype(_impl_.camera_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_camera()) {
    _this->_impl_.camera_ = new ::SC2APIProtocol::Point(*from._impl_.camera_);
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.PlayerRaw)
}

inline void PlayerRaw::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.power_sources_){arena}
    , decltype(_impl_.upgrade_ids_){arena}
    , decltype(_impl_.camera_){nullptr}
  };
}

PlayerRaw::~PlayerRaw() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.PlayerRaw)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerRaw::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.power_sources_.~RepeatedPtrField();
  _impl_.upgrade_ids_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.camera_;
}

void PlayerRaw::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.PlayerRaw)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.power_sources_.Clear();
  _impl_.upgrade_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.camera_ != nullptr);
    _impl_.camera_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerRaw::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .SC2APIProtocol.PowerSource power_sources = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_power_sources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Point camera = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 upgrade_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_upgrade_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_upgrade_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerRaw::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.PlayerRaw)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.PowerSource power_sources = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_power_sources_size()); i < n; i++) {
    const auto& repfield = this->_internal_power_sources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.Point camera = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::camera(this),
        _Internal::camera(this).GetCachedSize(), target, stream);
  }

  // repeated uint32 upgrade_ids = 3;
  for (int i = 0, n = this->_internal_upgrade_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_upgrade_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.PlayerRaw)
  return target;
}

size_t PlayerRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.PlayerRaw)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.PowerSource power_sources = 1;
  total_size += 1UL * this->_internal_power_sources_size();
  for (const auto& msg : this->_impl_.power_sources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 upgrade_ids = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.upgrade_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_upgrade_ids_size());
    total_size += data_size;
  }

  // optional .SC2APIProtocol.Point camera = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.camera_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerRaw::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerRaw::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerRaw::GetClassData() const { return &_class_data_; }


void PlayerRaw::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerRaw*>(&to_msg);
  auto& from = static_cast<const PlayerRaw&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.PlayerRaw)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.power_sources_.MergeFrom(from._impl_.power_sources_);
  _this->_impl_.upgrade_ids_.MergeFrom(from._impl_.upgrade_ids_);
  if (from._internal_has_camera()) {
    _this->_internal_mutable_camera()->::SC2APIProtocol::Point::MergeFrom(
        from._internal_camera());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerRaw::CopyFrom(const PlayerRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.PlayerRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerRaw::IsInitialized() const {
  return true;
}

void PlayerRaw::InternalSwap(PlayerRaw* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.power_sources_.InternalSwap(&other->_impl_.power_sources_);
  _impl_.upgrade_ids_.InternalSwap(&other->_impl_.upgrade_ids_);
  swap(_impl_.camera_, other->_impl_.camera_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerRaw::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[4]);
}

// ===================================================================

class UnitOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<UnitOrder>()._impl_._has_bits_);
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::Point& target_world_space_pos(const UnitOrder* msg);
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point&
UnitOrder::_Internal::target_world_space_pos(const UnitOrder* msg) {
  return *msg->_impl_.target_.target_world_space_pos_;
}
void UnitOrder::set_allocated_target_world_space_pos(::SC2APIProtocol::Point* target_world_space_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_target();
  if (target_world_space_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_world_space_pos));
    if (message_arena != submessage_arena) {
      target_world_space_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_world_space_pos, submessage_arena);
    }
    set_has_target_world_space_pos();
    _impl_.target_.target_world_space_pos_ = target_world_space_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.UnitOrder.target_world_space_pos)
}
void UnitOrder::clear_target_world_space_pos() {
  if (_internal_has_target_world_space_pos()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.target_.target_world_space_pos_;
    }
    clear_has_target();
  }
}
UnitOrder::UnitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.UnitOrder)
}
UnitOrder::UnitOrder(const UnitOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnitOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ability_id_){}
    , decltype(_impl_.progress_){}
    , decltype(_impl_.target_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ability_id_, &from._impl_.ability_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.progress_) -
    reinterpret_cast<char*>(&_impl_.ability_id_)) + sizeof(_impl_.progress_));
  clear_has_target();
  switch (from.target_case()) {
    case kTargetWorldSpacePos: {
      _this->_internal_mutable_target_world_space_pos()->::SC2APIProtocol::Point::MergeFrom(
          from._internal_target_world_space_pos());
      break;
    }
    case kTargetUnitTag: {
      _this->_internal_set_target_unit_tag(from._internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.UnitOrder)
}

inline void UnitOrder::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ability_id_){0u}
    , decltype(_impl_.progress_){0}
    , decltype(_impl_.target_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_target();
}

UnitOrder::~UnitOrder() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.UnitOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnitOrder::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_target()) {
    clear_target();
  }
}

void UnitOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnitOrder::clear_target() {
// @@protoc_insertion_point(one_of_clear_start:SC2APIProtocol.UnitOrder)
  switch (target_case()) {
    case kTargetWorldSpacePos: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.target_.target_world_space_pos_;
      }
      break;
    }
    case kTargetUnitTag: {
      // No need to clear
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}


void UnitOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.UnitOrder)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ability_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.progress_) -
        reinterpret_cast<char*>(&_impl_.ability_id_)) + sizeof(_impl_.progress_));
  }
  clear_target();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnitOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ability_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ability_id(&has_bits);
          _impl_.ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SC2APIProtocol.Point target_world_space_pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_world_space_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 target_unit_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_target_unit_tag(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float progress = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnitOrder::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.UnitOrder)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ability_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ability_id(), target);
  }

  switch (target_case()) {
    case kTargetWorldSpacePos: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::target_world_space_pos(this),
          _Internal::target_world_space_pos(this).GetCachedSize(), target, stream);
      break;
    }
    case kTargetUnitTag: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_target_unit_tag(), target);
      break;
    }
    default: ;
  }
  // optional float progress = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_progress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.UnitOrder)
  return target;
}

size_t UnitOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.UnitOrder)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ability_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ability_id());
    }

    // optional float progress = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  switch (target_case()) {
    // .SC2APIProtocol.Point target_world_space_pos = 2;
    case kTargetWorldSpacePos: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_.target_world_space_pos_);
      break;
    }
    // uint64 target_unit_tag = 3;
    case kTargetUnitTag: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnitOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnitOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnitOrder::GetClassData() const { return &_class_data_; }


void UnitOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnitOrder*>(&to_msg);
  auto& from = static_cast<const UnitOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.UnitOrder)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ability_id_ = from._impl_.ability_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.progress_ = from._impl_.progress_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.target_case()) {
    case kTargetWorldSpacePos: {
      _this->_internal_mutable_target_world_space_pos()->::SC2APIProtocol::Point::MergeFrom(
          from._internal_target_world_space_pos());
      break;
    }
    case kTargetUnitTag: {
      _this->_internal_set_target_unit_tag(from._internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnitOrder::CopyFrom(const UnitOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.UnitOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnitOrder::IsInitialized() const {
  return true;
}

void UnitOrder::InternalSwap(UnitOrder* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnitOrder, _impl_.progress_)
      + sizeof(UnitOrder::_impl_.progress_)
      - PROTOBUF_FIELD_OFFSET(UnitOrder, _impl_.ability_id_)>(
          reinterpret_cast<char*>(&_impl_.ability_id_),
          reinterpret_cast<char*>(&other->_impl_.ability_id_));
  swap(_impl_.target_, other->_impl_.target_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata UnitOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[5]);
}

// ===================================================================

class PassengerUnit::_Internal {
 public:
  using HasBits = decltype(std::declval<PassengerUnit>()._impl_._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_health(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_health_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_shield(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shield_max(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_energy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_energy_max(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_unit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

PassengerUnit::PassengerUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.PassengerUnit)
}
PassengerUnit::PassengerUnit(const PassengerUnit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PassengerUnit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.health_){}
    , decltype(_impl_.health_max_){}
    , decltype(_impl_.shield_){}
    , decltype(_impl_.energy_){}
    , decltype(_impl_.unit_type_){}
    , decltype(_impl_.shield_max_){}
    , decltype(_impl_.energy_max_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.tag_, &from._impl_.tag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.energy_max_) -
    reinterpret_cast<char*>(&_impl_.tag_)) + sizeof(_impl_.energy_max_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.PassengerUnit)
}

inline void PassengerUnit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){uint64_t{0u}}
    , decltype(_impl_.health_){0}
    , decltype(_impl_.health_max_){0}
    , decltype(_impl_.shield_){0}
    , decltype(_impl_.energy_){0}
    , decltype(_impl_.unit_type_){0u}
    , decltype(_impl_.shield_max_){0}
    , decltype(_impl_.energy_max_){0}
  };
}

PassengerUnit::~PassengerUnit() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.PassengerUnit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PassengerUnit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PassengerUnit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PassengerUnit::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.PassengerUnit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.tag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.energy_max_) -
        reinterpret_cast<char*>(&_impl_.tag_)) + sizeof(_impl_.energy_max_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PassengerUnit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tag(&has_bits);
          _impl_.tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float health = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_health(&has_bits);
          _impl_.health_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float health_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_health_max(&has_bits);
          _impl_.health_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float shield = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_shield(&has_bits);
          _impl_.shield_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float energy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_energy(&has_bits);
          _impl_.energy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unit_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_unit_type(&has_bits);
          _impl_.unit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float shield_max = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_shield_max(&has_bits);
          _impl_.shield_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float energy_max = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_energy_max(&has_bits);
          _impl_.energy_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PassengerUnit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.PassengerUnit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 tag = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tag(), target);
  }

  // optional float health = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_health(), target);
  }

  // optional float health_max = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_health_max(), target);
  }

  // optional float shield = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_shield(), target);
  }

  // optional float energy = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_energy(), target);
  }

  // optional uint32 unit_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_unit_type(), target);
  }

  // optional float shield_max = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_shield_max(), target);
  }

  // optional float energy_max = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_energy_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.PassengerUnit)
  return target;
}

size_t PassengerUnit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.PassengerUnit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tag());
    }

    // optional float health = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float health_max = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float shield = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float energy = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 unit_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unit_type());
    }

    // optional float shield_max = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float energy_max = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PassengerUnit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PassengerUnit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PassengerUnit::GetClassData() const { return &_class_data_; }


void PassengerUnit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PassengerUnit*>(&to_msg);
  auto& from = static_cast<const PassengerUnit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.PassengerUnit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.tag_ = from._impl_.tag_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.health_ = from._impl_.health_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.health_max_ = from._impl_.health_max_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.shield_ = from._impl_.shield_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.energy_ = from._impl_.energy_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.unit_type_ = from._impl_.unit_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.shield_max_ = from._impl_.shield_max_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.energy_max_ = from._impl_.energy_max_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PassengerUnit::CopyFrom(const PassengerUnit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.PassengerUnit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassengerUnit::IsInitialized() const {
  return true;
}

void PassengerUnit::InternalSwap(PassengerUnit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PassengerUnit, _impl_.energy_max_)
      + sizeof(PassengerUnit::_impl_.energy_max_)
      - PROTOBUF_FIELD_OFFSET(PassengerUnit, _impl_.tag_)>(
          reinterpret_cast<char*>(&_impl_.tag_),
          reinterpret_cast<char*>(&other->_impl_.tag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PassengerUnit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[6]);
}

// ===================================================================

class RallyTarget::_Internal {
 public:
  using HasBits = decltype(std::declval<RallyTarget>()._impl_._has_bits_);
  static const ::SC2APIProtocol::Point& point(const RallyTarget* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point&
RallyTarget::_Internal::point(const RallyTarget* msg) {
  return *msg->_impl_.point_;
}
void RallyTarget::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RallyTarget::RallyTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.RallyTarget)
}
RallyTarget::RallyTarget(const RallyTarget& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RallyTarget* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.tag_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_point()) {
    _this->_impl_.point_ = new ::SC2APIProtocol::Point(*from._impl_.point_);
  }
  _this->_impl_.tag_ = from._impl_.tag_;
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.RallyTarget)
}

inline void RallyTarget::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.tag_){uint64_t{0u}}
  };
}

RallyTarget::~RallyTarget() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.RallyTarget)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RallyTarget::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
}

void RallyTarget::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RallyTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.RallyTarget)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.point_ != nullptr);
    _impl_.point_->Clear();
  }
  _impl_.tag_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RallyTarget::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Point point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tag(&has_bits);
          _impl_.tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RallyTarget::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.RallyTarget)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.Point point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // optional uint64 tag = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.RallyTarget)
  return target;
}

size_t RallyTarget::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.RallyTarget)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SC2APIProtocol.Point point = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_);
    }

    // optional uint64 tag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tag());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RallyTarget::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RallyTarget::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RallyTarget::GetClassData() const { return &_class_data_; }


void RallyTarget::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RallyTarget*>(&to_msg);
  auto& from = static_cast<const RallyTarget&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.RallyTarget)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point()->::SC2APIProtocol::Point::MergeFrom(
          from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tag_ = from._impl_.tag_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RallyTarget::CopyFrom(const RallyTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.RallyTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RallyTarget::IsInitialized() const {
  return true;
}

void RallyTarget::InternalSwap(RallyTarget* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RallyTarget, _impl_.tag_)
      + sizeof(RallyTarget::_impl_.tag_)
      - PROTOBUF_FIELD_OFFSET(RallyTarget, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RallyTarget::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[7]);
}

// ===================================================================

class Unit::_Internal {
 public:
  using HasBits = decltype(std::declval<Unit>()._impl_._has_bits_);
  static void set_has_display_type(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_alliance(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_unit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::SC2APIProtocol::Point& pos(const Unit* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_facing(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_build_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_cloak(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_detect_range(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_radar_range(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_is_selected(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_on_screen(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_blip(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_powered(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_is_active(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_attack_upgrade_level(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_armor_upgrade_level(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_shield_upgrade_level(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_health(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_health_max(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_shield(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_shield_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_energy(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_energy_max(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_mineral_contents(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_vespene_contents(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_flying(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_is_burrowed(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_is_hallucination(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_add_on_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_cargo_space_taken(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_cargo_space_max(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_assigned_harvesters(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_ideal_harvesters(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_weapon_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_engaged_target_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_buff_duration_remain(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_buff_duration_max(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
};

const ::SC2APIProtocol::Point&
Unit::_Internal::pos(const Unit* msg) {
  return *msg->_impl_.pos_;
}
void Unit::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Unit::Unit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.Unit)
}
Unit::Unit(const Unit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Unit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orders_){from._impl_.orders_}
    , decltype(_impl_.passengers_){from._impl_.passengers_}
    , decltype(_impl_.buff_ids_){from._impl_.buff_ids_}
    , decltype(_impl_.rally_targets_){from._impl_.rally_targets_}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.unit_type_){}
    , decltype(_impl_.owner_){}
    , decltype(_impl_.facing_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.build_progress_){}
    , decltype(_impl_.cloak_){}
    , decltype(_impl_.health_){}
    , decltype(_impl_.health_max_){}
    , decltype(_impl_.shield_){}
    , decltype(_impl_.energy_){}
    , decltype(_impl_.is_selected_){}
    , decltype(_impl_.is_on_screen_){}
    , decltype(_impl_.is_blip_){}
    , decltype(_impl_.is_powered_){}
    , decltype(_impl_.mineral_contents_){}
    , decltype(_impl_.vespene_contents_){}
    , decltype(_impl_.cargo_space_taken_){}
    , decltype(_impl_.add_on_tag_){}
    , decltype(_impl_.cargo_space_max_){}
    , decltype(_impl_.assigned_harvesters_){}
    , decltype(_impl_.ideal_harvesters_){}
    , decltype(_impl_.is_active_){}
    , decltype(_impl_.is_flying_){}
    , decltype(_impl_.is_burrowed_){}
    , decltype(_impl_.is_hallucination_){}
    , decltype(_impl_.weapon_cooldown_){}
    , decltype(_impl_.detect_range_){}
    , decltype(_impl_.engaged_target_tag_){}
    , decltype(_impl_.radar_range_){}
    , decltype(_impl_.shield_max_){}
    , decltype(_impl_.energy_max_){}
    , decltype(_impl_.attack_upgrade_level_){}
    , decltype(_impl_.armor_upgrade_level_){}
    , decltype(_impl_.shield_upgrade_level_){}
    , decltype(_impl_.buff_duration_remain_){}
    , decltype(_impl_.buff_duration_max_){}
    , decltype(_impl_.display_type_){}
    , decltype(_impl_.alliance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::SC2APIProtocol::Point(*from._impl_.pos_);
  }
  ::memcpy(&_impl_.tag_, &from._impl_.tag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.alliance_) -
    reinterpret_cast<char*>(&_impl_.tag_)) + sizeof(_impl_.alliance_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.Unit)
}

inline void Unit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orders_){arena}
    , decltype(_impl_.passengers_){arena}
    , decltype(_impl_.buff_ids_){arena}
    , decltype(_impl_.rally_targets_){arena}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.tag_){uint64_t{0u}}
    , decltype(_impl_.unit_type_){0u}
    , decltype(_impl_.owner_){0}
    , decltype(_impl_.facing_){0}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.build_progress_){0}
    , decltype(_impl_.cloak_){0}
    , decltype(_impl_.health_){0}
    , decltype(_impl_.health_max_){0}
    , decltype(_impl_.shield_){0}
    , decltype(_impl_.energy_){0}
    , decltype(_impl_.is_selected_){false}
    , decltype(_impl_.is_on_screen_){false}
    , decltype(_impl_.is_blip_){false}
    , decltype(_impl_.is_powered_){false}
    , decltype(_impl_.mineral_contents_){0}
    , decltype(_impl_.vespene_contents_){0}
    , decltype(_impl_.cargo_space_taken_){0}
    , decltype(_impl_.add_on_tag_){uint64_t{0u}}
    , decltype(_impl_.cargo_space_max_){0}
    , decltype(_impl_.assigned_harvesters_){0}
    , decltype(_impl_.ideal_harvesters_){0}
    , decltype(_impl_.is_active_){false}
    , decltype(_impl_.is_flying_){false}
    , decltype(_impl_.is_burrowed_){false}
    , decltype(_impl_.is_hallucination_){false}
    , decltype(_impl_.weapon_cooldown_){0}
    , decltype(_impl_.detect_range_){0}
    , decltype(_impl_.engaged_target_tag_){uint64_t{0u}}
    , decltype(_impl_.radar_range_){0}
    , decltype(_impl_.shield_max_){0}
    , decltype(_impl_.energy_max_){0}
    , decltype(_impl_.attack_upgrade_level_){0}
    , decltype(_impl_.armor_upgrade_level_){0}
    , decltype(_impl_.shield_upgrade_level_){0}
    , decltype(_impl_.buff_duration_remain_){0}
    , decltype(_impl_.buff_duration_max_){0}
    , decltype(_impl_.display_type_){1}
    , decltype(_impl_.alliance_){1}
  };
}

Unit::~Unit() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.Unit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Unit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.orders_.~RepeatedPtrField();
  _impl_.passengers_.~RepeatedPtrField();
  _impl_.buff_ids_.~RepeatedField();
  _impl_.rally_targets_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.pos_;
}

void Unit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Unit::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.Unit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.orders_.Clear();
  _impl_.passengers_.Clear();
  _impl_.buff_ids_.Clear();
  _impl_.rally_targets_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pos_ != nullptr);
    _impl_.pos_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.tag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cloak_) -
        reinterpret_cast<char*>(&_impl_.tag_)) + sizeof(_impl_.cloak_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.health_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_powered_) -
        reinterpret_cast<char*>(&_impl_.health_)) + sizeof(_impl_.is_powered_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.mineral_contents_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_active_) -
        reinterpret_cast<char*>(&_impl_.mineral_contents_)) + sizeof(_impl_.is_active_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.is_flying_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shield_max_) -
        reinterpret_cast<char*>(&_impl_.is_flying_)) + sizeof(_impl_.shield_max_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.energy_max_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.buff_duration_max_) -
        reinterpret_cast<char*>(&_impl_.energy_max_)) + sizeof(_impl_.buff_duration_max_));
    _impl_.display_type_ = 1;
    _impl_.alliance_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Unit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.DisplayType display_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::DisplayType_IsValid(val))) {
            _internal_set_display_type(static_cast<::SC2APIProtocol::DisplayType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Alliance alliance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Alliance_IsValid(val))) {
            _internal_set_alliance(static_cast<::SC2APIProtocol::Alliance>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tag(&_impl_._has_bits_);
          _impl_.tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unit_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_unit_type(&_impl_._has_bits_);
          _impl_.unit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 owner = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_owner(&_impl_._has_bits_);
          _impl_.owner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Point pos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float facing = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_facing(&_impl_._has_bits_);
          _impl_.facing_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_radius(&_impl_._has_bits_);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float build_progress = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_build_progress(&_impl_._has_bits_);
          _impl_.build_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.CloakState cloak = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::CloakState_IsValid(val))) {
            _internal_set_cloak(static_cast<::SC2APIProtocol::CloakState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_selected = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_selected(&_impl_._has_bits_);
          _impl_.is_selected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_on_screen = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_is_on_screen(&_impl_._has_bits_);
          _impl_.is_on_screen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_blip = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_blip(&_impl_._has_bits_);
          _impl_.is_blip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float health = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_health(&_impl_._has_bits_);
          _impl_.health_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float health_max = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_health_max(&_impl_._has_bits_);
          _impl_.health_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float shield = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_shield(&_impl_._has_bits_);
          _impl_.shield_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float energy = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_energy(&_impl_._has_bits_);
          _impl_.energy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mineral_contents = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_mineral_contents(&_impl_._has_bits_);
          _impl_.mineral_contents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 vespene_contents = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_vespene_contents(&_impl_._has_bits_);
          _impl_.vespene_contents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_flying = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_is_flying(&_impl_._has_bits_);
          _impl_.is_flying_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_burrowed = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_is_burrowed(&_impl_._has_bits_);
          _impl_.is_burrowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.UnitOrder orders = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 add_on_tag = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_add_on_tag(&_impl_._has_bits_);
          _impl_.add_on_tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.PassengerUnit passengers = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_passengers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 cargo_space_taken = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_cargo_space_taken(&_impl_._has_bits_);
          _impl_.cargo_space_taken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cargo_space_max = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_cargo_space_max(&_impl_._has_bits_);
          _impl_.cargo_space_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 buff_ids = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_buff_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<216>(ptr));
        } else if (static_cast<uint8_t>(tag) == 218) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_buff_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 assigned_harvesters = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_assigned_harvesters(&_impl_._has_bits_);
          _impl_.assigned_harvesters_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ideal_harvesters = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_ideal_harvesters(&_impl_._has_bits_);
          _impl_.ideal_harvesters_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float weapon_cooldown = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 245)) {
          _Internal::set_has_weapon_cooldown(&_impl_._has_bits_);
          _impl_.weapon_cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float detect_range = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 253)) {
          _Internal::set_has_detect_range(&_impl_._has_bits_);
          _impl_.detect_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float radar_range = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 5)) {
          _Internal::set_has_radar_range(&_impl_._has_bits_);
          _impl_.radar_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 engaged_target_tag = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_engaged_target_tag(&_impl_._has_bits_);
          _impl_.engaged_target_tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_powered = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_powered(&_impl_._has_bits_);
          _impl_.is_powered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float shield_max = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_shield_max(&_impl_._has_bits_);
          _impl_.shield_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float energy_max = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_energy_max(&_impl_._has_bits_);
          _impl_.energy_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hallucination = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_hallucination(&_impl_._has_bits_);
          _impl_.is_hallucination_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_active = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_active(&_impl_._has_bits_);
          _impl_.is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 attack_upgrade_level = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_attack_upgrade_level(&_impl_._has_bits_);
          _impl_.attack_upgrade_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 armor_upgrade_level = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_armor_upgrade_level(&_impl_._has_bits_);
          _impl_.armor_upgrade_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 shield_upgrade_level = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_shield_upgrade_level(&_impl_._has_bits_);
          _impl_.shield_upgrade_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 buff_duration_remain = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_buff_duration_remain(&_impl_._has_bits_);
          _impl_.buff_duration_remain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 buff_duration_max = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_buff_duration_max(&_impl_._has_bits_);
          _impl_.buff_duration_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.RallyTarget rally_targets = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_rally_targets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<362>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Unit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.Unit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[1];
  // optional .SC2APIProtocol.DisplayType display_type = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_display_type(), target);
  }

  // optional .SC2APIProtocol.Alliance alliance = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_alliance(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 tag = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_tag(), target);
  }

  // optional uint32 unit_type = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_unit_type(), target);
  }

  // optional int32 owner = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_owner(), target);
  }

  // optional .SC2APIProtocol.Point pos = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional float facing = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_facing(), target);
  }

  // optional float radius = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_radius(), target);
  }

  // optional float build_progress = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_build_progress(), target);
  }

  // optional .SC2APIProtocol.CloakState cloak = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_cloak(), target);
  }

  // optional bool is_selected = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_is_selected(), target);
  }

  // optional bool is_on_screen = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_on_screen(), target);
  }

  // optional bool is_blip = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_blip(), target);
  }

  // optional float health = 14;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_health(), target);
  }

  // optional float health_max = 15;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_health_max(), target);
  }

  // optional float shield = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_shield(), target);
  }

  // optional float energy = 17;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_energy(), target);
  }

  // optional int32 mineral_contents = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_mineral_contents(), target);
  }

  // optional int32 vespene_contents = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_vespene_contents(), target);
  }

  // optional bool is_flying = 20;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_is_flying(), target);
  }

  // optional bool is_burrowed = 21;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_is_burrowed(), target);
  }

  // repeated .SC2APIProtocol.UnitOrder orders = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 add_on_tag = 23;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(23, this->_internal_add_on_tag(), target);
  }

  // repeated .SC2APIProtocol.PassengerUnit passengers = 24;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_passengers_size()); i < n; i++) {
    const auto& repfield = this->_internal_passengers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 cargo_space_taken = 25;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_cargo_space_taken(), target);
  }

  // optional int32 cargo_space_max = 26;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(26, this->_internal_cargo_space_max(), target);
  }

  // repeated uint32 buff_ids = 27;
  for (int i = 0, n = this->_internal_buff_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_buff_ids(i), target);
  }

  // optional int32 assigned_harvesters = 28;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(28, this->_internal_assigned_harvesters(), target);
  }

  // optional int32 ideal_harvesters = 29;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(29, this->_internal_ideal_harvesters(), target);
  }

  // optional float weapon_cooldown = 30;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(30, this->_internal_weapon_cooldown(), target);
  }

  // optional float detect_range = 31;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(31, this->_internal_detect_range(), target);
  }

  // optional float radar_range = 32;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(32, this->_internal_radar_range(), target);
  }

  // optional uint64 engaged_target_tag = 34;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(34, this->_internal_engaged_target_tag(), target);
  }

  // optional bool is_powered = 35;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(35, this->_internal_is_powered(), target);
  }

  // optional float shield_max = 36;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(36, this->_internal_shield_max(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional float energy_max = 37;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(37, this->_internal_energy_max(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_hallucination = 38;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(38, this->_internal_is_hallucination(), target);
  }

  // optional bool is_active = 39;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(39, this->_internal_is_active(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 attack_upgrade_level = 40;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(40, this->_internal_attack_upgrade_level(), target);
  }

  // optional int32 armor_upgrade_level = 41;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(41, this->_internal_armor_upgrade_level(), target);
  }

  // optional int32 shield_upgrade_level = 42;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(42, this->_internal_shield_upgrade_level(), target);
  }

  // optional int32 buff_duration_remain = 43;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(43, this->_internal_buff_duration_remain(), target);
  }

  // optional int32 buff_duration_max = 44;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(44, this->_internal_buff_duration_max(), target);
  }

  // repeated .SC2APIProtocol.RallyTarget rally_targets = 45;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rally_targets_size()); i < n; i++) {
    const auto& repfield = this->_internal_rally_targets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(45, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.Unit)
  return target;
}

size_t Unit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.Unit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.UnitOrder orders = 22;
  total_size += 2UL * this->_internal_orders_size();
  for (const auto& msg : this->_impl_.orders_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SC2APIProtocol.PassengerUnit passengers = 24;
  total_size += 2UL * this->_internal_passengers_size();
  for (const auto& msg : this->_impl_.passengers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 buff_ids = 27;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.buff_ids_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_buff_ids_size());
    total_size += data_size;
  }

  // repeated .SC2APIProtocol.RallyTarget rally_targets = 45;
  total_size += 2UL * this->_internal_rally_targets_size();
  for (const auto& msg : this->_impl_.rally_targets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .SC2APIProtocol.Point pos = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional uint64 tag = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tag());
    }

    // optional uint32 unit_type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unit_type());
    }

    // optional int32 owner = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_owner());
    }

    // optional float facing = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float radius = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float build_progress = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.CloakState cloak = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cloak());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float health = 14;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float health_max = 15;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float shield = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 4;
    }

    // optional float energy = 17;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 4;
    }

    // optional bool is_selected = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool is_on_screen = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool is_blip = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool is_powered = 35;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 mineral_contents = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mineral_contents());
    }

    // optional int32 vespene_contents = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_vespene_contents());
    }

    // optional int32 cargo_space_taken = 25;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_cargo_space_taken());
    }

    // optional uint64 add_on_tag = 23;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_add_on_tag());
    }

    // optional int32 cargo_space_max = 26;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_cargo_space_max());
    }

    // optional int32 assigned_harvesters = 28;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_assigned_harvesters());
    }

    // optional int32 ideal_harvesters = 29;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ideal_harvesters());
    }

    // optional bool is_active = 39;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool is_flying = 20;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_burrowed = 21;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_hallucination = 38;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional float weapon_cooldown = 30;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 4;
    }

    // optional float detect_range = 31;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 4;
    }

    // optional uint64 engaged_target_tag = 34;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_engaged_target_tag());
    }

    // optional float radar_range = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 4;
    }

    // optional float shield_max = 36;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 4;
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional float energy_max = 37;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 4;
    }

    // optional int32 attack_upgrade_level = 40;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_attack_upgrade_level());
    }

    // optional int32 armor_upgrade_level = 41;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_armor_upgrade_level());
    }

    // optional int32 shield_upgrade_level = 42;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_shield_upgrade_level());
    }

    // optional int32 buff_duration_remain = 43;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_buff_duration_remain());
    }

    // optional int32 buff_duration_max = 44;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_buff_duration_max());
    }

    // optional .SC2APIProtocol.DisplayType display_type = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_display_type());
    }

    // optional .SC2APIProtocol.Alliance alliance = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_alliance());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Unit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Unit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Unit::GetClassData() const { return &_class_data_; }


void Unit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Unit*>(&to_msg);
  auto& from = static_cast<const Unit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.Unit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.orders_.MergeFrom(from._impl_.orders_);
  _this->_impl_.passengers_.MergeFrom(from._impl_.passengers_);
  _this->_impl_.buff_ids_.MergeFrom(from._impl_.buff_ids_);
  _this->_impl_.rally_targets_.MergeFrom(from._impl_.rally_targets_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::SC2APIProtocol::Point::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tag_ = from._impl_.tag_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.unit_type_ = from._impl_.unit_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.owner_ = from._impl_.owner_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.facing_ = from._impl_.facing_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.build_progress_ = from._impl_.build_progress_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.cloak_ = from._impl_.cloak_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.health_ = from._impl_.health_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.health_max_ = from._impl_.health_max_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.shield_ = from._impl_.shield_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.energy_ = from._impl_.energy_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.is_selected_ = from._impl_.is_selected_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.is_on_screen_ = from._impl_.is_on_screen_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.is_blip_ = from._impl_.is_blip_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.is_powered_ = from._impl_.is_powered_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.mineral_contents_ = from._impl_.mineral_contents_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.vespene_contents_ = from._impl_.vespene_contents_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.cargo_space_taken_ = from._impl_.cargo_space_taken_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.add_on_tag_ = from._impl_.add_on_tag_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.cargo_space_max_ = from._impl_.cargo_space_max_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.assigned_harvesters_ = from._impl_.assigned_harvesters_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.ideal_harvesters_ = from._impl_.ideal_harvesters_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.is_active_ = from._impl_.is_active_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.is_flying_ = from._impl_.is_flying_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.is_burrowed_ = from._impl_.is_burrowed_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.is_hallucination_ = from._impl_.is_hallucination_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.weapon_cooldown_ = from._impl_.weapon_cooldown_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.detect_range_ = from._impl_.detect_range_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.engaged_target_tag_ = from._impl_.engaged_target_tag_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.radar_range_ = from._impl_.radar_range_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.shield_max_ = from._impl_.shield_max_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.energy_max_ = from._impl_.energy_max_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.attack_upgrade_level_ = from._impl_.attack_upgrade_level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.armor_upgrade_level_ = from._impl_.armor_upgrade_level_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.shield_upgrade_level_ = from._impl_.shield_upgrade_level_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.buff_duration_remain_ = from._impl_.buff_duration_remain_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.buff_duration_max_ = from._impl_.buff_duration_max_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.display_type_ = from._impl_.display_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.alliance_ = from._impl_.alliance_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Unit::CopyFrom(const Unit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.Unit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Unit::IsInitialized() const {
  return true;
}

void Unit::InternalSwap(Unit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.orders_.InternalSwap(&other->_impl_.orders_);
  _impl_.passengers_.InternalSwap(&other->_impl_.passengers_);
  _impl_.buff_ids_.InternalSwap(&other->_impl_.buff_ids_);
  _impl_.rally_targets_.InternalSwap(&other->_impl_.rally_targets_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Unit, _impl_.buff_duration_max_)
      + sizeof(Unit::_impl_.buff_duration_max_)
      - PROTOBUF_FIELD_OFFSET(Unit, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
  swap(_impl_.display_type_, other->_impl_.display_type_);
  swap(_impl_.alliance_, other->_impl_.alliance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Unit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[8]);
}

// ===================================================================

class MapState::_Internal {
 public:
  using HasBits = decltype(std::declval<MapState>()._impl_._has_bits_);
  static const ::SC2APIProtocol::ImageData& visibility(const MapState* msg);
  static void set_has_visibility(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::ImageData& creep(const MapState* msg);
  static void set_has_creep(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::ImageData&
MapState::_Internal::visibility(const MapState* msg) {
  return *msg->_impl_.visibility_;
}
const ::SC2APIProtocol::ImageData&
MapState::_Internal::creep(const MapState* msg) {
  return *msg->_impl_.creep_;
}
void MapState::clear_visibility() {
  if (_impl_.visibility_ != nullptr) _impl_.visibility_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MapState::clear_creep() {
  if (_impl_.creep_ != nullptr) _impl_.creep_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
MapState::MapState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.MapState)
}
MapState::MapState(const MapState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MapState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.visibility_){nullptr}
    , decltype(_impl_.creep_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_visibility()) {
    _this->_impl_.visibility_ = new ::SC2APIProtocol::ImageData(*from._impl_.visibility_);
  }
  if (from._internal_has_creep()) {
    _this->_impl_.creep_ = new ::SC2APIProtocol::ImageData(*from._impl_.creep_);
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.MapState)
}

inline void MapState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.visibility_){nullptr}
    , decltype(_impl_.creep_){nullptr}
  };
}

MapState::~MapState() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.MapState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.visibility_;
  if (this != internal_default_instance()) delete _impl_.creep_;
}

void MapState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapState::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.MapState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.visibility_ != nullptr);
      _impl_.visibility_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.creep_ != nullptr);
      _impl_.creep_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MapState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.ImageData visibility = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_visibility(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ImageData creep = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_creep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.MapState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.ImageData visibility = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::visibility(this),
        _Internal::visibility(this).GetCachedSize(), target, stream);
  }

  // optional .SC2APIProtocol.ImageData creep = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::creep(this),
        _Internal::creep(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.MapState)
  return target;
}

size_t MapState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.MapState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SC2APIProtocol.ImageData visibility = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.visibility_);
    }

    // optional .SC2APIProtocol.ImageData creep = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.creep_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MapState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MapState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MapState::GetClassData() const { return &_class_data_; }


void MapState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MapState*>(&to_msg);
  auto& from = static_cast<const MapState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.MapState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_visibility()->::SC2APIProtocol::ImageData::MergeFrom(
          from._internal_visibility());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_creep()->::SC2APIProtocol::ImageData::MergeFrom(
          from._internal_creep());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MapState::CopyFrom(const MapState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.MapState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapState::IsInitialized() const {
  return true;
}

void MapState::InternalSwap(MapState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapState, _impl_.creep_)
      + sizeof(MapState::_impl_.creep_)
      - PROTOBUF_FIELD_OFFSET(MapState, _impl_.visibility_)>(
          reinterpret_cast<char*>(&_impl_.visibility_),
          reinterpret_cast<char*>(&other->_impl_.visibility_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MapState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[9]);
}

// ===================================================================

class Event::_Internal {
 public:
};

Event::Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Event* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dead_units_){from._impl_.dead_units_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.Event)
}

inline void Event::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dead_units_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.Event)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Event::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dead_units_.~RepeatedField();
}

void Event::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.Event)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dead_units_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Event::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 dead_units = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dead_units(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_dead_units(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Event::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.Event)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 dead_units = 1;
  for (int i = 0, n = this->_internal_dead_units_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dead_units(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.Event)
  return target;
}

size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.Event)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 dead_units = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.dead_units_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_dead_units_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Event::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Event::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Event::GetClassData() const { return &_class_data_; }


void Event::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Event*>(&to_msg);
  auto& from = static_cast<const Event&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.Event)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dead_units_.MergeFrom(from._impl_.dead_units_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dead_units_.InternalSwap(&other->_impl_.dead_units_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Event::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[10]);
}

// ===================================================================

class Effect::_Internal {
 public:
  using HasBits = decltype(std::declval<Effect>()._impl_._has_bits_);
  static void set_has_effect_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alliance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

void Effect::clear_pos() {
  _impl_.pos_.Clear();
}
Effect::Effect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.Effect)
}
Effect::Effect(const Effect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Effect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){from._impl_.pos_}
    , decltype(_impl_.effect_id_){}
    , decltype(_impl_.owner_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.alliance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.effect_id_, &from._impl_.effect_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.alliance_) -
    reinterpret_cast<char*>(&_impl_.effect_id_)) + sizeof(_impl_.alliance_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.Effect)
}

inline void Effect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){arena}
    , decltype(_impl_.effect_id_){0u}
    , decltype(_impl_.owner_){0}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.alliance_){1}
  };
}

Effect::~Effect() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.Effect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Effect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pos_.~RepeatedPtrField();
}

void Effect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Effect::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.Effect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pos_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.effect_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.radius_) -
        reinterpret_cast<char*>(&_impl_.effect_id_)) + sizeof(_impl_.radius_));
    _impl_.alliance_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Effect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 effect_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_effect_id(&has_bits);
          _impl_.effect_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Point2D pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Alliance alliance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Alliance_IsValid(val))) {
            _internal_set_alliance(static_cast<::SC2APIProtocol::Alliance>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 owner = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_owner(&has_bits);
          _impl_.owner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Effect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.Effect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 effect_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_effect_id(), target);
  }

  // repeated .SC2APIProtocol.Point2D pos = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pos_size()); i < n; i++) {
    const auto& repfield = this->_internal_pos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .SC2APIProtocol.Alliance alliance = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_alliance(), target);
  }

  // optional int32 owner = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_owner(), target);
  }

  // optional float radius = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.Effect)
  return target;
}

size_t Effect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.Effect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.Point2D pos = 2;
  total_size += 1UL * this->_internal_pos_size();
  for (const auto& msg : this->_impl_.pos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 effect_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_effect_id());
    }

    // optional int32 owner = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_owner());
    }

    // optional float radius = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.Alliance alliance = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_alliance());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Effect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Effect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Effect::GetClassData() const { return &_class_data_; }


void Effect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Effect*>(&to_msg);
  auto& from = static_cast<const Effect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.Effect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pos_.MergeFrom(from._impl_.pos_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.effect_id_ = from._impl_.effect_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.owner_ = from._impl_.owner_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.alliance_ = from._impl_.alliance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Effect::CopyFrom(const Effect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.Effect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Effect::IsInitialized() const {
  return true;
}

void Effect::InternalSwap(Effect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pos_.InternalSwap(&other->_impl_.pos_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Effect, _impl_.radius_)
      + sizeof(Effect::_impl_.radius_)
      - PROTOBUF_FIELD_OFFSET(Effect, _impl_.effect_id_)>(
          reinterpret_cast<char*>(&_impl_.effect_id_),
          reinterpret_cast<char*>(&other->_impl_.effect_id_));
  swap(_impl_.alliance_, other->_impl_.alliance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Effect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[11]);
}

// ===================================================================

class ActionRaw::_Internal {
 public:
  static const ::SC2APIProtocol::ActionRawUnitCommand& unit_command(const ActionRaw* msg);
  static const ::SC2APIProtocol::ActionRawCameraMove& camera_move(const ActionRaw* msg);
  static const ::SC2APIProtocol::ActionRawToggleAutocast& toggle_autocast(const ActionRaw* msg);
};

const ::SC2APIProtocol::ActionRawUnitCommand&
ActionRaw::_Internal::unit_command(const ActionRaw* msg) {
  return *msg->_impl_.action_.unit_command_;
}
const ::SC2APIProtocol::ActionRawCameraMove&
ActionRaw::_Internal::camera_move(const ActionRaw* msg) {
  return *msg->_impl_.action_.camera_move_;
}
const ::SC2APIProtocol::ActionRawToggleAutocast&
ActionRaw::_Internal::toggle_autocast(const ActionRaw* msg) {
  return *msg->_impl_.action_.toggle_autocast_;
}
void ActionRaw::set_allocated_unit_command(::SC2APIProtocol::ActionRawUnitCommand* unit_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (unit_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unit_command);
    if (message_arena != submessage_arena) {
      unit_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_command, submessage_arena);
    }
    set_has_unit_command();
    _impl_.action_.unit_command_ = unit_command;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.unit_command)
}
void ActionRaw::set_allocated_camera_move(::SC2APIProtocol::ActionRawCameraMove* camera_move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (camera_move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_move);
    if (message_arena != submessage_arena) {
      camera_move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_move, submessage_arena);
    }
    set_has_camera_move();
    _impl_.action_.camera_move_ = camera_move;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.camera_move)
}
void ActionRaw::set_allocated_toggle_autocast(::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action();
  if (toggle_autocast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(toggle_autocast);
    if (message_arena != submessage_arena) {
      toggle_autocast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, toggle_autocast, submessage_arena);
    }
    set_has_toggle_autocast();
    _impl_.action_.toggle_autocast_ = toggle_autocast;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.toggle_autocast)
}
ActionRaw::ActionRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.ActionRaw)
}
ActionRaw::ActionRaw(const ActionRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActionRaw* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_action();
  switch (from.action_case()) {
    case kUnitCommand: {
      _this->_internal_mutable_unit_command()->::SC2APIProtocol::ActionRawUnitCommand::MergeFrom(
          from._internal_unit_command());
      break;
    }
    case kCameraMove: {
      _this->_internal_mutable_camera_move()->::SC2APIProtocol::ActionRawCameraMove::MergeFrom(
          from._internal_camera_move());
      break;
    }
    case kToggleAutocast: {
      _this->_internal_mutable_toggle_autocast()->::SC2APIProtocol::ActionRawToggleAutocast::MergeFrom(
          from._internal_toggle_autocast());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ActionRaw)
}

inline void ActionRaw::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_action();
}

ActionRaw::~ActionRaw() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ActionRaw)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionRaw::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_action()) {
    clear_action();
  }
}

void ActionRaw::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActionRaw::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:SC2APIProtocol.ActionRaw)
  switch (action_case()) {
    case kUnitCommand: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.unit_command_;
      }
      break;
    }
    case kCameraMove: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.camera_move_;
      }
      break;
    }
    case kToggleAutocast: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.action_.toggle_autocast_;
      }
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}


void ActionRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ActionRaw)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_action();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActionRaw::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_unit_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SC2APIProtocol.ActionRawCameraMove camera_move = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera_move(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_toggle_autocast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionRaw::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ActionRaw)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (action_case()) {
    case kUnitCommand: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::unit_command(this),
          _Internal::unit_command(this).GetCachedSize(), target, stream);
      break;
    }
    case kCameraMove: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::camera_move(this),
          _Internal::camera_move(this).GetCachedSize(), target, stream);
      break;
    }
    case kToggleAutocast: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::toggle_autocast(this),
          _Internal::toggle_autocast(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ActionRaw)
  return target;
}

size_t ActionRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ActionRaw)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (action_case()) {
    // .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;
    case kUnitCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.unit_command_);
      break;
    }
    // .SC2APIProtocol.ActionRawCameraMove camera_move = 2;
    case kCameraMove: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.camera_move_);
      break;
    }
    // .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
    case kToggleAutocast: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_.toggle_autocast_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActionRaw::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActionRaw::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActionRaw::GetClassData() const { return &_class_data_; }


void ActionRaw::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActionRaw*>(&to_msg);
  auto& from = static_cast<const ActionRaw&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ActionRaw)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.action_case()) {
    case kUnitCommand: {
      _this->_internal_mutable_unit_command()->::SC2APIProtocol::ActionRawUnitCommand::MergeFrom(
          from._internal_unit_command());
      break;
    }
    case kCameraMove: {
      _this->_internal_mutable_camera_move()->::SC2APIProtocol::ActionRawCameraMove::MergeFrom(
          from._internal_camera_move());
      break;
    }
    case kToggleAutocast: {
      _this->_internal_mutable_toggle_autocast()->::SC2APIProtocol::ActionRawToggleAutocast::MergeFrom(
          from._internal_toggle_autocast());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActionRaw::CopyFrom(const ActionRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ActionRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRaw::IsInitialized() const {
  return true;
}

void ActionRaw::InternalSwap(ActionRaw* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.action_, other->_impl_.action_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRaw::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[12]);
}

// ===================================================================

class ActionRawUnitCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionRawUnitCommand>()._impl_._has_bits_);
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::Point2D& target_world_space_pos(const ActionRawUnitCommand* msg);
  static void set_has_queue_command(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point2D&
ActionRawUnitCommand::_Internal::target_world_space_pos(const ActionRawUnitCommand* msg) {
  return *msg->_impl_.target_.target_world_space_pos_;
}
void ActionRawUnitCommand::set_allocated_target_world_space_pos(::SC2APIProtocol::Point2D* target_world_space_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_target();
  if (target_world_space_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_world_space_pos));
    if (message_arena != submessage_arena) {
      target_world_space_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_world_space_pos, submessage_arena);
    }
    set_has_target_world_space_pos();
    _impl_.target_.target_world_space_pos_ = target_world_space_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
}
void ActionRawUnitCommand::clear_target_world_space_pos() {
  if (_internal_has_target_world_space_pos()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.target_.target_world_space_pos_;
    }
    clear_has_target();
  }
}
ActionRawUnitCommand::ActionRawUnitCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.ActionRawUnitCommand)
}
ActionRawUnitCommand::ActionRawUnitCommand(const ActionRawUnitCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActionRawUnitCommand* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_tags_){from._impl_.unit_tags_}
    , decltype(_impl_.ability_id_){}
    , decltype(_impl_.queue_command_){}
    , decltype(_impl_.target_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ability_id_, &from._impl_.ability_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.queue_command_) -
    reinterpret_cast<char*>(&_impl_.ability_id_)) + sizeof(_impl_.queue_command_));
  clear_has_target();
  switch (from.target_case()) {
    case kTargetWorldSpacePos: {
      _this->_internal_mutable_target_world_space_pos()->::SC2APIProtocol::Point2D::MergeFrom(
          from._internal_target_world_space_pos());
      break;
    }
    case kTargetUnitTag: {
      _this->_internal_set_target_unit_tag(from._internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ActionRawUnitCommand)
}

inline void ActionRawUnitCommand::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_tags_){arena}
    , decltype(_impl_.ability_id_){0}
    , decltype(_impl_.queue_command_){false}
    , decltype(_impl_.target_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_target();
}

ActionRawUnitCommand::~ActionRawUnitCommand() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ActionRawUnitCommand)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionRawUnitCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.unit_tags_.~RepeatedField();
  if (has_target()) {
    clear_target();
  }
}

void ActionRawUnitCommand::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActionRawUnitCommand::clear_target() {
// @@protoc_insertion_point(one_of_clear_start:SC2APIProtocol.ActionRawUnitCommand)
  switch (target_case()) {
    case kTargetWorldSpacePos: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.target_.target_world_space_pos_;
      }
      break;
    }
    case kTargetUnitTag: {
      // No need to clear
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}


void ActionRawUnitCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ActionRawUnitCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.unit_tags_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ability_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.queue_command_) -
        reinterpret_cast<char*>(&_impl_.ability_id_)) + sizeof(_impl_.queue_command_));
  }
  clear_target();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActionRawUnitCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 ability_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ability_id(&has_bits);
          _impl_.ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SC2APIProtocol.Point2D target_world_space_pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_world_space_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 target_unit_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_target_unit_tag(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 unit_tags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_unit_tags(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_unit_tags(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool queue_command = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_queue_command(&has_bits);
          _impl_.queue_command_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionRawUnitCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ActionRawUnitCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 ability_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ability_id(), target);
  }

  switch (target_case()) {
    case kTargetWorldSpacePos: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::target_world_space_pos(this),
          _Internal::target_world_space_pos(this).GetCachedSize(), target, stream);
      break;
    }
    case kTargetUnitTag: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_target_unit_tag(), target);
      break;
    }
    default: ;
  }
  // repeated uint64 unit_tags = 4;
  for (int i = 0, n = this->_internal_unit_tags_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_unit_tags(i), target);
  }

  // optional bool queue_command = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_queue_command(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ActionRawUnitCommand)
  return target;
}

size_t ActionRawUnitCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ActionRawUnitCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 unit_tags = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.unit_tags_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_unit_tags_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 ability_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ability_id());
    }

    // optional bool queue_command = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  switch (target_case()) {
    // .SC2APIProtocol.Point2D target_world_space_pos = 2;
    case kTargetWorldSpacePos: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_.target_world_space_pos_);
      break;
    }
    // uint64 target_unit_tag = 3;
    case kTargetUnitTag: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActionRawUnitCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActionRawUnitCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActionRawUnitCommand::GetClassData() const { return &_class_data_; }


void ActionRawUnitCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActionRawUnitCommand*>(&to_msg);
  auto& from = static_cast<const ActionRawUnitCommand&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ActionRawUnitCommand)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.unit_tags_.MergeFrom(from._impl_.unit_tags_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ability_id_ = from._impl_.ability_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.queue_command_ = from._impl_.queue_command_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.target_case()) {
    case kTargetWorldSpacePos: {
      _this->_internal_mutable_target_world_space_pos()->::SC2APIProtocol::Point2D::MergeFrom(
          from._internal_target_world_space_pos());
      break;
    }
    case kTargetUnitTag: {
      _this->_internal_set_target_unit_tag(from._internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActionRawUnitCommand::CopyFrom(const ActionRawUnitCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ActionRawUnitCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRawUnitCommand::IsInitialized() const {
  return true;
}

void ActionRawUnitCommand::InternalSwap(ActionRawUnitCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.unit_tags_.InternalSwap(&other->_impl_.unit_tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActionRawUnitCommand, _impl_.queue_command_)
      + sizeof(ActionRawUnitCommand::_impl_.queue_command_)
      - PROTOBUF_FIELD_OFFSET(ActionRawUnitCommand, _impl_.ability_id_)>(
          reinterpret_cast<char*>(&_impl_.ability_id_),
          reinterpret_cast<char*>(&other->_impl_.ability_id_));
  swap(_impl_.target_, other->_impl_.target_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRawUnitCommand::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[13]);
}

// ===================================================================

class ActionRawCameraMove::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionRawCameraMove>()._impl_._has_bits_);
  static const ::SC2APIProtocol::Point& center_world_space(const ActionRawCameraMove* msg);
  static void set_has_center_world_space(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SC2APIProtocol::Point&
ActionRawCameraMove::_Internal::center_world_space(const ActionRawCameraMove* msg) {
  return *msg->_impl_.center_world_space_;
}
void ActionRawCameraMove::clear_center_world_space() {
  if (_impl_.center_world_space_ != nullptr) _impl_.center_world_space_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ActionRawCameraMove::ActionRawCameraMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.ActionRawCameraMove)
}
ActionRawCameraMove::ActionRawCameraMove(const ActionRawCameraMove& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActionRawCameraMove* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.center_world_space_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_center_world_space()) {
    _this->_impl_.center_world_space_ = new ::SC2APIProtocol::Point(*from._impl_.center_world_space_);
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ActionRawCameraMove)
}

inline void ActionRawCameraMove::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.center_world_space_){nullptr}
  };
}

ActionRawCameraMove::~ActionRawCameraMove() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ActionRawCameraMove)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionRawCameraMove::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.center_world_space_;
}

void ActionRawCameraMove::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActionRawCameraMove::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ActionRawCameraMove)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.center_world_space_ != nullptr);
    _impl_.center_world_space_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActionRawCameraMove::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Point center_world_space = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_center_world_space(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionRawCameraMove::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ActionRawCameraMove)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.Point center_world_space = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::center_world_space(this),
        _Internal::center_world_space(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ActionRawCameraMove)
  return target;
}

size_t ActionRawCameraMove::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ActionRawCameraMove)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .SC2APIProtocol.Point center_world_space = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.center_world_space_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActionRawCameraMove::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActionRawCameraMove::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActionRawCameraMove::GetClassData() const { return &_class_data_; }


void ActionRawCameraMove::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActionRawCameraMove*>(&to_msg);
  auto& from = static_cast<const ActionRawCameraMove&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ActionRawCameraMove)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_center_world_space()) {
    _this->_internal_mutable_center_world_space()->::SC2APIProtocol::Point::MergeFrom(
        from._internal_center_world_space());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActionRawCameraMove::CopyFrom(const ActionRawCameraMove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ActionRawCameraMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRawCameraMove::IsInitialized() const {
  return true;
}

void ActionRawCameraMove::InternalSwap(ActionRawCameraMove* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.center_world_space_, other->_impl_.center_world_space_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRawCameraMove::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[14]);
}

// ===================================================================

class ActionRawToggleAutocast::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionRawToggleAutocast>()._impl_._has_bits_);
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ActionRawToggleAutocast::ActionRawToggleAutocast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.ActionRawToggleAutocast)
}
ActionRawToggleAutocast::ActionRawToggleAutocast(const ActionRawToggleAutocast& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActionRawToggleAutocast* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_tags_){from._impl_.unit_tags_}
    , decltype(_impl_.ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ability_id_ = from._impl_.ability_id_;
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ActionRawToggleAutocast)
}

inline void ActionRawToggleAutocast::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_tags_){arena}
    , decltype(_impl_.ability_id_){0}
  };
}

ActionRawToggleAutocast::~ActionRawToggleAutocast() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ActionRawToggleAutocast)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionRawToggleAutocast::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.unit_tags_.~RepeatedField();
}

void ActionRawToggleAutocast::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActionRawToggleAutocast::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ActionRawToggleAutocast)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.unit_tags_.Clear();
  _impl_.ability_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActionRawToggleAutocast::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 ability_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ability_id(&has_bits);
          _impl_.ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 unit_tags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_unit_tags(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_unit_tags(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionRawToggleAutocast::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ActionRawToggleAutocast)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 ability_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ability_id(), target);
  }

  // repeated uint64 unit_tags = 2;
  for (int i = 0, n = this->_internal_unit_tags_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_unit_tags(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ActionRawToggleAutocast)
  return target;
}

size_t ActionRawToggleAutocast::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ActionRawToggleAutocast)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 unit_tags = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.unit_tags_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_unit_tags_size());
    total_size += data_size;
  }

  // optional int32 ability_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ability_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActionRawToggleAutocast::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActionRawToggleAutocast::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActionRawToggleAutocast::GetClassData() const { return &_class_data_; }


void ActionRawToggleAutocast::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActionRawToggleAutocast*>(&to_msg);
  auto& from = static_cast<const ActionRawToggleAutocast&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ActionRawToggleAutocast)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.unit_tags_.MergeFrom(from._impl_.unit_tags_);
  if (from._internal_has_ability_id()) {
    _this->_internal_set_ability_id(from._internal_ability_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActionRawToggleAutocast::CopyFrom(const ActionRawToggleAutocast& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ActionRawToggleAutocast)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRawToggleAutocast::IsInitialized() const {
  return true;
}

void ActionRawToggleAutocast::InternalSwap(ActionRawToggleAutocast* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.unit_tags_.InternalSwap(&other->_impl_.unit_tags_);
  swap(_impl_.ability_id_, other->_impl_.ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRawToggleAutocast::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fraw_2eproto_getter, &descriptor_table_s2clientprotocol_2fraw_2eproto_once,
      file_level_metadata_s2clientprotocol_2fraw_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::StartRaw*
Arena::CreateMaybeMessage< ::SC2APIProtocol::StartRaw >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::StartRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ObservationRaw*
Arena::CreateMaybeMessage< ::SC2APIProtocol::ObservationRaw >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::ObservationRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::RadarRing*
Arena::CreateMaybeMessage< ::SC2APIProtocol::RadarRing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::RadarRing >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::PowerSource*
Arena::CreateMaybeMessage< ::SC2APIProtocol::PowerSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::PowerSource >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::PlayerRaw*
Arena::CreateMaybeMessage< ::SC2APIProtocol::PlayerRaw >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::PlayerRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::UnitOrder*
Arena::CreateMaybeMessage< ::SC2APIProtocol::UnitOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::UnitOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::PassengerUnit*
Arena::CreateMaybeMessage< ::SC2APIProtocol::PassengerUnit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::PassengerUnit >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::RallyTarget*
Arena::CreateMaybeMessage< ::SC2APIProtocol::RallyTarget >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::RallyTarget >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::Unit*
Arena::CreateMaybeMessage< ::SC2APIProtocol::Unit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::Unit >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::MapState*
Arena::CreateMaybeMessage< ::SC2APIProtocol::MapState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::MapState >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::Event*
Arena::CreateMaybeMessage< ::SC2APIProtocol::Event >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::Effect*
Arena::CreateMaybeMessage< ::SC2APIProtocol::Effect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::Effect >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ActionRaw*
Arena::CreateMaybeMessage< ::SC2APIProtocol::ActionRaw >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::ActionRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ActionRawUnitCommand*
Arena::CreateMaybeMessage< ::SC2APIProtocol::ActionRawUnitCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::ActionRawUnitCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ActionRawCameraMove*
Arena::CreateMaybeMessage< ::SC2APIProtocol::ActionRawCameraMove >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::ActionRawCameraMove >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ActionRawToggleAutocast*
Arena::CreateMaybeMessage< ::SC2APIProtocol::ActionRawToggleAutocast >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::ActionRawToggleAutocast >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
