// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/data.proto

#include "s2clientprotocol/data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace SC2APIProtocol {
PROTOBUF_CONSTEXPR AbilityData::AbilityData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.link_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.button_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.friendly_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hotkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ability_id_)*/0u
  , /*decltype(_impl_.link_index_)*/0u
  , /*decltype(_impl_.remaps_to_ability_id_)*/0u
  , /*decltype(_impl_.available_)*/false
  , /*decltype(_impl_.allow_minimap_)*/false
  , /*decltype(_impl_.allow_autocast_)*/false
  , /*decltype(_impl_.is_building_)*/false
  , /*decltype(_impl_.footprint_radius_)*/0
  , /*decltype(_impl_.is_instant_placement_)*/false
  , /*decltype(_impl_.cast_range_)*/0
  , /*decltype(_impl_.target_)*/1} {}
struct AbilityDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AbilityDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AbilityDataDefaultTypeInternal() {}
  union {
    AbilityData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AbilityDataDefaultTypeInternal _AbilityData_default_instance_;
PROTOBUF_CONSTEXPR DamageBonus::DamageBonus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bonus_)*/0
  , /*decltype(_impl_.attribute_)*/1} {}
struct DamageBonusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DamageBonusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DamageBonusDefaultTypeInternal() {}
  union {
    DamageBonus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DamageBonusDefaultTypeInternal _DamageBonus_default_instance_;
PROTOBUF_CONSTEXPR Weapon::Weapon(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.damage_bonus_)*/{}
  , /*decltype(_impl_.damage_)*/0
  , /*decltype(_impl_.attacks_)*/0u
  , /*decltype(_impl_.range_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.type_)*/1} {}
struct WeaponDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WeaponDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WeaponDefaultTypeInternal() {}
  union {
    Weapon _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WeaponDefaultTypeInternal _Weapon_default_instance_;
PROTOBUF_CONSTEXPR UnitTypeData::UnitTypeData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attributes_)*/{}
  , /*decltype(_impl_.weapons_)*/{}
  , /*decltype(_impl_.tech_alias_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unit_id_)*/0u
  , /*decltype(_impl_.cargo_size_)*/0u
  , /*decltype(_impl_.movement_speed_)*/0
  , /*decltype(_impl_.armor_)*/0
  , /*decltype(_impl_.mineral_cost_)*/0u
  , /*decltype(_impl_.vespene_cost_)*/0u
  , /*decltype(_impl_.food_required_)*/0
  , /*decltype(_impl_.ability_id_)*/0u
  , /*decltype(_impl_.race_)*/0
  , /*decltype(_impl_.available_)*/false
  , /*decltype(_impl_.has_vespene_)*/false
  , /*decltype(_impl_.has_minerals_)*/false
  , /*decltype(_impl_.require_attached_)*/false
  , /*decltype(_impl_.build_time_)*/0
  , /*decltype(_impl_.food_provided_)*/0
  , /*decltype(_impl_.unit_alias_)*/0u
  , /*decltype(_impl_.tech_requirement_)*/0u
  , /*decltype(_impl_.sight_range_)*/0} {}
struct UnitTypeDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnitTypeDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnitTypeDataDefaultTypeInternal() {}
  union {
    UnitTypeData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnitTypeDataDefaultTypeInternal _UnitTypeData_default_instance_;
PROTOBUF_CONSTEXPR UpgradeData::UpgradeData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.upgrade_id_)*/0u
  , /*decltype(_impl_.mineral_cost_)*/0u
  , /*decltype(_impl_.vespene_cost_)*/0u
  , /*decltype(_impl_.research_time_)*/0
  , /*decltype(_impl_.ability_id_)*/0u} {}
struct UpgradeDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpgradeDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpgradeDataDefaultTypeInternal() {}
  union {
    UpgradeData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpgradeDataDefaultTypeInternal _UpgradeData_default_instance_;
PROTOBUF_CONSTEXPR BuffData::BuffData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.buff_id_)*/0u} {}
struct BuffDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BuffDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BuffDataDefaultTypeInternal() {}
  union {
    BuffData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BuffDataDefaultTypeInternal _BuffData_default_instance_;
PROTOBUF_CONSTEXPR EffectData::EffectData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.friendly_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.effect_id_)*/0u
  , /*decltype(_impl_.radius_)*/0} {}
struct EffectDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EffectDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EffectDataDefaultTypeInternal() {}
  union {
    EffectData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EffectDataDefaultTypeInternal _EffectData_default_instance_;
}  // namespace SC2APIProtocol
static ::_pb::Metadata file_level_metadata_s2clientprotocol_2fdata_2eproto[7];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_s2clientprotocol_2fdata_2eproto = nullptr;

const uint32_t TableStruct_s2clientprotocol_2fdata_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.ability_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.link_name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.link_index_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.button_name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.friendly_name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.hotkey_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.remaps_to_ability_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.available_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.allow_minimap_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.allow_autocast_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.is_building_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.footprint_radius_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.is_instant_placement_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _impl_.cast_range_),
  4,
  0,
  5,
  1,
  2,
  3,
  6,
  7,
  14,
  8,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::DamageBonus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::DamageBonus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::DamageBonus, _impl_.attribute_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::DamageBonus, _impl_.bonus_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _impl_.damage_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _impl_.damage_bonus_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _impl_.attacks_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _impl_.range_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _impl_.speed_),
  4,
  0,
  ~0u,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.unit_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.available_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.cargo_size_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.mineral_cost_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.vespene_cost_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.food_required_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.food_provided_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.ability_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.race_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.build_time_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.has_vespene_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.has_minerals_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.sight_range_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.tech_alias_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.unit_alias_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.tech_requirement_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.require_attached_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.attributes_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.movement_speed_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.armor_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _impl_.weapons_),
  1,
  0,
  10,
  2,
  5,
  6,
  7,
  15,
  8,
  9,
  14,
  11,
  12,
  18,
  ~0u,
  16,
  17,
  13,
  ~0u,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _impl_.upgrade_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _impl_.mineral_cost_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _impl_.vespene_cost_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _impl_.research_time_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _impl_.ability_id_),
  1,
  0,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::BuffData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::BuffData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::BuffData, _impl_.buff_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::BuffData, _impl_.name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, _impl_.effect_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, _impl_.friendly_name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, _impl_.radius_),
  2,
  0,
  1,
  3,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 21, -1, sizeof(::SC2APIProtocol::AbilityData)},
  { 36, 44, -1, sizeof(::SC2APIProtocol::DamageBonus)},
  { 46, 58, -1, sizeof(::SC2APIProtocol::Weapon)},
  { 64, 92, -1, sizeof(::SC2APIProtocol::UnitTypeData)},
  { 114, 126, -1, sizeof(::SC2APIProtocol::UpgradeData)},
  { 132, 140, -1, sizeof(::SC2APIProtocol::BuffData)},
  { 142, 152, -1, sizeof(::SC2APIProtocol::EffectData)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::SC2APIProtocol::_AbilityData_default_instance_._instance,
  &::SC2APIProtocol::_DamageBonus_default_instance_._instance,
  &::SC2APIProtocol::_Weapon_default_instance_._instance,
  &::SC2APIProtocol::_UnitTypeData_default_instance_._instance,
  &::SC2APIProtocol::_UpgradeData_default_instance_._instance,
  &::SC2APIProtocol::_BuffData_default_instance_._instance,
  &::SC2APIProtocol::_EffectData_default_instance_._instance,
};

const char descriptor_table_protodef_s2clientprotocol_2fdata_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\033s2clientprotocol/data.proto\022\016SC2APIPro"
  "tocol\032\035s2clientprotocol/common.proto\"\304\003\n"
  "\013AbilityData\022\022\n\nability_id\030\001 \001(\r\022\021\n\tlink"
  "_name\030\002 \001(\t\022\022\n\nlink_index\030\003 \001(\r\022\023\n\013butto"
  "n_name\030\004 \001(\t\022\025\n\rfriendly_name\030\005 \001(\t\022\016\n\006h"
  "otkey\030\006 \001(\t\022\034\n\024remaps_to_ability_id\030\007 \001("
  "\r\022\021\n\tavailable\030\010 \001(\010\0222\n\006target\030\t \001(\0162\".S"
  "C2APIProtocol.AbilityData.Target\022\025\n\rallo"
  "w_minimap\030\n \001(\010\022\026\n\016allow_autocast\030\013 \001(\010\022"
  "\023\n\013is_building\030\014 \001(\010\022\030\n\020footprint_radius"
  "\030\r \001(\002\022\034\n\024is_instant_placement\030\016 \001(\010\022\022\n\n"
  "cast_range\030\017 \001(\002\"I\n\006Target\022\010\n\004None\020\001\022\t\n\005"
  "Point\020\002\022\010\n\004Unit\020\003\022\017\n\013PointOrUnit\020\004\022\017\n\013Po"
  "intOrNone\020\005\"J\n\013DamageBonus\022,\n\tattribute\030"
  "\001 \001(\0162\031.SC2APIProtocol.Attribute\022\r\n\005bonu"
  "s\030\002 \001(\002\"\327\001\n\006Weapon\022/\n\004type\030\001 \001(\0162!.SC2AP"
  "IProtocol.Weapon.TargetType\022\016\n\006damage\030\002 "
  "\001(\002\0221\n\014damage_bonus\030\003 \003(\0132\033.SC2APIProtoc"
  "ol.DamageBonus\022\017\n\007attacks\030\004 \001(\r\022\r\n\005range"
  "\030\005 \001(\002\022\r\n\005speed\030\006 \001(\002\"*\n\nTargetType\022\n\n\006G"
  "round\020\001\022\007\n\003Air\020\002\022\007\n\003Any\020\003\"\225\004\n\014UnitTypeDa"
  "ta\022\017\n\007unit_id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022\021\n\tava"
  "ilable\030\003 \001(\010\022\022\n\ncargo_size\030\004 \001(\r\022\024\n\014mine"
  "ral_cost\030\014 \001(\r\022\024\n\014vespene_cost\030\r \001(\r\022\025\n\r"
  "food_required\030\016 \001(\002\022\025\n\rfood_provided\030\022 \001"
  "(\002\022\022\n\nability_id\030\017 \001(\r\022\"\n\004race\030\020 \001(\0162\024.S"
  "C2APIProtocol.Race\022\022\n\nbuild_time\030\021 \001(\002\022\023"
  "\n\013has_vespene\030\023 \001(\010\022\024\n\014has_minerals\030\024 \001("
  "\010\022\023\n\013sight_range\030\031 \001(\002\022\022\n\ntech_alias\030\025 \003"
  "(\r\022\022\n\nunit_alias\030\026 \001(\r\022\030\n\020tech_requireme"
  "nt\030\027 \001(\r\022\030\n\020require_attached\030\030 \001(\010\022-\n\nat"
  "tributes\030\010 \003(\0162\031.SC2APIProtocol.Attribut"
  "e\022\026\n\016movement_speed\030\t \001(\002\022\r\n\005armor\030\n \001(\002"
  "\022\'\n\007weapons\030\013 \003(\0132\026.SC2APIProtocol.Weapo"
  "n\"\206\001\n\013UpgradeData\022\022\n\nupgrade_id\030\001 \001(\r\022\014\n"
  "\004name\030\002 \001(\t\022\024\n\014mineral_cost\030\003 \001(\r\022\024\n\014ves"
  "pene_cost\030\004 \001(\r\022\025\n\rresearch_time\030\005 \001(\002\022\022"
  "\n\nability_id\030\006 \001(\r\")\n\010BuffData\022\017\n\007buff_i"
  "d\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\"T\n\nEffectData\022\021\n\te"
  "ffect_id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022\025\n\rfriendly"
  "_name\030\003 \001(\t\022\016\n\006radius\030\004 \001(\002*\236\001\n\tAttribut"
  "e\022\t\n\005Light\020\001\022\013\n\007Armored\020\002\022\016\n\nBiological\020"
  "\003\022\016\n\nMechanical\020\004\022\013\n\007Robotic\020\005\022\013\n\007Psioni"
  "c\020\006\022\013\n\007Massive\020\007\022\r\n\tStructure\020\010\022\t\n\005Hover"
  "\020\t\022\n\n\006Heroic\020\n\022\014\n\010Summoned\020\013"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_s2clientprotocol_2fdata_2eproto_deps[1] = {
  &::descriptor_table_s2clientprotocol_2fcommon_2eproto,
};
static ::_pbi::once_flag descriptor_table_s2clientprotocol_2fdata_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_s2clientprotocol_2fdata_2eproto = {
    false, false, 1788, descriptor_table_protodef_s2clientprotocol_2fdata_2eproto,
    "s2clientprotocol/data.proto",
    &descriptor_table_s2clientprotocol_2fdata_2eproto_once, descriptor_table_s2clientprotocol_2fdata_2eproto_deps, 1, 7,
    schemas, file_default_instances, TableStruct_s2clientprotocol_2fdata_2eproto::offsets,
    file_level_metadata_s2clientprotocol_2fdata_2eproto, file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto,
    file_level_service_descriptors_s2clientprotocol_2fdata_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_s2clientprotocol_2fdata_2eproto_getter() {
  return &descriptor_table_s2clientprotocol_2fdata_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_s2clientprotocol_2fdata_2eproto(&descriptor_table_s2clientprotocol_2fdata_2eproto);
namespace SC2APIProtocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AbilityData_Target_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fdata_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto[0];
}
bool AbilityData_Target_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AbilityData_Target AbilityData::None;
constexpr AbilityData_Target AbilityData::Point;
constexpr AbilityData_Target AbilityData::Unit;
constexpr AbilityData_Target AbilityData::PointOrUnit;
constexpr AbilityData_Target AbilityData::PointOrNone;
constexpr AbilityData_Target AbilityData::Target_MIN;
constexpr AbilityData_Target AbilityData::Target_MAX;
constexpr int AbilityData::Target_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Weapon_TargetType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fdata_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto[1];
}
bool Weapon_TargetType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Weapon_TargetType Weapon::Ground;
constexpr Weapon_TargetType Weapon::Air;
constexpr Weapon_TargetType Weapon::Any;
constexpr Weapon_TargetType Weapon::TargetType_MIN;
constexpr Weapon_TargetType Weapon::TargetType_MAX;
constexpr int Weapon::TargetType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Attribute_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fdata_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto[2];
}
bool Attribute_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class AbilityData::_Internal {
 public:
  using HasBits = decltype(std::declval<AbilityData>()._impl_._has_bits_);
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_button_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hotkey(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remaps_to_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_available(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_target(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_allow_minimap(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_allow_autocast(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_building(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_footprint_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_instant_placement(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_cast_range(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

AbilityData::AbilityData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.AbilityData)
}
AbilityData::AbilityData(const AbilityData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AbilityData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.link_name_){}
    , decltype(_impl_.button_name_){}
    , decltype(_impl_.friendly_name_){}
    , decltype(_impl_.hotkey_){}
    , decltype(_impl_.ability_id_){}
    , decltype(_impl_.link_index_){}
    , decltype(_impl_.remaps_to_ability_id_){}
    , decltype(_impl_.available_){}
    , decltype(_impl_.allow_minimap_){}
    , decltype(_impl_.allow_autocast_){}
    , decltype(_impl_.is_building_){}
    , decltype(_impl_.footprint_radius_){}
    , decltype(_impl_.is_instant_placement_){}
    , decltype(_impl_.cast_range_){}
    , decltype(_impl_.target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.link_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.link_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_link_name()) {
    _this->_impl_.link_name_.Set(from._internal_link_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.button_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.button_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_button_name()) {
    _this->_impl_.button_name_.Set(from._internal_button_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.friendly_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_friendly_name()) {
    _this->_impl_.friendly_name_.Set(from._internal_friendly_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hotkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hotkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hotkey()) {
    _this->_impl_.hotkey_.Set(from._internal_hotkey(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ability_id_, &from._impl_.ability_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_) -
    reinterpret_cast<char*>(&_impl_.ability_id_)) + sizeof(_impl_.target_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.AbilityData)
}

inline void AbilityData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.link_name_){}
    , decltype(_impl_.button_name_){}
    , decltype(_impl_.friendly_name_){}
    , decltype(_impl_.hotkey_){}
    , decltype(_impl_.ability_id_){0u}
    , decltype(_impl_.link_index_){0u}
    , decltype(_impl_.remaps_to_ability_id_){0u}
    , decltype(_impl_.available_){false}
    , decltype(_impl_.allow_minimap_){false}
    , decltype(_impl_.allow_autocast_){false}
    , decltype(_impl_.is_building_){false}
    , decltype(_impl_.footprint_radius_){0}
    , decltype(_impl_.is_instant_placement_){false}
    , decltype(_impl_.cast_range_){0}
    , decltype(_impl_.target_){1}
  };
  _impl_.link_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.link_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.button_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.button_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.friendly_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hotkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hotkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AbilityData::~AbilityData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.AbilityData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AbilityData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.link_name_.Destroy();
  _impl_.button_name_.Destroy();
  _impl_.friendly_name_.Destroy();
  _impl_.hotkey_.Destroy();
}

void AbilityData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AbilityData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.AbilityData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.link_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.button_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.friendly_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.hotkey_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.ability_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.available_) -
        reinterpret_cast<char*>(&_impl_.ability_id_)) + sizeof(_impl_.available_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.allow_minimap_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cast_range_) -
        reinterpret_cast<char*>(&_impl_.allow_minimap_)) + sizeof(_impl_.cast_range_));
    _impl_.target_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbilityData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ability_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ability_id(&has_bits);
          _impl_.ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.AbilityData.link_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 link_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_link_index(&has_bits);
          _impl_.link_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string button_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_button_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.AbilityData.button_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string friendly_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_friendly_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.AbilityData.friendly_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string hotkey = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_hotkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.AbilityData.hotkey");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 remaps_to_ability_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_remaps_to_ability_id(&has_bits);
          _impl_.remaps_to_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool available = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_available(&has_bits);
          _impl_.available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.AbilityData.Target target = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::AbilityData_Target_IsValid(val))) {
            _internal_set_target(static_cast<::SC2APIProtocol::AbilityData_Target>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_minimap = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_allow_minimap(&has_bits);
          _impl_.allow_minimap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_autocast = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_allow_autocast(&has_bits);
          _impl_.allow_autocast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_building = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_is_building(&has_bits);
          _impl_.is_building_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float footprint_radius = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_footprint_radius(&has_bits);
          _impl_.footprint_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_instant_placement = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_is_instant_placement(&has_bits);
          _impl_.is_instant_placement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float cast_range = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_cast_range(&has_bits);
          _impl_.cast_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbilityData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.AbilityData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ability_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ability_id(), target);
  }

  // optional string link_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.AbilityData.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  // optional uint32 link_index = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_link_index(), target);
  }

  // optional string button_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_button_name().data(), static_cast<int>(this->_internal_button_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.AbilityData.button_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_button_name(), target);
  }

  // optional string friendly_name = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friendly_name().data(), static_cast<int>(this->_internal_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.AbilityData.friendly_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_friendly_name(), target);
  }

  // optional string hotkey = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hotkey().data(), static_cast<int>(this->_internal_hotkey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.AbilityData.hotkey");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_hotkey(), target);
  }

  // optional uint32 remaps_to_ability_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_remaps_to_ability_id(), target);
  }

  // optional bool available = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_available(), target);
  }

  // optional .SC2APIProtocol.AbilityData.Target target = 9;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_target(), target);
  }

  // optional bool allow_minimap = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_allow_minimap(), target);
  }

  // optional bool allow_autocast = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_allow_autocast(), target);
  }

  // optional bool is_building = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_building(), target);
  }

  // optional float footprint_radius = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_footprint_radius(), target);
  }

  // optional bool is_instant_placement = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_is_instant_placement(), target);
  }

  // optional float cast_range = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_cast_range(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.AbilityData)
  return target;
}

size_t AbilityData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.AbilityData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string link_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_link_name());
    }

    // optional string button_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_button_name());
    }

    // optional string friendly_name = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friendly_name());
    }

    // optional string hotkey = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hotkey());
    }

    // optional uint32 ability_id = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ability_id());
    }

    // optional uint32 link_index = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_link_index());
    }

    // optional uint32 remaps_to_ability_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_remaps_to_ability_id());
    }

    // optional bool available = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool allow_minimap = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool allow_autocast = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool is_building = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional float footprint_radius = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional bool is_instant_placement = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional float cast_range = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.AbilityData.Target target = 9;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_target());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbilityData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AbilityData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbilityData::GetClassData() const { return &_class_data_; }


void AbilityData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AbilityData*>(&to_msg);
  auto& from = static_cast<const AbilityData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.AbilityData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_link_name(from._internal_link_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_button_name(from._internal_button_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_friendly_name(from._internal_friendly_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_hotkey(from._internal_hotkey());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ability_id_ = from._impl_.ability_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.link_index_ = from._impl_.link_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.remaps_to_ability_id_ = from._impl_.remaps_to_ability_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.available_ = from._impl_.available_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.allow_minimap_ = from._impl_.allow_minimap_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.allow_autocast_ = from._impl_.allow_autocast_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.is_building_ = from._impl_.is_building_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.footprint_radius_ = from._impl_.footprint_radius_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.is_instant_placement_ = from._impl_.is_instant_placement_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.cast_range_ = from._impl_.cast_range_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.target_ = from._impl_.target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbilityData::CopyFrom(const AbilityData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.AbilityData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbilityData::IsInitialized() const {
  return true;
}

void AbilityData::InternalSwap(AbilityData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.link_name_, lhs_arena,
      &other->_impl_.link_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.button_name_, lhs_arena,
      &other->_impl_.button_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.friendly_name_, lhs_arena,
      &other->_impl_.friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hotkey_, lhs_arena,
      &other->_impl_.hotkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AbilityData, _impl_.cast_range_)
      + sizeof(AbilityData::_impl_.cast_range_)
      - PROTOBUF_FIELD_OFFSET(AbilityData, _impl_.ability_id_)>(
          reinterpret_cast<char*>(&_impl_.ability_id_),
          reinterpret_cast<char*>(&other->_impl_.ability_id_));
  swap(_impl_.target_, other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AbilityData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fdata_2eproto_getter, &descriptor_table_s2clientprotocol_2fdata_2eproto_once,
      file_level_metadata_s2clientprotocol_2fdata_2eproto[0]);
}

// ===================================================================

class DamageBonus::_Internal {
 public:
  using HasBits = decltype(std::declval<DamageBonus>()._impl_._has_bits_);
  static void set_has_attribute(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bonus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DamageBonus::DamageBonus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.DamageBonus)
}
DamageBonus::DamageBonus(const DamageBonus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DamageBonus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonus_){}
    , decltype(_impl_.attribute_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.bonus_, &from._impl_.bonus_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.attribute_) -
    reinterpret_cast<char*>(&_impl_.bonus_)) + sizeof(_impl_.attribute_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.DamageBonus)
}

inline void DamageBonus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonus_){0}
    , decltype(_impl_.attribute_){1}
  };
}

DamageBonus::~DamageBonus() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.DamageBonus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DamageBonus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DamageBonus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DamageBonus::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.DamageBonus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.bonus_ = 0;
    _impl_.attribute_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DamageBonus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Attribute attribute = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Attribute_IsValid(val))) {
            _internal_set_attribute(static_cast<::SC2APIProtocol::Attribute>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float bonus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_bonus(&has_bits);
          _impl_.bonus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DamageBonus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.DamageBonus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.Attribute attribute = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_attribute(), target);
  }

  // optional float bonus = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_bonus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.DamageBonus)
  return target;
}

size_t DamageBonus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.DamageBonus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float bonus = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.Attribute attribute = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_attribute());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DamageBonus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DamageBonus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DamageBonus::GetClassData() const { return &_class_data_; }


void DamageBonus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DamageBonus*>(&to_msg);
  auto& from = static_cast<const DamageBonus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.DamageBonus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bonus_ = from._impl_.bonus_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.attribute_ = from._impl_.attribute_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DamageBonus::CopyFrom(const DamageBonus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.DamageBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DamageBonus::IsInitialized() const {
  return true;
}

void DamageBonus::InternalSwap(DamageBonus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.bonus_, other->_impl_.bonus_);
  swap(_impl_.attribute_, other->_impl_.attribute_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DamageBonus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fdata_2eproto_getter, &descriptor_table_s2clientprotocol_2fdata_2eproto_once,
      file_level_metadata_s2clientprotocol_2fdata_2eproto[1]);
}

// ===================================================================

class Weapon::_Internal {
 public:
  using HasBits = decltype(std::declval<Weapon>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attacks(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_range(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Weapon::Weapon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.Weapon)
}
Weapon::Weapon(const Weapon& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Weapon* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.damage_bonus_){from._impl_.damage_bonus_}
    , decltype(_impl_.damage_){}
    , decltype(_impl_.attacks_){}
    , decltype(_impl_.range_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.damage_, &from._impl_.damage_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.damage_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.Weapon)
}

inline void Weapon::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.damage_bonus_){arena}
    , decltype(_impl_.damage_){0}
    , decltype(_impl_.attacks_){0u}
    , decltype(_impl_.range_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.type_){1}
  };
}

Weapon::~Weapon() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.Weapon)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Weapon::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.damage_bonus_.~RepeatedPtrField();
}

void Weapon::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Weapon::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.Weapon)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.damage_bonus_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.damage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.damage_)) + sizeof(_impl_.speed_));
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Weapon::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Weapon.TargetType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Weapon_TargetType_IsValid(val))) {
            _internal_set_type(static_cast<::SC2APIProtocol::Weapon_TargetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float damage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_damage(&has_bits);
          _impl_.damage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.DamageBonus damage_bonus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_damage_bonus(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attacks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_attacks(&has_bits);
          _impl_.attacks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float range = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_range(&has_bits);
          _impl_.range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float speed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_speed(&has_bits);
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Weapon::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.Weapon)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .SC2APIProtocol.Weapon.TargetType type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float damage = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_damage(), target);
  }

  // repeated .SC2APIProtocol.DamageBonus damage_bonus = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_damage_bonus_size()); i < n; i++) {
    const auto& repfield = this->_internal_damage_bonus(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 attacks = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_attacks(), target);
  }

  // optional float range = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_range(), target);
  }

  // optional float speed = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.Weapon)
  return target;
}

size_t Weapon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.Weapon)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.DamageBonus damage_bonus = 3;
  total_size += 1UL * this->_internal_damage_bonus_size();
  for (const auto& msg : this->_impl_.damage_bonus_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float damage = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional uint32 attacks = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_attacks());
    }

    // optional float range = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float speed = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.Weapon.TargetType type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Weapon::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Weapon::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Weapon::GetClassData() const { return &_class_data_; }


void Weapon::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Weapon*>(&to_msg);
  auto& from = static_cast<const Weapon&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.Weapon)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.damage_bonus_.MergeFrom(from._impl_.damage_bonus_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.damage_ = from._impl_.damage_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.attacks_ = from._impl_.attacks_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.range_ = from._impl_.range_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Weapon::CopyFrom(const Weapon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.Weapon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Weapon::IsInitialized() const {
  return true;
}

void Weapon::InternalSwap(Weapon* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.damage_bonus_.InternalSwap(&other->_impl_.damage_bonus_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Weapon, _impl_.speed_)
      + sizeof(Weapon::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(Weapon, _impl_.damage_)>(
          reinterpret_cast<char*>(&_impl_.damage_),
          reinterpret_cast<char*>(&other->_impl_.damage_));
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Weapon::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fdata_2eproto_getter, &descriptor_table_s2clientprotocol_2fdata_2eproto_once,
      file_level_metadata_s2clientprotocol_2fdata_2eproto[2]);
}

// ===================================================================

class UnitTypeData::_Internal {
 public:
  using HasBits = decltype(std::declval<UnitTypeData>()._impl_._has_bits_);
  static void set_has_unit_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_available(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_cargo_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mineral_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_vespene_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_food_required(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_food_provided(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_race(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_build_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_has_vespene(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_has_minerals(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_sight_range(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_unit_alias(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_tech_requirement(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_require_attached(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_movement_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_armor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UnitTypeData::UnitTypeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.UnitTypeData)
}
UnitTypeData::UnitTypeData(const UnitTypeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnitTypeData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attributes_){from._impl_.attributes_}
    , decltype(_impl_.weapons_){from._impl_.weapons_}
    , decltype(_impl_.tech_alias_){from._impl_.tech_alias_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.unit_id_){}
    , decltype(_impl_.cargo_size_){}
    , decltype(_impl_.movement_speed_){}
    , decltype(_impl_.armor_){}
    , decltype(_impl_.mineral_cost_){}
    , decltype(_impl_.vespene_cost_){}
    , decltype(_impl_.food_required_){}
    , decltype(_impl_.ability_id_){}
    , decltype(_impl_.race_){}
    , decltype(_impl_.available_){}
    , decltype(_impl_.has_vespene_){}
    , decltype(_impl_.has_minerals_){}
    , decltype(_impl_.require_attached_){}
    , decltype(_impl_.build_time_){}
    , decltype(_impl_.food_provided_){}
    , decltype(_impl_.unit_alias_){}
    , decltype(_impl_.tech_requirement_){}
    , decltype(_impl_.sight_range_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.unit_id_, &from._impl_.unit_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sight_range_) -
    reinterpret_cast<char*>(&_impl_.unit_id_)) + sizeof(_impl_.sight_range_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.UnitTypeData)
}

inline void UnitTypeData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attributes_){arena}
    , decltype(_impl_.weapons_){arena}
    , decltype(_impl_.tech_alias_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.unit_id_){0u}
    , decltype(_impl_.cargo_size_){0u}
    , decltype(_impl_.movement_speed_){0}
    , decltype(_impl_.armor_){0}
    , decltype(_impl_.mineral_cost_){0u}
    , decltype(_impl_.vespene_cost_){0u}
    , decltype(_impl_.food_required_){0}
    , decltype(_impl_.ability_id_){0u}
    , decltype(_impl_.race_){0}
    , decltype(_impl_.available_){false}
    , decltype(_impl_.has_vespene_){false}
    , decltype(_impl_.has_minerals_){false}
    , decltype(_impl_.require_attached_){false}
    , decltype(_impl_.build_time_){0}
    , decltype(_impl_.food_provided_){0}
    , decltype(_impl_.unit_alias_){0u}
    , decltype(_impl_.tech_requirement_){0u}
    , decltype(_impl_.sight_range_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnitTypeData::~UnitTypeData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.UnitTypeData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnitTypeData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attributes_.~RepeatedField();
  _impl_.weapons_.~RepeatedPtrField();
  _impl_.tech_alias_.~RepeatedField();
  _impl_.name_.Destroy();
}

void UnitTypeData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnitTypeData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.UnitTypeData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attributes_.Clear();
  _impl_.weapons_.Clear();
  _impl_.tech_alias_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.unit_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.food_required_) -
        reinterpret_cast<char*>(&_impl_.unit_id_)) + sizeof(_impl_.food_required_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.ability_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.food_provided_) -
        reinterpret_cast<char*>(&_impl_.ability_id_)) + sizeof(_impl_.food_provided_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&_impl_.unit_alias_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sight_range_) -
        reinterpret_cast<char*>(&_impl_.unit_alias_)) + sizeof(_impl_.sight_range_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnitTypeData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 unit_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_unit_id(&has_bits);
          _impl_.unit_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.UnitTypeData.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool available = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_available(&has_bits);
          _impl_.available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cargo_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cargo_size(&has_bits);
          _impl_.cargo_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Attribute attributes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Attribute_IsValid(val))) {
              _internal_add_attributes(static_cast<::SC2APIProtocol::Attribute>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_attributes(), ptr, ctx, ::SC2APIProtocol::Attribute_IsValid, &_internal_metadata_, 8);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float movement_speed = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_movement_speed(&has_bits);
          _impl_.movement_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float armor = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_armor(&has_bits);
          _impl_.armor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Weapon weapons = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_weapons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mineral_cost = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_mineral_cost(&has_bits);
          _impl_.mineral_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 vespene_cost = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_vespene_cost(&has_bits);
          _impl_.vespene_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float food_required = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_food_required(&has_bits);
          _impl_.food_required_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ability_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_ability_id(&has_bits);
          _impl_.ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Race race = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Race_IsValid(val))) {
            _internal_set_race(static_cast<::SC2APIProtocol::Race>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float build_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_build_time(&has_bits);
          _impl_.build_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float food_provided = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_food_provided(&has_bits);
          _impl_.food_provided_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_vespene = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_has_vespene(&has_bits);
          _impl_.has_vespene_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_minerals = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_has_minerals(&has_bits);
          _impl_.has_minerals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 tech_alias = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_tech_alias(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
        } else if (static_cast<uint8_t>(tag) == 170) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_tech_alias(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unit_alias = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_unit_alias(&has_bits);
          _impl_.unit_alias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tech_requirement = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_tech_requirement(&has_bits);
          _impl_.tech_requirement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool require_attached = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_require_attached(&has_bits);
          _impl_.require_attached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float sight_range = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _Internal::set_has_sight_range(&has_bits);
          _impl_.sight_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnitTypeData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.UnitTypeData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 unit_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_unit_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.UnitTypeData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional bool available = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_available(), target);
  }

  // optional uint32 cargo_size = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cargo_size(), target);
  }

  // repeated .SC2APIProtocol.Attribute attributes = 8;
  for (int i = 0, n = this->_internal_attributes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        8, this->_internal_attributes(i), target);
  }

  // optional float movement_speed = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_movement_speed(), target);
  }

  // optional float armor = 10;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_armor(), target);
  }

  // repeated .SC2APIProtocol.Weapon weapons = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_weapons_size()); i < n; i++) {
    const auto& repfield = this->_internal_weapons(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 mineral_cost = 12;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_mineral_cost(), target);
  }

  // optional uint32 vespene_cost = 13;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_vespene_cost(), target);
  }

  // optional float food_required = 14;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_food_required(), target);
  }

  // optional uint32 ability_id = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_ability_id(), target);
  }

  // optional .SC2APIProtocol.Race race = 16;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_race(), target);
  }

  // optional float build_time = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_build_time(), target);
  }

  // optional float food_provided = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_food_provided(), target);
  }

  // optional bool has_vespene = 19;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_has_vespene(), target);
  }

  // optional bool has_minerals = 20;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_has_minerals(), target);
  }

  // repeated uint32 tech_alias = 21;
  for (int i = 0, n = this->_internal_tech_alias_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_tech_alias(i), target);
  }

  // optional uint32 unit_alias = 22;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_unit_alias(), target);
  }

  // optional uint32 tech_requirement = 23;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_tech_requirement(), target);
  }

  // optional bool require_attached = 24;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_require_attached(), target);
  }

  // optional float sight_range = 25;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(25, this->_internal_sight_range(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.UnitTypeData)
  return target;
}

size_t UnitTypeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.UnitTypeData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.Attribute attributes = 8;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_attributes_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_attributes(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .SC2APIProtocol.Weapon weapons = 11;
  total_size += 1UL * this->_internal_weapons_size();
  for (const auto& msg : this->_impl_.weapons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 tech_alias = 21;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.tech_alias_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_tech_alias_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 unit_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unit_id());
    }

    // optional uint32 cargo_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cargo_size());
    }

    // optional float movement_speed = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float armor = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 mineral_cost = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mineral_cost());
    }

    // optional uint32 vespene_cost = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vespene_cost());
    }

    // optional float food_required = 14;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 ability_id = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ability_id());
    }

    // optional .SC2APIProtocol.Race race = 16;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_race());
    }

    // optional bool available = 3;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool has_vespene = 19;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool has_minerals = 20;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool require_attached = 24;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional float build_time = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional float food_provided = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 unit_alias = 22;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_unit_alias());
    }

    // optional uint32 tech_requirement = 23;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tech_requirement());
    }

    // optional float sight_range = 25;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnitTypeData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnitTypeData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnitTypeData::GetClassData() const { return &_class_data_; }


void UnitTypeData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnitTypeData*>(&to_msg);
  auto& from = static_cast<const UnitTypeData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.UnitTypeData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attributes_.MergeFrom(from._impl_.attributes_);
  _this->_impl_.weapons_.MergeFrom(from._impl_.weapons_);
  _this->_impl_.tech_alias_.MergeFrom(from._impl_.tech_alias_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.unit_id_ = from._impl_.unit_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cargo_size_ = from._impl_.cargo_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.movement_speed_ = from._impl_.movement_speed_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.armor_ = from._impl_.armor_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.mineral_cost_ = from._impl_.mineral_cost_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.vespene_cost_ = from._impl_.vespene_cost_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.food_required_ = from._impl_.food_required_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.ability_id_ = from._impl_.ability_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.race_ = from._impl_.race_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.available_ = from._impl_.available_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.has_vespene_ = from._impl_.has_vespene_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.has_minerals_ = from._impl_.has_minerals_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.require_attached_ = from._impl_.require_attached_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.build_time_ = from._impl_.build_time_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.food_provided_ = from._impl_.food_provided_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.unit_alias_ = from._impl_.unit_alias_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.tech_requirement_ = from._impl_.tech_requirement_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.sight_range_ = from._impl_.sight_range_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnitTypeData::CopyFrom(const UnitTypeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.UnitTypeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnitTypeData::IsInitialized() const {
  return true;
}

void UnitTypeData::InternalSwap(UnitTypeData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attributes_.InternalSwap(&other->_impl_.attributes_);
  _impl_.weapons_.InternalSwap(&other->_impl_.weapons_);
  _impl_.tech_alias_.InternalSwap(&other->_impl_.tech_alias_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnitTypeData, _impl_.sight_range_)
      + sizeof(UnitTypeData::_impl_.sight_range_)
      - PROTOBUF_FIELD_OFFSET(UnitTypeData, _impl_.unit_id_)>(
          reinterpret_cast<char*>(&_impl_.unit_id_),
          reinterpret_cast<char*>(&other->_impl_.unit_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UnitTypeData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fdata_2eproto_getter, &descriptor_table_s2clientprotocol_2fdata_2eproto_once,
      file_level_metadata_s2clientprotocol_2fdata_2eproto[3]);
}

// ===================================================================

class UpgradeData::_Internal {
 public:
  using HasBits = decltype(std::declval<UpgradeData>()._impl_._has_bits_);
  static void set_has_upgrade_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mineral_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vespene_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_research_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UpgradeData::UpgradeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.UpgradeData)
}
UpgradeData::UpgradeData(const UpgradeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpgradeData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.upgrade_id_){}
    , decltype(_impl_.mineral_cost_){}
    , decltype(_impl_.vespene_cost_){}
    , decltype(_impl_.research_time_){}
    , decltype(_impl_.ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.upgrade_id_, &from._impl_.upgrade_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ability_id_) -
    reinterpret_cast<char*>(&_impl_.upgrade_id_)) + sizeof(_impl_.ability_id_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.UpgradeData)
}

inline void UpgradeData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.upgrade_id_){0u}
    , decltype(_impl_.mineral_cost_){0u}
    , decltype(_impl_.vespene_cost_){0u}
    , decltype(_impl_.research_time_){0}
    , decltype(_impl_.ability_id_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpgradeData::~UpgradeData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.UpgradeData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpgradeData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void UpgradeData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpgradeData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.UpgradeData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.upgrade_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ability_id_) -
        reinterpret_cast<char*>(&_impl_.upgrade_id_)) + sizeof(_impl_.ability_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpgradeData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 upgrade_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_upgrade_id(&has_bits);
          _impl_.upgrade_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.UpgradeData.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mineral_cost = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mineral_cost(&has_bits);
          _impl_.mineral_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 vespene_cost = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vespene_cost(&has_bits);
          _impl_.vespene_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float research_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_research_time(&has_bits);
          _impl_.research_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ability_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ability_id(&has_bits);
          _impl_.ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpgradeData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.UpgradeData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 upgrade_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_upgrade_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.UpgradeData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional uint32 mineral_cost = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_mineral_cost(), target);
  }

  // optional uint32 vespene_cost = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_vespene_cost(), target);
  }

  // optional float research_time = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_research_time(), target);
  }

  // optional uint32 ability_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_ability_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.UpgradeData)
  return target;
}

size_t UpgradeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.UpgradeData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 upgrade_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_upgrade_id());
    }

    // optional uint32 mineral_cost = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mineral_cost());
    }

    // optional uint32 vespene_cost = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vespene_cost());
    }

    // optional float research_time = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 ability_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ability_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpgradeData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpgradeData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpgradeData::GetClassData() const { return &_class_data_; }


void UpgradeData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpgradeData*>(&to_msg);
  auto& from = static_cast<const UpgradeData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.UpgradeData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.upgrade_id_ = from._impl_.upgrade_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mineral_cost_ = from._impl_.mineral_cost_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vespene_cost_ = from._impl_.vespene_cost_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.research_time_ = from._impl_.research_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ability_id_ = from._impl_.ability_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpgradeData::CopyFrom(const UpgradeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.UpgradeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeData::IsInitialized() const {
  return true;
}

void UpgradeData::InternalSwap(UpgradeData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpgradeData, _impl_.ability_id_)
      + sizeof(UpgradeData::_impl_.ability_id_)
      - PROTOBUF_FIELD_OFFSET(UpgradeData, _impl_.upgrade_id_)>(
          reinterpret_cast<char*>(&_impl_.upgrade_id_),
          reinterpret_cast<char*>(&other->_impl_.upgrade_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpgradeData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fdata_2eproto_getter, &descriptor_table_s2clientprotocol_2fdata_2eproto_once,
      file_level_metadata_s2clientprotocol_2fdata_2eproto[4]);
}

// ===================================================================

class BuffData::_Internal {
 public:
  using HasBits = decltype(std::declval<BuffData>()._impl_._has_bits_);
  static void set_has_buff_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BuffData::BuffData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.BuffData)
}
BuffData::BuffData(const BuffData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BuffData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.buff_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.buff_id_ = from._impl_.buff_id_;
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.BuffData)
}

inline void BuffData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.buff_id_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BuffData::~BuffData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.BuffData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BuffData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void BuffData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BuffData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.BuffData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.buff_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BuffData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 buff_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_buff_id(&has_bits);
          _impl_.buff_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.BuffData.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BuffData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.BuffData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 buff_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_buff_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.BuffData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.BuffData)
  return target;
}

size_t BuffData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.BuffData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 buff_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_buff_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BuffData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BuffData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BuffData::GetClassData() const { return &_class_data_; }


void BuffData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BuffData*>(&to_msg);
  auto& from = static_cast<const BuffData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.BuffData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.buff_id_ = from._impl_.buff_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BuffData::CopyFrom(const BuffData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.BuffData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuffData::IsInitialized() const {
  return true;
}

void BuffData::InternalSwap(BuffData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.buff_id_, other->_impl_.buff_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BuffData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fdata_2eproto_getter, &descriptor_table_s2clientprotocol_2fdata_2eproto_once,
      file_level_metadata_s2clientprotocol_2fdata_2eproto[5]);
}

// ===================================================================

class EffectData::_Internal {
 public:
  using HasBits = decltype(std::declval<EffectData>()._impl_._has_bits_);
  static void set_has_effect_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

EffectData::EffectData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SC2APIProtocol.EffectData)
}
EffectData::EffectData(const EffectData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EffectData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.friendly_name_){}
    , decltype(_impl_.effect_id_){}
    , decltype(_impl_.radius_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.friendly_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_friendly_name()) {
    _this->_impl_.friendly_name_.Set(from._internal_friendly_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.effect_id_, &from._impl_.effect_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.radius_) -
    reinterpret_cast<char*>(&_impl_.effect_id_)) + sizeof(_impl_.radius_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.EffectData)
}

inline void EffectData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.friendly_name_){}
    , decltype(_impl_.effect_id_){0u}
    , decltype(_impl_.radius_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.friendly_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EffectData::~EffectData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.EffectData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EffectData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.friendly_name_.Destroy();
}

void EffectData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EffectData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.EffectData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.friendly_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.effect_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.radius_) -
        reinterpret_cast<char*>(&_impl_.effect_id_)) + sizeof(_impl_.radius_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EffectData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 effect_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_effect_id(&has_bits);
          _impl_.effect_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.EffectData.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string friendly_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_friendly_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "SC2APIProtocol.EffectData.friendly_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EffectData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.EffectData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 effect_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_effect_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.EffectData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string friendly_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friendly_name().data(), static_cast<int>(this->_internal_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.EffectData.friendly_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_friendly_name(), target);
  }

  // optional float radius = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.EffectData)
  return target;
}

size_t EffectData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.EffectData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string friendly_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friendly_name());
    }

    // optional uint32 effect_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_effect_id());
    }

    // optional float radius = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EffectData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EffectData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EffectData::GetClassData() const { return &_class_data_; }


void EffectData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EffectData*>(&to_msg);
  auto& from = static_cast<const EffectData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.EffectData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_friendly_name(from._internal_friendly_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.effect_id_ = from._impl_.effect_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EffectData::CopyFrom(const EffectData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.EffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EffectData::IsInitialized() const {
  return true;
}

void EffectData::InternalSwap(EffectData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.friendly_name_, lhs_arena,
      &other->_impl_.friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EffectData, _impl_.radius_)
      + sizeof(EffectData::_impl_.radius_)
      - PROTOBUF_FIELD_OFFSET(EffectData, _impl_.effect_id_)>(
          reinterpret_cast<char*>(&_impl_.effect_id_),
          reinterpret_cast<char*>(&other->_impl_.effect_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EffectData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_s2clientprotocol_2fdata_2eproto_getter, &descriptor_table_s2clientprotocol_2fdata_2eproto_once,
      file_level_metadata_s2clientprotocol_2fdata_2eproto[6]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::AbilityData*
Arena::CreateMaybeMessage< ::SC2APIProtocol::AbilityData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::AbilityData >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::DamageBonus*
Arena::CreateMaybeMessage< ::SC2APIProtocol::DamageBonus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::DamageBonus >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::Weapon*
Arena::CreateMaybeMessage< ::SC2APIProtocol::Weapon >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::Weapon >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::UnitTypeData*
Arena::CreateMaybeMessage< ::SC2APIProtocol::UnitTypeData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::UnitTypeData >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::UpgradeData*
Arena::CreateMaybeMessage< ::SC2APIProtocol::UpgradeData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::UpgradeData >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::BuffData*
Arena::CreateMaybeMessage< ::SC2APIProtocol::BuffData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::BuffData >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::EffectData*
Arena::CreateMaybeMessage< ::SC2APIProtocol::EffectData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SC2APIProtocol::EffectData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
